<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Minibase</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.colafornia.me/"/>
  <updated>2019-04-01T09:54:37.167Z</updated>
  <id>https://blog.colafornia.me/</id>
  
  <author>
    <name>Colafornia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019.3 Webpack 升级改造小记</title>
    <link href="https://blog.colafornia.me/post/2019/2019-webpack-optimization/"/>
    <id>https://blog.colafornia.me/post/2019/2019-webpack-optimization/</id>
    <published>2019-03-31T10:00:00.000Z</published>
    <updated>2019-04-01T09:54:37.167Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2019-3-webpack.png" alt="webpack"></p><blockquote><p>时间：2019.3<br>Webpack 稳定版本为4, 正在 5 的 roadmap 中<br>记录一下当前时间对前端项目构建打包优化的策略</p></blockquote><a id="more"></a><h2 id="当前项目问题"><a href="#当前项目问题" class="headerlink" title="当前项目问题"></a>当前项目问题</h2><p>我们的前端项目基本都是使用的是 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> 的配置，冗余项太多，升级难。</p><p>在这个前提下，有个“极限项目”每次代码改动之后的 hot reload 都需要 30s，实在坐不住了，就动手做了打包升级。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/1/169d84da7c4abd59?w=1968&amp;h=806&amp;f=png&amp;s=237856" alt="before"></p><p>这次是从代码依赖相对简单，后续测试回滚负担小的后台管理系统下手的。</p><p>总结下当前的痛点为：</p><ol><li>项目启动慢</li><li>Hot reload 慢</li><li>Build 慢（上线前在后端项目里 build 时尤其明显）</li><li>没分包，文件体积太大</li></ol><h2 id="解决手段"><a href="#解决手段" class="headerlink" title="解决手段"></a>解决手段</h2><p>首先把 Webpack 版本从 3 升到 4，起码先享受上工具本身升级后带来的优越性</p><h3 id="1-分离配置文件（与性能无关，与开发维护体验有关）"><a href="#1-分离配置文件（与性能无关，与开发维护体验有关）" class="headerlink" title="1.分离配置文件（与性能无关，与开发维护体验有关）"></a>1.分离配置文件（与性能无关，与开发维护体验有关）</h3><p>分成 base、dev、prod 三个 config 文件</p><p>把通用配置放到 base 中，dev 与 prod 中只放与这两种模式强相关的配置</p><h3 id="2-HappyPack"><a href="#2-HappyPack" class="headerlink" title="2.HappyPack"></a>2.HappyPack</h3><p><img src="https://user-gold-cdn.xitu.io/2019/4/1/169d848b9c8f44bd?w=750&amp;h=830&amp;f=png&amp;s=88315" alt="HappyPack"></p><p>治疗各种编译慢</p><p>本地启动 server 编译时间： 30s =&gt; 10s</p><h3 id="3-splitChunks-分包"><a href="#3-splitChunks-分包" class="headerlink" title="3.splitChunks 分包"></a>3.splitChunks 分包</h3><p><img src="https://user-gold-cdn.xitu.io/2019/4/1/169d849f457b12e1?w=1007&amp;h=799&amp;f=png&amp;s=121585" alt="splitChunks"></p><p>这一功能在之前版本中是通过 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">CommonsChunkPlugin</a> 来进行的。</p><p>初步分成三个包，减小 main 包体积。</p><p>根据业务特点，其实可以做懒加载，但是注意不能分太多，增加 http 请求数得不偿失。后台管理项目体积目前不大，各模块也没什么业务上的明显区分，就没啥做懒加载的必要。</p><p>结果：包体积：6M =&gt; 3M</p><h3 id="4-将第三方巨型包打入-externals"><a href="#4-将第三方巨型包打入-externals" class="headerlink" title="4.将第三方巨型包打入 externals"></a>4.将第三方巨型包打入 externals</h3><p>经过以上分包后，用 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">BundleAnalyzerPlugin</a> 看了下结果</p><p>发现有个非常显眼的巨型包 <code>echarts</code></p><p>把它的 min.js 扔到公司 cdn 上，在 html 中直接引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  echarts: <span class="string">'echarts'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果也很明显，当时没截图，就不贴对比图了</p><h3 id="5-gzip"><a href="#5-gzip" class="headerlink" title="5.gzip"></a>5.gzip</h3><p><img src="https://user-gold-cdn.xitu.io/2019/4/1/169d84edf289f6a2?w=1462&amp;h=324&amp;f=png&amp;s=96245" alt="after"></p><p>通过引入 CompressionWebpackPlugin 插件，打出来 .js.gz 资源，在服务器已支持 gzip 的情况下，所加载资源体积（直接到了 1.3M）和时间提升非常明显</p><h3 id="6-常规操作"><a href="#6-常规操作" class="headerlink" title="6.常规操作"></a>6.常规操作</h3><p>还有很多升到 webpack@4 之后的常规操作：</p><blockquote><p>MiniCssExtractPlugin<br>TerserPlugin<br>OptimizeCSSAssetsPlugin<br>等等</p></blockquote><p>随便搜搜，或者按图索骥去最新版的 create-react-app 源码里看看用了啥就行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2019-3-webpack.png&quot; alt=&quot;webpack&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间：2019.3&lt;br&gt;Webpack 稳定版本为4, 正在 5 的 roadmap 中&lt;br&gt;记录一下当前时间对前端项目构建打包优化的策略&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://blog.colafornia.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>2018 年度总结</title>
    <link href="https://blog.colafornia.me/post/2019/2018-review/"/>
    <id>https://blog.colafornia.me/post/2019/2018-review/</id>
    <published>2019-01-02T04:00:00.000Z</published>
    <updated>2019-02-13T07:05:14.274Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/chengdu-2018.jpeg" alt="chengdu in 2018"></p><p>2018: have some fun</p><a id="more"></a><h3 id="工作与学习"><a href="#工作与学习" class="headerlink" title="工作与学习"></a>工作与学习</h3><p>说来有点打脸，去年的年终总结写完不久，我就申请了内部转岗到成都研发中心，比预计至少早了两三年离京。</p><p>新部门属于公司内为数不多使用 <code>React + Node 中间层</code>技术栈的团队，对我而言也是很不错的机会，连滚带爬地学习了一波，勉强跟上趟了。下半年开始有机会独自 backup 一个小业务项目，也就对公司当前的微服务架构，构建部署流程，Node 服务的线上运维，问题排查更为熟练了，这是在公司业务中的主要收获。</p><p>从 17 年年底，我开始写一个 side project <a href="https://github.com/Colafornia/little-robot" target="_blank" rel="noopener">「little-robot」</a>，一开始只是一个为了熟悉 Node 服务端开发部署而写的小脚本，夏天终于有时间给它做了一次升级，搭建了 <code>Koa Server</code>，封装成 api，基于 <code>Docker</code> 实现了构建部署与持续集成。最后还厚着脸皮在掘金上推广了一波，目前用户量稳定在 100+，Github Star 60+，对于我而言是个不小的鼓舞。</p><p>在上一个年终总结里立的一个 Flag 是 “<strong>Leetcode 每周一题</strong>”，万万没想到最后还是完成了(在 18 年的最后两个月里突击完成😂)。<a href="http://blog.colafornia.me/leetcode-solutions/">「leetcode-solutions」</a> 完成了 54 个题目，一边复习数据结构和算法知识一边刷题，题目最多覆盖到动态规划。最大的收获应该是找到了做算法题的快乐(传说中的用算法娱乐身心)，希望把算法学习能够作为一个长期习惯保持下去。</p><p>今年的一个重点学习项目是 <strong>iOS 开发</strong>，花了蛮多时间学习 <code>Objective-C</code> 语法，已经可以照着文档画一些简单的交互页面。目前粗浅的感觉 iOS 开发还是很规整，Xcode 功能齐全，在 IDE 里看文档非常舒服。主要是战线拉的太长，这些准备工作都做完之后，有点失去耐心转去做算法题了，还是要有个 deadline 短期集中精力来做更好些。新的一年要把这一块的学习完成，完成一个成品 iOS App。</p><p>博客有 <strong>11 篇</strong>，翻译方面也还是做了一些，翻译了很多长文，积分足够兑换了一个 GDD 的音响。十一假期完成了<a href="https://blog.colafornia.me/post/2018/translation-blink-render/">Blink 演讲视频的翻译</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680f3b73a1f6d7c?w=914&h=990&f=png&s=250226" width="450"></p><p>完全没有进展的内容是 CS 公开课学习，又当了一年的野生程序员，计算机基础方面除了算法几乎没什么进步。</p><h3 id="生活与玩乐"><a href="#生活与玩乐" class="headerlink" title="生活与玩乐"></a>生活与玩乐</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680d1bed2c2457e?w=4032&amp;h=3024&amp;f=jpeg&amp;s=4161789" alt="Phuket"></p><p>下定决心回成都之后，对自己的一个期许是“更好的体验生活”，所以今年的生活娱乐还是很丰富多彩的。</p><h4 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h4><p>今年四月带我妈去了普吉岛+曼谷玩，上面这张照片便是去斯米兰岛潜水时拍的。普吉岛非常好玩，景色和水质都很不错，消费水平也不高，两个人吃一顿海鲜烧烤最多也才 100RMB 左右，再去夜市买点水果小吃简直美滋滋。每天去便利店买一大袋零食，酸奶，加起来最多不超过 30RMB。去斯米兰潜水的一天也很爽，当时那个季节水面很稳，没有晕船，我在当地租了一个 GoPro5，在水下录的很嗨皮。</p><p>但曼谷的观感就很一般，堵车程度是帝都两倍，购物中心也没有什么实惠or限定的东西可买。好在只在曼谷停留了两天，本着来都来了的态度还是去大皇宫逛了逛，也有了用 Grab 叫车，和司机用蹩脚的英文乱侃的体验。</p><p>总而言之还是一趟很完满的旅行，第一次由我带着妈妈出国玩，她体验了这一波 Airbnb，Grab，全程只管拍照就行，也玩的很开心。决定以后每年都带妈妈出一趟远门✌️。</p><p>除此之外还去了乐山吃了三天，以及甘孜阿坝爬山，成都以及四川周边好玩的地方还是很多，应该趁机多去周边玩玩。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680d1b8e9bee2f2?w=1080&h=1080&f=jpeg&s=455228" width="450"></p><h4 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h4><p>回成都之后便考察了一下软件园的健身房，选定一家买了私教课，由教练带着练了三个月，之后便是自己练了。</p><p>成果还是比较满意的，体态纠正了不少，终于能在70%的时间里都站直了，心肺功能也有一定改善，感觉还是全靠健身才保证了来成都后每天胡吃海喝也没胖……</p><p>只是到了冬天之后没再坚持锻炼，有点可惜，健身期间的精神头真的很不一样。</p><h4 id="Live"><a href="#Live" class="headerlink" title="Live"></a>Live</h4><p>总结回来，这一年也听了几场 Live:</p><blockquote><ol><li>The xx -I See You Tour@北京展览馆</li><li>Hello Nico「慢慢，而远」@成都小酒馆</li><li>沼泽乐队「争鸣二十年」@成都小酒馆</li><li>惘闻乐队 「看不见的城市」@成都小酒馆</li></ol></blockquote><p>这篇文章的题图便是沼泽乐队的现场照片。成都这边还是有很多听现场 Live 的机会，票也并不贵，年中工作不忙的时候与朋友去听了几场，散场后去吃冰粉、串串，也是非常美滋滋。</p><h4 id="观影与阅读"><a href="#观影与阅读" class="headerlink" title="观影与阅读"></a>观影与阅读</h4><p>观影量与往年持平，阅片内容也没太大变化，还是商业片为主，独立电影看了一小部分。</p><p>比较欣慰的是今年看了不少书，有 <strong>32 本</strong>，大概是去年阅读量的两倍。</p><p>其中还是技术书居多，把早些时间买的迟迟没有看完的实体书都 K 掉了，因为焦虑程度比在北京好了不少，也总算有心情看些非技术类的书。</p><h4 id="年度最佳清单"><a href="#年度最佳清单" class="headerlink" title="年度最佳清单"></a>年度最佳清单</h4><p><strong>观影最佳：</strong></p><blockquote><ol><li>《西部世界 第二季》</li><li>《横道世之介》</li><li>《Call Me by Your Name》</li></ol></blockquote><p><strong>阅读最佳：</strong></p><blockquote><p>技术类</p><ol><li>《JavaScript 语言精粹》</li><li>《Objective-C 编程（第2版）》</li><li>《深入React技术栈》</li></ol></blockquote><blockquote><p>非技术类</p><ol><li>《十一种孤独》</li><li>《费马大定理》</li><li>《为人文教育辩护》</li></ol></blockquote><p><strong>好物最佳：</strong></p><blockquote><ol><li>除湿机</li><li>Kindle Oasis2</li><li>发热猫窝(有了这个窝之后，家猫几乎没在别的地方睡过觉，使用率100%)</li></ol></blockquote><h3 id="新的期许"><a href="#新的期许" class="headerlink" title="新的期许"></a>新的期许</h3><p>又到了新年 Flag 时间~</p><p>工作学习方面：</p><ol><li>拓端，完成一个 iOS 成品 App</li><li>Leetcode 不能停，2019年进度完成到 100 题(目标定得挺低的)</li><li>补足 CS 基础，通过 HIT 的基础课学习</li><li>开源两个完整的 Side Project</li></ol><p>生活方面：</p><ol><li>阅读量 35 本+</li><li>至少去两个没去过的城市玩</li><li>体重减掉 5kg</li><li>培养一个新爱好(这条很虚，但又很必要)</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680f450efa89bad?w=1200&amp;h=900&amp;f=png&amp;s=938194" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/chengdu-2018.jpeg&quot; alt=&quot;chengdu in 2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;2018: have some fun&lt;/p&gt;
    
    </summary>
    
      <category term="summary" scheme="https://blog.colafornia.me/categories/summary/"/>
    
    
  </entry>
  
  <entry>
    <title>8102年末，前端路由基本思路</title>
    <link href="https://blog.colafornia.me/post/2018/implement-of-frontend-route/"/>
    <id>https://blog.colafornia.me/post/2018/implement-of-frontend-route/</id>
    <published>2018-11-12T12:00:00.000Z</published>
    <updated>2019-02-13T07:05:14.279Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/router/cover.jpg" alt="cover"></p><p>最近看了一些相关资料，特地来整理一下，当前前端主流路由 <code>react-router</code>、<code>vue-router</code> 的实现思路，内容不多也并不复杂，作为知识体系的补全。</p><a id="more"></a><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>此处默认你已经至少使用过主流框架 Router 中的一种，那就肯定知道路由配置时肯定会有个配置项是关于，使用 <code>hash</code> 模式还是 <code>history</code> 模式。</p><p><img src="/images/router/01.jpg" alt=""></p><div style="text-align:center">vue-router 通过给实例传入 <code>mode</code> 字段来设置</div><p><img src="/images/router/02.jpg" alt=""></p><div style="text-align:center">react-router 则通过直接使用不同的路由组件进行区分</div><p>这两种模式便是目前我们在浏览器环境中为单页应用实现“<strong>无需重载页面即可更新视图</strong>”的原理。</p><p>接下来我们分别进行分析。</p><h3 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h3><p>url 中使用了 hash 符号 <code>#</code> 后的内容便属于 <code>fragment</code>。</p><p><img src="/images/router/03.jpg" alt=""></p><p>有别于 url 中的 <code>?</code> 符号，<code>fragment</code> 设计之初便是为了<code>锚点</code>这一特性，通过 <code>fragment</code> 指定网页中的位置，浏览器会匹配到 id 或 name 为 <code>fragment</code> 值的 a 标签，将其滚动到可视区域的顶部。</p><p>除此之外，<code>fragment</code> 还具备以下三个特性：</p><ol><li>修改#后的 <code>fragment</code> 值不会导致页面重新加载，但是会改变浏览器的历史记录</li><li>作为 url 发起 HTTP 请求时，<code>fragment</code> 部分不会被包含在请求头中，也就不会被发送到服务器</li><li><code>fragment</code> 一般不会被搜索引擎收录（虽然 Google 也出了相应对策作为补救，但整体上这种模式对 SEO 依然算不上不友好）</li></ol><p>那 hash 模式是如何进行路由的呢？</p><p>通过监听 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchange" target="_blank" rel="noopener">onhashchange</a> 事件即可捕获 hash 值的改变然后执行后续的更新视图逻辑（具体实现后面再解释）。</p><h3 id="history-模式（又名-browser-模式、HTML5-模式）"><a href="#history-模式（又名-browser-模式、HTML5-模式）" class="headerlink" title="history 模式（又名 browser 模式、HTML5 模式）"></a>history 模式（又名 browser 模式、HTML5 模式）</h3><p>这一模式的实现基于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" rel="noopener">Web API 中的 History</a>，浏览器工具栏的前进与后退实际上也是在操作 <code>History</code>。</p><p>其中，<code>History.pushState()</code> 与 <code>History.replaceState()</code> 让我们可以实现路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(stateObject, title, URL);</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(stateObject, title, URL);</span><br></pre></td></tr></table></figure><p>两者用法类似，<strong>URL 必须为与当前页面属于同域</strong>。这两个方法执行之后都会使得浏览器地址栏更新，但不跳转，同时 <code>History.state</code> 对象也将更新为传入的 URL 值，这就为前端路由的实现提供可能。</p><p>每当 <code>History</code> 对象发生变化，都会触发 <code>popstate</code> 事件，同理，我们可以通过监听这一事件，在回调中执行路由匹配逻辑。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><code>vue-router</code> 的源码更为易读，几个版本下来 API 变化也不是很大，此处以 <code>vue-router</code> 源码作为示例。</p><p>先看<a href="https://github.com/vuejs/vue-router/tree/dev/src" target="_blank" rel="noopener">目录结构</a>：</p><p><img src="/images/router/04.jpg" alt=""></p><p>components 文件夹中便是涉及到视图更新的 <code>Link</code> 与 <code>RouterView</code> 组件，history 文件中涉及到我们刚刚提到的浏览器中两种路由模式。</p><p>先看入口文件<a href="https://github.com/vuejs/vue-router/blob/dev/src/index.js" target="_blank" rel="noopener">https://github.com/vuejs/vue-router/blob/dev/src/index.js</a></p><p>在构造器中进行了 <code>mode</code> 读取，可以得知 vue-router 默认使用 <code>hash 模式</code>：</p><p><img src="/images/router/05.jpg" alt=""></p><p>在 switch 函数中分别调用各自模式对路由的 history 对象进行加工。随后调用 <a href="https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/install.js" target="_blank" rel="noopener">install.js</a> 将 vue-router 混入 Vue 实例中：</p><p><img src="/images/router/06.jpg" alt=""></p><p>通过全局的 Mixin 对象，在 Vue 实例的 <code>beforeCreate</code> 钩子函数中将其混入，并将两个组件进行挂载。</p><p>那两个针对不同模式下 histroy 的包装方法呢？</p><p>以 <a href="https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/history/hash.js" target="_blank" rel="noopener">hash.js</a>为例：</p><p><img src="/images/router/07.jpg" alt=""><br>先是设置了事件监听，然后声明了 go、push、replace 等方法。</p><p>其中 <code>supportsPushState</code> 是工具方法，通过 <code>window.navigator.userAgent</code> 读取设备信息判断移动端设备是否支持。</p><p>从 go、push、replace 等方法的实现可以看出，基本都是通过在history 基础上改写的 <a href="https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/util/push-state.js" target="_blank" rel="noopener">pushState</a> 方法实现的。</p><p>hash.js 还有一些针对 hash 模式特有的方法如 <code>ensureSlash()</code>，其余实现思路基本与 <a href="https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/history/html5.js" target="_blank" rel="noopener">html5.js</a> 相同。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>所以在不借助框架的情况下如何实现一个极简版的前端路由也不是什么难题了，<a href="https://github.com/Colafornia/Wheels/blob/master/Router/index.js" target="_blank" rel="noopener">Wheels/Router</a> 轻松写两种~</p><p>关于实际工程中使用的路由其实还有很多边界情况需要处理，<code>react-router</code> 与 <code>vue-router</code> 结合各自框架实例与上下文，实现了非常简洁高效的路由机制，推荐大家阅读源码好好挖掘一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/router/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近看了一些相关资料，特地来整理一下，当前前端主流路由 &lt;code&gt;react-router&lt;/code&gt;、&lt;code&gt;vue-router&lt;/code&gt; 的实现思路，内容不多也并不复杂，作为知识体系的补全。&lt;/p&gt;
    
    </summary>
    
      <category term="route javascript" scheme="https://blog.colafornia.me/categories/route-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Blink 渲染： 重建引擎</title>
    <link href="https://blog.colafornia.me/post/2018/translation-blink-render/"/>
    <id>https://blog.colafornia.me/post/2018/translation-blink-render/</id>
    <published>2018-10-07T11:30:00.000Z</published>
    <updated>2019-02-13T07:05:14.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f666cf2441?w=1920&amp;h=1080&amp;f=jpeg&amp;s=142074" alt="cover"></p><blockquote><p>本文系掘金委托翻译整理的 BlinkOn9 会议演讲内容<br>演讲资料 <a href="https://www.youtube.com/watch?v=ExNYN_phaxI" target="_blank" rel="noopener">视频</a>/ <a href="https://docs.google.com/presentation/d/1Iko1oIYb-VHwOOFU3rBPUcOO_9lAd3NutYluATgzV_0/edit#slide=id.g36f1b50c08_0_3702" target="_blank" rel="noopener">PPT</a></p></blockquote><p>在 <code>BlinkOn9</code> 会议中，Google Blink 团队开发者 Philip Rogers 与 Stefan Zager 进行了<a href="https://www.youtube.com/watch?v=ExNYN_phaxI" target="_blank" rel="noopener">《Blink Rendering - Rebuilding the Engine Mid-Flight》分享</a>，旨在介绍 Blink 渲染的基本原理与开发团队近期对滚动性能、绘制合成与排版的改进。</p><a id="more"></a><h2 id="第一部分：渲染是什么？"><a href="#第一部分：渲染是什么？" class="headerlink" title="第一部分：渲染是什么？"></a>第一部分：渲染是什么？</h2><p>简单来说，渲染是浏览器的某种基础功能，它将你的 HTML 和 CSS 解析成 DOM 树，并将其转换成屏幕上的像素点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f44edfa7af?w=1560&amp;h=884&amp;f=jpeg&amp;s=80469" alt=""></p><p>图中显示了 <code>document</code> 生命周期的主要阶段，中间四个黑色框是渲染流水线（<code>render pipeline</code>）。</p><p>我一直认为研究 Chrome 的追踪器有助于理解 document 生命周期。因此，下图是一个渲染进程的 Chrome 追踪器面板，图中的高亮区域是渲染主线程，底部的一小部分属于合成器线程（<code>compositor thread</code>）。在渲染的开始，我们可能会处理资源加载，运行 JavaScript，修改 DOM 树等等，其间会有一段空闲阶段，用于处理一般任务。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f45538d224?w=1558&amp;h=884&amp;f=jpeg&amp;s=208218" alt=""></p><p>接下来，就会发生 <code>VSync</code>（垂直同期，Vertical Synchronization）。vsync 是浏览器刚刚将一个满满的像素窗口推到显示器上，并且开始生成下一个像素窗口了。因此对于渲染进程来说，这意味着全员都已做好准备生成新的像素点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f4554f50df?w=1784&amp;h=1012&amp;f=jpeg&amp;s=221329" alt=""></p><p>vsync 触发了 <code>BeginMainFrame</code>，这是一个重要方法，它<strong>驱动了渲染流水线</strong>。<code>BeginMainFrame</code> 首先会处理输入事件，如滚动、触屏、手势、鼠标等，然后会运行 <code>requestAnimationFrame</code> 回调。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f4642336ba?w=1780&amp;h=1012&amp;f=jpeg&amp;s=254709" alt=""></p><p>接下来便是开始执行渲染流水线了，如下图，共有四个步骤：</p><ul><li><p>style: 将 DOM 树转化为 layout 树，遍历 layout 树为每一个节点标注其样式信息，然后将带有样式信息的 layout 树传递到下一阶段</p></li><li><p>layout: 我们将再次遍历 layout 树，为节点标注其尺寸、位置信息，至此我们已两次对 layout 树进行标注，然后将它传递给合成阶段</p></li><li><p>composition setup: 在合成设置阶段我们会确定需要绘制多少个合成层（<code>compositing layers</code>），以及它们的尺寸、位置、层叠顺序等</p></li><li><p>paint: 绘制阶段会获取 layout 树的标注以及在合成设置阶段所记录信息，然后创建一个由原始绘图命令组成的“显示列表”，它会指示合成器如何进行像素绘制。</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f466a6f6c3?w=1784&amp;h=1008&amp;f=jpeg&amp;s=254311" alt=""></p><p>在绘制阶段的结尾，会由主线程切换到合成线程（即下图追踪器中的绿色区域），将光栅化工作切分成几个“瓦片”，分配给几个工作线程来进行。待光栅化完成，我们将进入 Chrome 合成器。这一过程会循环往复地执行下去。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f4bbc9b31b?w=1784&amp;h=1012&amp;f=jpeg&amp;s=255888" alt=""></p><p>以上便是关于渲染的简单介绍，值得注意的一点是，主线程非常繁忙，所有动作都发生在主线程，脚本在主线程运行，还负责了渲染和许多其它功能，因此<strong>主线程是非常拥挤的</strong>。经过多年的优化工作，我们发现一个非常有效的优化方式，就是把主线程的工作切分，交给其它线程处理。</p><h2 id="第二部分：渲染的重要性与时下的难题"><a href="#第二部分：渲染的重要性与时下的难题" class="headerlink" title="第二部分：渲染的重要性与时下的难题"></a>第二部分：渲染的重要性与时下的难题</h2><p>对于 Web 平台来说，渲染是非常重要的。</p><p>一是因为，动态网页的本质是接受用户或脚本生成的输入，并将其转化为视觉结果。<strong>渲染是这个过程的核心</strong>，因此无论你的页面做的有多么酷炫，如果渲染出了问题，用户就不会有任何好的体验。</p><p>其二，<strong>渲染是网页性能的主要决定因素</strong>(感知的和实际的)，渲染是无法中断的，如果 JavaScript 运行太久页面就会变得笨重，这当然会引起用户注意。</p><p>其三，现代网页是动态的——会不断地修改内容，加载内容，进行动画。为了跟上步伐，保证交互流畅，<strong>渲染代码必须是一等公民</strong>。</p><p>下面开始介绍我们在渲染代码中遇到的挑战，以及为了解决这些问题我们正在着手进行的改进。</p><h3 id="1-滚动"><a href="#1-滚动" class="headerlink" title="1. 滚动"></a>1. 滚动</h3><p>正如前文所说，渲染是网页性能的主要决定因素，而<strong>滚动体验则是其重中之重</strong>。用户对于滚动体验是非常敏感的，滚动的体验决定了其对页面整体性能的感知，如果滚动体验很糟糕，页面再酷炫也拯救不了。Blink 中涉及到滚动的代码巧妙地隐藏在各处，跨越了渲染器中的主线程与合成线程，甚至包括浏览器进程。</p><p>回首历史，在 1998 年 <code>KHTML</code> 的原始版本中首次赋予了 <code>document</code> 滚动能力。其后，2003 年 <code>WebKit</code> 中 div 也可以进行滚动了，然而这两种滚动都需要重新触发渲染流水线来进行。起初，这两种滚动的代码是分开编写的，这也没什么大不了的。</p><p>然而几年之后，随着对滚动添加了很多功能，做了很多优化，这些关于滚动的代码直接变成了 Blink 中最复杂也最难懂的部分。我们依然维护着这两套滚动代码，所有的功能都要写两遍。不仅如此，由于滚动属于核心代码，实现其它功能也难免要去修改它，复杂度直线上升，越来越难以维护了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f45a605462?w=1630&amp;h=922&amp;f=jpeg&amp;s=122038" alt=""></p><p>由于目前滚动代码的现状，以及任何功能改动都要写两遍，我们所有开发者的工作都变得很困难，因此，在 2014 年 Steve Kobus 与 Elliott 想到了一个绝妙的主意：通过根层滚动（<code>Root Layer Scrolling</code>）来解决这个问题。</p><p>他们决定取消 <code>document</code> 文档级滚动，只使用 <code>overflow</code> 实现所有的滚动功能，这一决定主要是为了降低代码的复杂度，改善代码质量。除此之外还有别的好处，比如，由于两套代码已经分别维护了很长时间，他们的行为表现也并不一致。实际上，文档级滚动行为有明显差异，这是因为文档级滚动与 div 滚动会有一些完全不相关的 Bug，一种滚动有 Bug，另一张滚动可能没有，真是一团糟。</p><p>实现根层滚动也是一个漫长艰辛的过程，历经 4 年，终于完成，在 M66 版本交付。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f4cb9bb471?w=1852&amp;h=1052&amp;f=jpeg&amp;s=164361" alt=""></p><p>想要大规模改动修改渲染代码的布局部分，第一件事是要通过大约四万五千个布局测试，上图中测试失败次数是由 1500 开始的，事实上，我们刚开始进行修改时，大约有 6000 个测试都失败了。这些测试都需要分门别类，挨个解决，因此在这个过程中我们又顺便解决了很多历史遗留 Bug。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f4c03290b9?w=1794&amp;h=1024&amp;f=jpeg&amp;s=221547" alt=""></p><p>在我们的性能基准测试图中可以发现，在我们刚开展工作时，性能有了一次明显退化，大概退化了 40% 到 50%，随着深入研究这些性能 Bug，我们发现这些是深递归到 CPU 路径的代码，因此我们必须做 CPU 相关优化与 Chrome chromium 部分的代码修改。这是一个非常艰难的过程，要各种不同的代码修复才能让我们真正回到基线性能。</p><p>所以我也不得不重申，这块代码真的很难处理，如果我们犯了任何错误，用户都会立即发现，这些错误也会影响所有页面。</p><p>接下来我们来了解一下关于绘制与合成我们所做的改进。</p><h3 id="2-绘制与合成"><a href="#2-绘制与合成" class="headerlink" title="2. 绘制与合成"></a>2. 绘制与合成</h3><p>同滚动代码一样，绘制与合成部分的代码也相当古老，大概已经有 16 年了，在当前的代码架构中开发新功能实属不易。现在有机会对这一部分代码进行性能优化，降低内存占用，使得代码易于扩展，便于开发新功能。因此我们开展了一个综合工程项目：绘制代码瘦身。</p><p>有必要先从技术方面概述绘制是什么，为什么它如此酷炫，以及我们在整体项目中所处的位置。因此，我们先从前文所提到的滚动是如何工作的开始吧。</p><p>在过去，如果我们想进行 div 滚动，我们需要重绘出每一帧。这意味着如果用户一直拖动滚轮，我们就需要生成所有的像素点，用户需要等待我们运行整个渲染流水线后才可以继续移动。</p><p>这里有一个惊人的创新叫做合成线程滚动（<code>composited threaded scrolling</code>），其中有两个部分，一个是合成，这很像从电子游戏中获得的灵感，其思想是将整个可滚动区域绘制到一个图像图形缓冲区中，然后并不是每一帧重绘移动区域，而是将一个子纹理复制到不同的纹理中。第二个创新是将滚动操作脱离出主线程，还记得前文提到过的吧，主线程的资源是多么宝贵，此处的基本思想是我们可以在 JavaScript 运行的同时进行滚动。这两件事结合在一起，是一项非常惊人的创新，这种合成线程渲染的思想可以推广到任何需要对纹理进行修改的地方。</p><p>比如说，transform，opacity，filter，clip 等等这些都可以通过合成线程思想来实现。当你在软件上运行，用 CPU 绘制像素时，速度很快，但是如果在 GPU 上运行，它的速度更会快成一道闪电。</p><p>但是这里有一个叫“老巢爆炸（<code>lair explosion</code>）”的问题。如下图，如果我们将绿盒子使用合成线程进行旋转，它会贯穿蓝盒子。问题是我们需要确认蓝盒子会被绘制在绿盒子之上，因此蓝盒子也会被合成。这种情况会占用相当多的内存。你作为一名前端工程师，在页面上设置了透明度，有可能你就突然发现内存爆炸了，因为页面上其它部分也都被合成了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f4c40ca0d4?w=266&amp;h=612&amp;f=jpeg&amp;s=34875" alt=""></p><p>下面来介绍一下当下合成器架构体系来阐述合成器是如何工作的，绘制代码瘦身又有什么样的成效。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f5bf487212?w=1348&amp;h=766&amp;f=jpeg&amp;s=118447" alt=""></p><p>我们有一个简单的 DOM 树结构，有 emoji 笑脸表情的 div 是可以滚动的。它的生命周期与前文所述的并无二致，因此在排版环节我们将标注 layout 树的尺寸与位置信息，然后便是合成设置环节了，我们重点讲一下。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f662696620?w=1354&amp;h=762&amp;f=jpeg&amp;s=106300" alt=""></p><p>a、b、d 都不可滚动，所以它们仨可以一起绘制到同一个图形缓冲区中（<code>graphics buffer</code>）。而 emoji 笑脸表情是可以滚动的，我们不想为它的滚动重绘每一帧，因此把它单独放到一个图形缓冲区中。现在我们有了两个图形缓冲区，是时候进行绘制了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f65ddb7650?w=1344&amp;h=764&amp;f=jpeg&amp;s=119302" alt=""></p><p>在绘制过程中，我们实际上是遍历 layout 树，记录绘图命令。然后是进行光栅化。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f5c0ca4b57?w=1352&amp;h=768&amp;f=jpeg&amp;s=128387" alt=""></p><p>此时我们将执行绘制步骤中所记录的绘图命令，生成真正的像素点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f662c52ece?w=1342&amp;h=764&amp;f=jpeg&amp;s=111908" alt=""></p><p>最终我们将在页面上它们安放到一起，上下滚动 emoji 表情时也不会触发重绘步骤了。</p><p>在目前的架构体系下，有两个问题，一是<strong>合成仅限于特定子树</strong>。layout 树有一个属性，决定我们能否进行合成。并非所有子树都有这个属性，因此我们不能随意将页面上的 div 转换成图形缓冲区，这导致了一个基本性合成 Bug，在 2014 年首次发现。</p><p>当时我们试图让 iframe 在任意地方合成，以提高滚动性能，结果发现页面上的内容瞬间都消失了，原因是如果制作了一个合成的 iframe，你还需要确保任何绘制在它上方的内容也是合成的。这是一个在 2014 年发现的毁灭性错误，因为你已经建立了这些特殊的逻辑来不创建过多的图形缓冲区处理诸如此类的事情，结果在游戏的后期发现了一种基本的缺陷，这种缺陷束缚了你的手，这并不是是把你的手绑在一个边缘案例中，这一个可能遇到的情况（Gmail 在进行滚动优化时就遇到了这个问题，优化无法生效），这阻止了我们继续在当前架构中构建。</p><p>我们当前合成体系结构的第二个问题是<strong>合成设置是在绘制之前完成的</strong>。我们在系统早期就创建了图像缓冲区，你需要在绘制步骤中重新计算，所以我们有重复的逻辑，很难描述这个逻辑有多复杂，但是我可以说大约一半的绘制代码是用于这种大小和效果，比如 clip。</p><p>除了在绘制之前进行这种合成设置之外，还有一个问题，因为它在主线程上，这意味着任何可能改变绘制对象大小的效果都需要回到主线程。例如，如果你有两个可以合成的盒子，其中一个是可以滚动的，那么在很多情况下你必须假设最坏的情况。你必须假设合成器可以在页面上的任何地方进行，所以你必须为页面上的许多东西创建图像缓冲区，这是我们之前讨论过的老巢爆炸问题，导致了真正的性能问题。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f662e16ec3?w=1346&amp;h=766&amp;f=jpeg&amp;s=172999" alt=""></p><p>绘制代码瘦身项目改变了我们整个架构中的这两个问题。它改变了我们如何选择合成事物的粒度，这样你就可以合成，将任何效果转换成图像缓冲区，第二是我们将合成设置移动到绘制后。这不仅可以解决基础性合成 Bug，也避免了逻辑重复。</p><p>因此，新的合成架构可以在任何边界进行合成，我们已经移动了合成设置应用程序，以释放主线程的压力。这使我们能够对重叠的事物做出精确的合成决定，可以做一些改变主线程外绘制对象大小的事情。</p><p>在这个项目的里程碑中，我们已经完成了关于绘制缓存的功能，目前处于 M67，刚刚发布了绘制代码瘦身的 V1.75 版本。在今年（2018）年底，我们将发布 V2 版本，将合成设置移动到绘制后进行。</p><h3 id="3-布局排版"><a href="#3-布局排版" class="headerlink" title="3. 布局排版"></a>3. 布局排版</h3><p>布局有两个主要问题，第一个是 web 平台问题，我们称之为<strong>组合问题</strong>(<code>The Combinatorial Problem</code>)。我们有大量的 web 标准，并且还在不断添加更多新的标准，同时旧的标准也依然存在，每次我们定义新的 CSS 标准时，它都会创建一组带有与所有现有 CSS 标准的新交互。它们结合的方式有一点奇怪，随之而来有很多的边界 case，让我们以 <code>flexbox</code> 为例看一看：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f669714993?w=888&amp;h=422&amp;f=jpeg&amp;s=34579" alt=""></p><p>很简单的三个 flex item 盒子，我们添加几个属性看看布局会发生什么变化。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f6f8c84ba4" alt=""></p><p>设置 <code>direction: rtl</code> 会使得布局方向变为从右往左。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f6fd13e2de" alt=""></p><p>在此基础上，添加一个 <code>flex-direction: row-reverse</code>，布局方向又恢复为从左往右了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f6fd924a2e" alt=""></p><p>把 <code>direction</code> 属性去掉，从右往左排布。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f7078e0821" alt=""></p><p><code>flex-direction</code> 设置为 <code>columb-reverse</code>，布局改为按列排布。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f7077ed8e9" alt=""></p><p>设置 <code>writing-mode</code> 同时 <code>flex-direction</code> 改为行排布，使得文字方向也发生了改变。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f8d0a2f5c4?w=1028&amp;h=532&amp;f=jpeg&amp;s=48801" alt=""></p><p><code>flex-direction</code> 改为反向，依然复合预期。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f7079255c7" alt=""></p><p><code>flex-direction</code> 改为列，也是一样。举例到这里就足够了，以上之所以表现复合预期，是因为我花了三周的时间解决各种 Bug。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f8d3445d0a?w=1084&amp;h=706&amp;f=jpeg&amp;s=198362" alt=""></p><p>在其它内核的浏览器中可就不一定了，如上图，第一个图是以上 flexbox 示例在 chromium 中的表现，第一排第二个浏览器表现也几乎相同，然而第三个第四个可就相去甚远。</p><p>我无意 diss 其它浏览器，换个功能示例，可能 chromium 就是表现最差的那一个。我是想强调这个兼容性问题确实存在，复杂的 CSS 特性也在持续堆积。</p><p>第二个问题是 <strong>Blink 中布局相关的代码是非常远古的，里面充斥着无封装，不可重入，非线程安全的面条式巨石代码</strong>。</p><p>先解释一下巨石代码，这里有一个 layout 树，节点是 layout 对象，假设我们在树下面的一个元素上改变 CSS。元素现在变脏了，需要转发出去。接下来我们要做的是标记整个祖先链，当我们想执行 layout 阶段时，我们总是从树顶开始，一直往下走，现在我们进行了一系列优化，但是优化后的也没有跳过很多步骤。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f8d3767fc7?w=1330&amp;h=704&amp;f=jpeg&amp;s=56419" alt=""></p><p>我们仍然要进行完整的树遍历，这也是耗费资源的，每次我们执行 layout 都会进行遍历。底部节点可能位于一个尺寸固定的盒子里，它甚至可以使用 <code>CSS containment</code>，这是一个新特性，有点类似于浏览器的契约，意味着这个子树不会影响它自身以外的任何东西，子树以外的任何东西也不会影响它。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f8d38d6af2?w=1336&amp;h=690&amp;f=jpeg&amp;s=57501" alt=""></p><p>如果布局这棵子树时我们已经有了所有我们所需要的信息，无需在这个子树之外寻找任何额外的信息来确定大小和位置就好了。然而事实上，我们一直在运行布局代码来获取其他信息。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166511f94e759049" alt=""></p><p>处于图中这个节点中，如果出于某种原因我们可以跳到树的另一部分吗？不可以，这是一个毁灭性操作。</p><p>至于线程安全，还记得最开始我们了解的渲染流水线吧？我们遍历 layout 树，还对它进行标注，然后传递给绘制阶段。当我们完成所有任务准备生成下一帧内容时，会从上次使用的 layout 树开始，根据已改变的内容来更新它。这里是没有什么是线程安全的，可能有多个线程修改它。</p><p>对于以上两个问题，相应有两个解决方案。针对<strong>组合问题</strong>，解决方案是 CSS 定制布局即 <a href="https://developers.google.com/web/updates/2016/05/houdini" target="_blank" rel="noopener">Houdini</a>，这意味着可以在元素上设置特定的 CSS 属性，然后定义一个 JavaScript 函数，该函数负责布局该元素及子树。在常规布局过程中，我们会暂停然后去调用 JavaScript 函数，传给它一组布局元素所需要的信息，函数将消费它。这里不会讲太多 <code>Houdini</code> 的细节，大家有兴趣可以自行研究。</p><p>针对第二个问题的解决方案是 <code>Layout NG</code>，这实际上是对如何完成布局的全盘反思。<code>Layout NG</code> 有两个特性，一是它使用约束驱动的布局，输入一个子树来进行布局，我们传递给它所有它所需要的在子树中进行布局的信息，而且它根本不看子树的外面。实现这一点也并不容易，通过在中强制封装，我们让底层布局代码更容易实现刚才提到的 CSS 定制布局。第二个特性是，输入（layout 树）与输出（fragment 树）的树都是<strong>不可变对象</strong>，我们每次都创建一个新的布局树，一旦我们创建了它，该树就不可变了，我们并不是在这个输入树上进行注释，而是复制它，并用新的替换子树来改变子树，我们将拥有布局树的全新副本。</p><p>这两个特性的实现将使得布局方面的各种强力优化成为可能。这一项目尚属早期，第一阶段预计在今年年底、明年年初发布。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/8/166511f666cf2441?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=142074&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文系掘金委托翻译整理的 BlinkOn9 会议演讲内容&lt;br&gt;演讲资料 &lt;a href=&quot;https://www.youtube.com/watch?v=ExNYN_phaxI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;视频&lt;/a&gt;/ &lt;a href=&quot;https://docs.google.com/presentation/d/1Iko1oIYb-VHwOOFU3rBPUcOO_9lAd3NutYluATgzV_0/edit#slide=id.g36f1b50c08_0_3702&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;code&gt;BlinkOn9&lt;/code&gt; 会议中，Google Blink 团队开发者 Philip Rogers 与 Stefan Zager 进行了&lt;a href=&quot;https://www.youtube.com/watch?v=ExNYN_phaxI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Blink Rendering - Rebuilding the Engine Mid-Flight》分享&lt;/a&gt;，旨在介绍 Blink 渲染的基本原理与开发团队近期对滚动性能、绘制合成与排版的改进。&lt;/p&gt;
    
    </summary>
    
      <category term="render chrome" scheme="https://blog.colafornia.me/categories/render-chrome/"/>
    
    
  </entry>
  
  <entry>
    <title>生命在于折腾，写一个前端资讯推送服务</title>
    <link href="https://blog.colafornia.me/post/2018/the-beginning-of-little-robot/"/>
    <id>https://blog.colafornia.me/post/2018/the-beginning-of-little-robot/</id>
    <published>2018-09-11T04:39:00.000Z</published>
    <updated>2019-02-13T07:05:14.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c7d54108ab97e?w=1390&h=1154&f=jpeg&s=224666" width="600"></p><p>去年年底开始写的一个小项目，断断续续做了些优化，在此简单的记录一下。</p><a id="more"></a><h2 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h2><p>起源是之前一直没什么机会接触到 Node 项目，工作中接触到的也仅限于用 Node 写脚本，做一些小工具，与服务器上跑的 Node 服务相差甚远。所以想写一个在服务器上跑的 Node 小项目练手。</p><p>一直喜欢用 RSS 订阅资讯这种方式，简单高效，与其每天不定时地接收推送，打开各网站 App 来接收资讯，不如自己拿到主动权集中在同一时间段统一阅读。这样避免了每天不定时接受信息的焦虑堆积，但是又常常想不起来打开😅，过了一周打开 Reeder，发现累积的未读资讯又爆炸了，人真是很难满足。</p><p>于是决定自己搞个资讯推送服务吧，满足自己的核心诉求，<strong>每个工作日早上 10 点微信推送 RSS 前端资讯的更新</strong>，这样就可以在每天抵达工位的时候舒舒服服浏览一下新鲜事，挑一些有用的存起来慢慢研读。</p><p>项目仓库： <a href="https://github.com/Colafornia/little-robot" target="_blank" rel="noopener">https://github.com/Colafornia/little-robot</a></p><p>推送大概长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c7d54108ab97e?w=1390&h=1154&f=jpeg&s=224666" width="600"></p><p>扫码获取推送服务：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c7d541080f3a0?w=500&h=500&f=png&s=12430" width="280"></p><p>现在推送源主要是各厂的知乎专栏，大佬们的个人博客，掘金前端热门文章，都是我自己的个人口味。</p><p>下面来讲一下开发（与自己给自己加需求）历程。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>最开始感觉这个需求是很简单的，具体操作可以分解为：</p><ol><li>写一个配置文件，把我想抓取的 RSS 源地址写在里面</li><li>找一个能解析 RSS 的 npm 包，遍历配置文件里的源，解析之后处理数据</li><li>仅筛出在过去 24 小时内更新的文章，把数据处理一下，汇总成一段字符串，用微信推送</li><li>以上写出的脚本通过定时任务跑起来，done！</li></ol><p>最后选择了 <a href="https://github.com/bobby-brennan/rss-parser" target="_blank" rel="noopener">rss-parser</a> 作为解析工具包，<a href="https://pushbear.ftqq.com/admin/#/" target="_blank" rel="noopener">PushBear</a> 作为推送服务，<a href="https://github.com/node-schedule/node-schedule" target="_blank" rel="noopener">node-schedule</a> 任务调度工具写出来了一版。</p><p>然后就发现自己知识的匮乏了，没有考虑到脚本部署到服务器上时，进程守护的问题，于是研习了一波 <a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">pm2</a>，完美完成任务。</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>项目写到这里其实是可以凑和用了，但是看起来很 low 很难受。主要问题有：</p><ol><li>当时 RSS 源大概有四五十个，一次性遍历解析所有的源经常会有超时或者出错的</li><li>RSS 源写在配置文件里，每次想添加、修改源都需要改代码，很 low</li><li><a href="https://pushbear.ftqq.com/admin/#/" target="_blank" rel="noopener">PushBear</a> 这个推送服务只能存储三天内的推送，三天前，一周前的推送内容都看不了，这也很难受</li><li>掘金的 RSS 源内容不多，也不是按照热门程度排序的（也可能是我姿势不对😅），不太符合要求</li></ol><p>第一点稍微有点复杂，可能现在解决的方案依然很原始。出现第一个问题一是需要控制请求的并发数量，二是 RSS 源本身有一定的不稳定性。目前的解决方案是：</p><ol><li>把抓取任务和推送任务分开，预留出可以循环抓取三次的时间，后面两次只抓取之前失败的源</li><li>用 <a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a> 的 <code>mapLimit</code> 和 <code>timeout</code> 方法设置最大并发数量和超时时间</li></ol><p>大致代码如下（有一些细节处理没贴上来）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抓取定时器 ID</span></span><br><span class="line"><span class="keyword">let</span> fetchInterval = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 抓取次数</span></span><br><span class="line"><span class="keyword">let</span> fetchTimes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPushSchedule</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    schedule.scheduleJob(<span class="string">'00 30 09 * * *'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 抓取任务</span></span><br><span class="line">        log.info(<span class="string">'rss schedule fetching fire at '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        activateFetchTask();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    schedule.scheduleJob(<span class="string">'00 00 10 * * *'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 发送任务</span></span><br><span class="line">        log.info(<span class="string">'rss schedule delivery fire at '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        <span class="keyword">let</span> message = makeUpMessage();</span><br><span class="line">        log.info(message);</span><br><span class="line">        sendToWeChat(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activateFetchTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetchInterval = setInterval(fetchRSSUpdate, <span class="number">120000</span>);</span><br><span class="line">  fetchRSSUpdate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchRSSUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fetchTimes++;</span><br><span class="line">    <span class="keyword">if</span> (toFetchList.length &amp;&amp; fetchTimes &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 若抓取次数少于三次，且仍存在未成功抓取的源</span></span><br><span class="line">        log.info(<span class="string">`第<span class="subst">$&#123;fetchTimes&#125;</span>次抓取，有 <span class="subst">$&#123;toFetchList.length&#125;</span> 篇`</span>);</span><br><span class="line">        <span class="comment">// 最大并发数为15，超时时间设置为 8000ms</span></span><br><span class="line">        <span class="keyword">return</span> mapLimit(toFetchList, <span class="number">15</span>, (source, callback) =&gt; &#123;</span><br><span class="line">            timeout(parseRSS(source, callback), <span class="number">8000</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">'fetching is done'</span>);</span><br><span class="line">    clearInterval(fetchInterval);</span><br><span class="line">    <span class="keyword">return</span> fetchDataCb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样基本解决了 90% 以上的抓取问题，保证了脚本的稳定性。</p><p>针对 RSS 源写在配置文件里，每次想添加、修改源都需要改代码的问题，解决方法很简单，把源配置写到 MongoDB 里也就好了，有一些 GUI 软件可以直接在图形界面来添加、修改数据。</p><p>为了解决推送服务只能存储三天内的推送，决定新增一个每周五的周抓取任务，抓取一周内的新文章，把内容作为 issue 发到仓库。也还算是一个解决方案。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c7d5410a067c6?w=940&h=952&f=jpeg&s=174243" width="480"></p><p>针对掘金的 RSS 源问题，最后决定直接调用掘金的接口来取数据，这就可以随心所欲按自己的需求来了，每天只抓取❤️点赞数在 70 以上的文章。</p><p>顺便给抓取的文章时间范围加了一个偏移值，避免筛掉质量好但是由于刚刚发布点赞较少的文章。感觉自己棒棒哒~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterArticlesByDateAndCollection</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">70</span>;</span><br><span class="line">    <span class="comment">// articles 是已按❤️数由高到低排序的文章列表</span></span><br><span class="line">    <span class="keyword">let</span> results = articles.filter(<span class="function">(<span class="params">article</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 偏移值五小时，避免筛掉质量好但是由于刚刚发布点赞较少的文章</span></span><br><span class="line">        <span class="keyword">return</span> moment(article.createdAt).isAfter(moment(startTime).subtract(<span class="number">5</span>, <span class="string">'hours'</span>))</span><br><span class="line">            &amp;&amp; moment(article.createdAt).isBefore(moment(endTime).subtract(<span class="number">5</span>, <span class="string">'hours'</span>))</span><br><span class="line">            &amp;&amp; article.collectionCount &gt; threshold;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 掘金文章最多收录 8 篇，避免信息爆炸</span></span><br><span class="line">    <span class="keyword">return</span> results.slice(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个期间也充分感受到了日志的重要性，在数据库里新增了一个表用来存每天的推送内容。</p><p>另外在 <a href="https://pushbear.ftqq.com/admin/#/" target="_blank" rel="noopener">PushBear</a> 上新添加了一个 Channel 来给自己推送日志，每天在抓取任务完成后，先给我发送一下抓取到的内容，如果发现有任何问题，我可以自己登服务器紧急修复一下（这么想来还是很 low 😅）。</p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>做完以上改动之后，脚本稳定地跑了快半年，这期间我也一直在忙着搬砖，没什么精力再来改造它。</p><p>一直没做推广，但某天突然发现已经有了三十多个用户在订阅这个服务，于是良心发现，本着对用户负责（也是自己有了新的想练习的技术👻）,就又做了一次改造。</p><p>此时项目的问题有：</p><ol><li>没有文章去重，如果文章在知乎专栏发了，掘金也发了，作者个人博客也发了的话，就相当于会重复出现几次</li><li>推送的时间间隔不精确，都是当前时间的过去 24 小时来筛的</li><li>脚本直连数据库进行存取操作也不太好，感觉这个形式做成 server，对外暴露 api 更合理（等哪天想写个 RSS 阅读器也就用上了）</li><li>每次代码有更新，依赖有更新，都 ssh 上服务器然后 <code>npm install</code> 感觉也不太专业，有提升空间（其实就是想用 <code>docker</code> 了）</li></ol><p>1，2 问题很好解决，每次抓取之前先查一下日志，上次推送的具体时间。每抓到新文章时，再与最近 7 天日志里的文章比对一下，重复的不放到抓取结果中，也就解决了。</p><p>对于问题 3，于是决定搭建 Koa Server，先把从 MongoDB 读取推送源，存取推送日志变成 api。</p><p>目录结构如下，添加 <code>Model</code> 与 <code>Controller</code>。把 RSS 抓取脚本与掘金爬虫放到 task 文件。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c7d54109e1c80?w=654&h=970&f=jpeg&s=59616" width="400"></p><p>没什么难点，就可以调用 api 来获取 RSS 源了：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c7d54107ab26b?w=1072&h=996&f=jpeg&s=158223" width="500"></p><p>此时想到了一个重要问题，<strong>身份验证</strong>。肯定不能把所有 api 都随意暴露出去，让外界可以任意调用，这也就相当于把数据库都暴露出去了。</p><p>最终决定用 <code>JSON Web Token（缩写 JWT）</code> 作为认证方案，主要原因是 JWT 适合一次性、短时间的命令认证，目前我的服务仅限于服务器端的 api 调用，每天的使用时间也不长，无需签发有效期很长的令牌。</p><p>Koa 有一个 <a href="https://github.com/koajs/jwt" target="_blank" rel="noopener">jwt</a> 的中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">app.use(jwtKoa(&#123; <span class="attr">secret</span>: config.secretKey &#125;).unless(&#123;</span><br><span class="line">    path: [<span class="regexp">/^\/api\/source/</span>, /^\/api\/login/]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>加上中间件后，除了 <code>/api/source</code> 与 <code>/api/login</code> 接口就都需要经过 jwt 认证才能访问了。</p><p>因此写了一个 <code>/api/login</code> 接口，用于签发令牌，拿到令牌之后，把令牌设置到请求头里就可以通过认证了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api/base.js</span></span><br><span class="line"><span class="comment">// 用于封装 axios</span></span><br><span class="line"><span class="comment">// http request 拦截器</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"><span class="keyword">const</span> Instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">`http://localhost:<span class="subst">$&#123;config.port&#125;</span>/api`</span>,</span><br><span class="line">    timeout: <span class="number">3000</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        post: &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Instance.interceptors.request.use(</span><br><span class="line">    (config) =&gt; &#123;</span><br><span class="line">        <span class="comment">// jwt 验证</span></span><br><span class="line">        <span class="keyword">const</span> token = config.token;</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.headers[<span class="string">'Authorization'</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果请求头里没有正确的 token，则会返回 <code>Authentication Error</code>。</p><p>至于问题 4，现在服务比较简单，也只在一个机器上部署，手动登机器 npm install 问题还不大，如果机器很多，依赖项也复杂的话，很容易出问题，具体参见<a href="https://zhuanlan.zhihu.com/p/39209596" target="_blank" rel="noopener">科普文：为什么不能在服务器上 npm install ？</a>。</p><p>于是决定基于 <code>Docker</code> 做构建部署。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> daocloud.io/node:<span class="number">8.4</span>.<span class="number">0</span>-<span class="keyword">onbuild</span></span><br><span class="line"><span class="keyword">COPY</span> package*.json ./</span><br><span class="line"><span class="keyword">RUN</span> npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="keyword">RUN</span> cnpm install</span><br><span class="line"><span class="keyword">RUN</span> echo "Asia/Shanghai" &gt; /etc/timezone</span><br><span class="line"><span class="keyword">RUN</span> dpkg-reconfigure -f noninteractive tzdata</span><br><span class="line"><span class="keyword">COPY</span> . .</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="keyword">CMD</span> [ "npm", "start", "$value1", "$value2", "$value3"]</span><br></pre></td></tr></table></figure><p>用的比较简单，主要就是负责安装依赖，启动服务。需要注意的主要有两点：</p><ol><li>国内拉去外网的镜像很慢，像 Node 官方的镜像我都拉了好久都没拉下来，这样的话推荐使用国内的镜像，比如我用的 DaoCloud，还有阿里云镜像等等</li><li>由于推送服务是对时间敏感的，基础镜像的时区并不是国内时区，要手动设置一下</li></ol><p>然后去 <a href="https://dashboard.daocloud.io/" target="_blank" rel="noopener">DaoCloud</a> 等提供公有云服务的网站授权访问 Github 仓库，连接自己的主机，就可以实现持续集成，自动构建部署我们的镜像了。具体步骤可参考<a href="https://zhuanlan.zhihu.com/p/37961402" target="_blank" rel="noopener">基于 Docker 打造前端持续集成开发环境</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/12/165c96207478caa7?w=2382&amp;h=366&amp;f=jpeg&amp;s=64252" alt="daocloud"></p><p>本次优化大概就到这里了。接下来要做的可能是提供一个推送历史查看页面，优先级不是很高，有时间再做吧（顺便练习一下 Nginx）。</p><p>现在的实现方案可能还是有很不合理的地方，欢迎提出建议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/11/165c7d54108ab97e?w=1390&amp;h=1154&amp;f=jpeg&amp;s=224666&quot; width=&quot;600&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年年底开始写的一个小项目，断断续续做了些优化，在此简单的记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="open-source" scheme="https://blog.colafornia.me/categories/open-source/"/>
    
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="https://blog.colafornia.me/post/2018/character-encoding/"/>
    <id>https://blog.colafornia.me/post/2018/character-encoding/</id>
    <published>2018-09-03T06:20:00.000Z</published>
    <updated>2019-02-13T07:05:14.275Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.dailymail.co.uk/i/pix/2016/10/27/21/39C8A74600000578-3879480-The_touch_bar_can_display_emotions_in_messaging_apps_playback_co-a-5_1477598860842.jpg" alt="cover"></p><p>作为编程知识基础中的基础，有必要消化整理输出一次。</p><p>本文主要介绍了字符编码的几个重要基础概念，从 <code>ASCII</code> 到 <code>Unicode</code> 再到 <code>Emoji</code> 与 <code>JavaScript</code> 字符处理的一些坑。</p><a id="more"></a><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>由于计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字。计算机中，<code>字节（byte）</code> 是一个 <code>8bit</code> 的储存单元，一个字节能表示的最大的整数就是 255（二进制的11111111 = 十进制255），如果要表示更大的整数，就必须用更多的字节。</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>字符是文字与符号的总称，它是一个信息单位。字符集就是字符的集合。<code>ASCII码</code>（American Standard Code for Information Interchange）就是一个字符集，这个集合中只有数字，英文字母和一些符号共 127 个字符。如果我们想处理中文、日文文本，仅通过 <code>ASCII码</code> 就做不到了。在历史中由于眼光的局限性，出现了一些仅能处理部分字符的字符集，无法通用。</p><p><img src="https://i.loli.net/2018/09/03/5b8d2209e4247.jpg" alt=""></p><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>字符编码规定了字符集和实际存储的二进制数值之间的转换关系。一般来说，每个字符集都有其对应的字符编码方式（有的字符集有一个对应字符编码，有的则有多个）。像 <code>ASCII</code> 与 <code>GB18030</code> 都仅有一种编码实现，因此既可以作为字符集的名字，也可以用来指代它们的字符编码。</p><p>通过以上概念的介绍不难窥探在字符编码的历史中存在以下痛点：</p><ol><li>字符集不够通用，总有覆盖不到的字符</li><li>新的字符集难以向下兼容老的</li><li>覆盖更多字符的字符集，难以避免需要更多字节，如果我们的文本仅通过 <code>ASCII</code> 就能处理的话，使用占用字节更多的字符集在储存和传输都不划算</li></ol><p>这些问题都由 <code>Unicode</code> 及其字符编码一起打包解决了。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a> 是一个<strong>字符集</strong>，旨于涵盖所有国家语言中可能出现的符号与文字，是目前绝大多数程序使用的字符编码。</p><p><code>Unicode</code>的诞生也不是一蹴而就，也有历史过程。</p><h4 id="历史进程"><a href="#历史进程" class="headerlink" title="历史进程"></a>历史进程</h4><p>（这段不是用来凑数的，这几个英文简写后面还会一直出现，知道了历史更方便记忆分辨）</p><p>ISO 与 IEC 分别推出了 <code>Unicode</code> 与 <code>UCS</code>（Universal Multiple-Octet Coded Character Set） 。后来（只过了一年），两者进行整合，到了 Unicode2.0 时代，Unicode 的编码和 UCS 的编码都完全一致。</p><p><code>USC</code> 这个名字也并未从此消失在历史中。<code>UCS</code> 标准有自己的格式，如<code>UCS-2</code>，<code>UCS-4</code>等等 而 Unicode 也有自己的不同编码实现，如<code>UTF-8</code>，<code>UTF-16</code>，<code>UTF-32</code>等等。</p><h4 id="关于-Unicode-自己"><a href="#关于-Unicode-自己" class="headerlink" title="关于 Unicode 自己"></a>关于 Unicode 自己</h4><p><code>码点 code point</code> 是指在 Unicode 字符集中字符的值，根据 Unicode 标准，是前缀为 <code>U+</code> 的十六进制数字。</p><p>Unicode 字符分为 17 组平面（plane），每个平面拥有 2^16 (65,536) 个码点。每一个码点都可以用 16 进制 xy0000 到 xyFFFF 来表示，这里的 xy 是表示一个 16 进制的值，从 00 到 10。目前我们常用字符大多都在 BMP 基本平面中。</p><p><img src="https://s1.ax1x.com/2018/08/29/PXQfOA.png" alt="plane"></p><h4 id="字节序与-BOM"><a href="#字节序与-BOM" class="headerlink" title="字节序与 BOM"></a>字节序与 BOM</h4><p>在了解 Unicode 的字符编码之前，还需要了解一个关于 <code>字节序</code> 的知识。</p><p>计算机硬件有两种储存数据的方式：<code>大端</code>字节序（big endian）和<code>小端</code>字节序（little endian）。</p><ul><li>大端字节序：高位字节在前，低位字节在后</li><li>小端字节序：低位字节在前，高位字节在后</li></ul><p>因此，<code>0x1234567</code> 的大端字节序和小端字节序的写法如下图：</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2016/bg2016112201.gif" alt=""></p><p>字节序的存在主要是因为计算机电路先处理低位字节，因为计算都是从低位开始的。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p><p>Unicode 规范中推荐的标记字节顺序的方法是 <code>BOM</code>（Byte Order Mark）。有一个叫做”零宽度非换行空格（ZERO WIDTH NO-BREAK SPACE）”的字符，它的编码是 <code>FEFF</code>。而 <code>FFFE</code> 在 UCS 中是不存在的字符，所以不应该出现在实际传输中。Unicode 规范中定义每个文件的最前面加入这个零宽度非换行空格字符，如果一个文本文件的头两个字节是 <code>FE FF</code>，就表示该文件采用大端方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小端方式。</p><p>需要清楚的是，<strong>不是所有的东西都有字节序</strong>，而且字符序是以单字节为单位的顺序问题。</p><p>前面提到 <code>Unicode</code> 有多种字符编码实现方式，我们主要介绍 <code>UTF-8</code> 与 <code>UCS-2</code>。</p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p><code>UTF-8</code> 作为最常见的 Unicode 实现方式，解决了前面提到的字符编码几大痛点。</p><p> <code>UTF-8</code> 编码是<strong>变长编码</strong>，用 1 到 6 个字节编码，完全兼容 <code>ASCII</code> 码，对于 ASCII 涵盖的那些字符，单字节实现，其余大多数为三字节实现。对于以英文为主的文本非常友好，最节省存储空间。缺点主要在于</p><p><code>UTF-8</code> 编码通过多个字节组合的方式来显示，这是计算机处理<code>UTF-8</code> 的机制，它是无字节序之分的。</p><p>UTF 家族还有 <code>UTF-16（双字节）</code> 与 <code>UTF-32（四字节）</code> 实现，两者都有字节序问题，前者更适合汉字编码但不支持单字节的 <code>ASCII</code>，后者由于浪费储存空间很不常见，HTML5 中明确规定禁止使用 UTF-32 编码。</p><h4 id="UCS-2"><a href="#UCS-2" class="headerlink" title="UCS-2"></a>UCS-2</h4><p>JavaScript 设计之初，还没有出现 <code>UTF-16</code>，因此采用的是 <code>USC-2</code> 编码。前面提到 <strong>Unicode 的编码和 UCS 的编码都完全一致</strong>。<code>UCS-2</code> 是一种定长的编码方式，用两位字节来表示一位码位。</p><p><code>UTF-16</code> 可看成是 <code>UCS-2</code> 的父集。在没有<code>辅助平面字符（surrogate code points）</code>前，<code>UTF-16</code> 与 <code>UCS-2</code> 所指的是同一的意思。但当引入辅助平面字符后，就称为 <code>UTF-16</code> 了。现在若有软件声称自己支持 <code>UCS-2</code> 编码，那其实是暗指它不能支持在 <code>UTF-16</code> 中超过 2 字节的字集。对于小于 <code>0x10000</code> 的 <code>UCS</code> 码，<code>UTF-16</code> 编码就等于 <code>UCS</code> 码。</p><p>因此在 ES6 之前，JavaScript 对于超出 USC-2 的字符无法正确处理，会导致字符长度、正则匹配判断错误，使用字符串的 <code>charCodeAt()</code> 与 <code>fromCharCode()</code> 也无法正确识别字符与码点。</p><p>ES6 新增了 <code>codePointAt()</code> 与 <code>fromCodePoint()</code> 方法以正确处理 32 位的 <code>UTF-16</code> 字符之外的字符。</p><h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'😂'</span>.length <span class="comment">// 2</span></span><br><span class="line"><span class="string">'1️⃣'</span>.length <span class="comment">// 3</span></span><br><span class="line"><span class="string">'👨‍👨‍👦'</span>.length <span class="comment">// 8</span></span><br><span class="line"><span class="string">'👨‍👩‍👧‍👦'</span>.length <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>看起来就很刺激。</p><p>随着 <code>Emoji</code> 表情的流行，在开发中就不得不了解、考虑 <code>Emoji</code> 字符了。否则最简单的 textarea 文本字数限制需求都难以正常完成。</p><p>随着政治正确的发展，Emoji 现在是非常多元化了：</p><p><img src="https://i.loli.net/2018/09/03/5b8d23bc27a4c.jpg" width="500"></p><p><img src="https://i.loli.net/2018/09/03/5b8d23bc4ed9b.jpg" width="500"></p><p>肤色，职业，性别，取向，家庭组成都十分多元，基本覆盖了所有情况。</p><p>其实在原先的基础 Emoji 字符上拓展出这些多元化字符并不难，通过码点组合就能实现。</p><p>肤色修饰符： 🏻 🏼 🏽 🏾 🏿</p><p>通过这几个肤色修饰符拼接到原有表情上，就可以实现肤色多元化：</p><p><img src="https://i.loli.net/2018/09/03/5b8d21b17273c.jpg" alt=""></p><p>通过 <code>零宽字符 ZWJ(U+200D)</code> 可以实现 family emoji，U+200D 相当于是一个连接符，连接家庭成员 emoji：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// family (man, woman, boy)</span></span><br><span class="line"><span class="comment">// '\u&#123;1F468&#125;' + '\u&#123;200D&#125;' + '\u&#123;1F469&#125;' + '\u&#123;200D&#125;' + '\u&#123;1F466&#125;'</span></span><br><span class="line"><span class="comment">// 👨‍ + '\u&#123;200D&#125;' + 👩‍ + '\u&#123;200D&#125;' + 👦</span></span><br><span class="line"><span class="comment">// length: 8</span></span><br><span class="line">&gt; ‍👨‍👩‍👦</span><br><span class="line"><span class="comment">// family (woman, woman, girl)</span></span><br><span class="line"><span class="comment">// '\u&#123;1F469&#125;' + '\u&#123;200D&#125;' + '\u&#123;1F469&#125;' + '\u&#123;200D&#125;' + '\u&#123;1F467&#125;'</span></span><br><span class="line"><span class="comment">// 👩‍ + '\u&#123;200D&#125;' + 👩‍ '\u&#123;200D&#125;' + 👧</span></span><br><span class="line"><span class="comment">// length: 8</span></span><br><span class="line">&gt; ‍👩‍👩‍👧</span><br><span class="line"><span class="comment">// family (woman, woman, girl, girl)</span></span><br><span class="line"><span class="comment">// '\u&#123;1F469&#125;' + '\u&#123;200D&#125;' + '\u&#123;1F469&#125;' + '\u&#123;200D&#125;' + '\u&#123;1F467&#125;' + '\u&#123;200D&#125;' + '\u&#123;1F467&#125;'</span></span><br><span class="line"><span class="comment">// '👩‍' + '\u&#123;200D&#125;' + '👩‍' + '\u&#123;200D&#125;' + '👧‍' + '\u&#123;200D&#125;'+ 👧</span></span><br><span class="line"><span class="comment">// length: 11</span></span><br><span class="line">&gt; ‍👩‍👩‍👧‍👧</span><br></pre></td></tr></table></figure><p>因此，遇到文本有可能含有 Emoji 的情况中，需将 Emoji 字符正则匹配出来，单独进行计算。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>字符编码相关知识还有很多，本文仅介绍最近工作中所涉及的部分。更完善更准确的内容建议参考英文维基。</p><ul><li><a href="https://www.thoughtco.com/what-is-unicode-2034272" target="_blank" rel="noopener">What Is Unicode?</a></li><li><a href="cenalulu.github.io/linux/character-encoding/">十分钟搞清字符集和字符编码</a></li><li><a href="https://zhuanlan.zhihu.com/p/41203455" target="_blank" rel="noopener">从 Unicode 到 emoji</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">理解字节序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.dailymail.co.uk/i/pix/2016/10/27/21/39C8A74600000578-3879480-The_touch_bar_can_display_emotions_in_messaging_apps_playback_co-a-5_1477598860842.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为编程知识基础中的基础，有必要消化整理输出一次。&lt;/p&gt;
&lt;p&gt;本文主要介绍了字符编码的几个重要基础概念，从 &lt;code&gt;ASCII&lt;/code&gt; 到 &lt;code&gt;Unicode&lt;/code&gt; 再到 &lt;code&gt;Emoji&lt;/code&gt; 与 &lt;code&gt;JavaScript&lt;/code&gt; 字符处理的一些坑。&lt;/p&gt;
    
    </summary>
    
      <category term="cs" scheme="https://blog.colafornia.me/categories/cs/"/>
    
    
  </entry>
  
  <entry>
    <title>又双叒叕学习了一遍正则表达式</title>
    <link href="https://blog.colafornia.me/post/2018/learning-regex-again/"/>
    <id>https://blog.colafornia.me/post/2018/learning-regex-again/</id>
    <published>2018-07-11T12:00:00.000Z</published>
    <updated>2019-02-13T07:05:14.280Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/regex.jpg" alt="cover"></p><p>正则表达式基本上每用到一次就得从头自学一次，用完了写出来了也就忘光了。</p><p>前两天在 Twitter 上看到了题图，感觉又是个大坑，趁着手头还有 <a href="https://caraws.github.io/" target="_blank" rel="noopener">Caraws</a> 给的书就又双叒叕学习了一遍正则表达式。</p><p>本文试图先用最易懂的方式理顺正则表达式的知识点（就不贴一摞一摞的文档截图了，至于正则的使用场景和用处也不啰嗦了），主要介绍正则本身和在 JavaScript 中使用正则的坑。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>形如题图中的 <code>/abc/</code> 就是一个最简单的正则表达式（regular expression），一般被称之为模式（pattern）。</p><p>更具体一点的定义，正则表达式是用“正则表达式语言”来创建的，用于匹配和处理文本的字符串，它是内置于其它语言中的“迷你语言”。在不同语言中的正则表达式实现中，<strong>语法和功能可能会有一定差异</strong>（后面我们会详细讲一下）。</p><p><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a> 是一个在线练习网站，我们可以在界面上勾选不同的编程语言，也可以看到正则表达式的性能（匹配完成所需时间）以及具体的匹配步骤。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>总结了一下，我觉得把正则中的语法符号分为四类比较容易记忆：</p><ul><li>字符与字符集</li><li>预定义字符类</li><li>重复次数</li><li>功能字符（最后这种是我概括出来的名字）</li></ul><h3 id="字符与字符集"><a href="#字符与字符集" class="headerlink" title="字符与字符集"></a>字符与字符集</h3><p>首先要分清<code>字符</code>与<code>字符集</code>。</p><p><code>/abc/</code> 中的 a 匹配的是单个字符，这个模式就匹配的是三个字符，当文本是 ‘abcd’ 时会<strong>一次性匹配到字符串 ‘abc’</strong>。</p><p>然而用 <code>[]</code> <strong>字符集操作符</strong>包裹起来的 <code>/[abc]/</code> 就是一个字符集，<code>[abc]</code> 匹配的是一个字符，表明匹配为 a 或 b 或 c 的一个字符。因此，当文本是 ‘abcd’ 时执行匹配，<strong>每次只能匹配到单个字符</strong>，第一次匹配到 ‘a’，第二次匹配到’b’……</p><p>区分这两个概念并不难，一般（我自己是）等到了各种表达式嵌套的时候就开始懵逼了。</p><p>只能在字符集中使用的操作符有两个，<code>取非操作符^</code> 与 <code>字符区间-</code>。</p><p>在字符集中我们可以使用<code>取非操作符^</code>，<code>/[^abc]/</code>即为匹配 a，b，c 以外的任意字符。</p><p><code>/[a-c]/</code> 与 <code>/[abc]/</code> 相同，通过字符区间我们可以编写 <code>/[A-Za-z0-9]/</code> 这种简洁易读的正则表达式了。</p><h3 id="预定义字符类"><a href="#预定义字符类" class="headerlink" title="预定义字符类"></a>预定义字符类</h3><p>正则表达式预定义了一些常用的术语来代表一类字符。</p><p>比如 <code>\d</code> 为任意数字，<code>\D</code> 为任意非数字，更多预定义字符可以参看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">MDN</a>。</p><h3 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h3><p>以下符号跟在字符或者字符集的后面，代表重复次数：</p><ul><li><code>+</code>：重复一次或多次</li><li><code>*</code>：重复零次或多次</li><li><code>?</code>：重复零次或一次</li><li><code>{m, n}</code>：可表示区间，或是至少 m 次</li></ul><p>需要注意的是，除了 <code>?</code> 之外的三种都是贪婪型字符，可能会发生<strong>过度匹配</strong>的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">'aacbacbc'</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/a.*b/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); <span class="comment">// ["aacbacb", index:0...]</span></span><br></pre></td></tr></table></figure><p>此时执行一次匹配，由于 <code>*</code> 作为贪婪型字符会尽可能匹配更多内容，因此匹配到的是 aacbacb，而不是 aacb。在贪婪型字符后面加上 <code>?</code> 即变为非贪婪字符。</p><h3 id="功能字符"><a href="#功能字符" class="headerlink" title="功能字符"></a>功能字符</h3><p>举几个例子：</p><ul><li><p>正则尾部的  <code>/i</code> 表示忽略大小写，<code>/g</code> 表示匹配所有实例，<code>/m</code> 多行匹配</p></li><li><p>竖线符号 <code>|</code> 表明“或”，<code>a|b</code> 即匹配 a 或 b</p></li><li><p>小括号 <code>()</code> 可以用来分割子表达式</p></li><li><p><code>^字符串$</code> 代表字符串的前后边界</p></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>以上介绍的都是基础语法与字符匹配规则，正则还有两种较为高级的使用语法。</p><h3 id="回溯引用-backreference"><a href="#回溯引用-backreference" class="headerlink" title="回溯引用 backreference"></a>回溯引用 backreference</h3><p><code>回溯引用</code>是指模式的后半部分引用在前半部分中定义的子表达式。</p><p>语法：</p><ol><li><code>(x)</code> 子表达式</li><li><code>\</code> 标识回溯引用，<code>\n</code> 即代表第 n 个子表达式所匹配到的内容（在 replace 操作中使用 <code>$</code>）</li></ol><p>举一个典型例子，匹配 HTML 中的标题标签，HTML 可能如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>111<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>lalala<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>/&lt;[Hh][1-5]&gt;.*?&lt;\/[Hh][1-5]&gt;/</code> 我们会将 <code>&lt;h4&gt;lalala\&lt;/h3&gt;</code> 这种非法标签也匹配到。回溯引用就适用于这种场景，它可以实现<strong>前后一致匹配</strong>。</p><p><code>/&lt;([hH][1-5])&gt;.*?&lt;\/\1&gt;/</code> 中的 <code>\1</code> 只匹配第一个子表达式 <code>([hH][1-5])</code> 所匹配到的内容，从而避免匹配到对应不上的标签组合。</p><h3 id="前后查找-lookaround"><a href="#前后查找-lookaround" class="headerlink" title="前后查找 lookaround"></a>前后查找 lookaround</h3><p>还是引用上面的标题标签匹配例子，如果我们想只匹配到 <code>&lt;h1&gt;111&lt;/h1&gt;</code> 中的标题内容要怎么写正则呢？</p><p>这里涉及到两个新语法：</p><ul><li><code>?=</code>：向前查找</li><li><code>?&lt;=</code>：向后查找</li></ul><p><strong>以向前、向后查找开头的子表达式</strong>就是前后查找。</p><p>因此，正则可以为：<code>/(?&lt;=&lt;[Hh][1-5]&gt;).*(?=&lt;\/[Hh][1-5]&gt;)/</code></p><p>结合回溯引用与前后查找，还可以实现条件式的正则表达式，威力爆炸，只是这种形式的正则太难读了，有兴趣可以 Google 学习一下，这里不讲了。</p><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p>以上是正则表达式的知识点，现在讲讲坑。首先说说 JavaScript 中的正则。</p><h3 id="字面量-VS-RegExp"><a href="#字面量-VS-RegExp" class="headerlink" title="字面量 VS RegExp()"></a>字面量 VS RegExp()</h3><p>在 JavaScript 中创建正则表达式有两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则字面量</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\d+/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 RegExp 实例，以字符串形式传入正则</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\d+'</span>);</span><br></pre></td></tr></table></figure><p>两种方式创建出的正则没有任何差别。从创建方式上看，<strong>正则字面量可读性更优</strong>，因为正则中经常使用 <code>\</code> 反斜杠在字符串中是一个转义字符，想以字符串中表示反斜杠的话，需要使用 <code>\\</code> 两个反斜杠。</p><p>但是，需要注意，<strong>每个正则表达式都有一个独立的对象表示，每次创建正则表达式，都会为其创建一个新的正则表达式对象，这和其它类型（字符串、数组）不同</strong>。</p><p>我们可以通过<strong>让正则表达式只编译一次并将其保存在一个变量中以供后续使用</strong>来实现优化。</p><p>因此，第一段代码将创建三个正则表达式对象，并进行了三次编译，虽然表达式是相同的。而第二段代码则性能更高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">'a'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">'ab'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">'abc'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/abc/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pattern.test(<span class="string">'a'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pattern.test(<span class="string">'ab'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pattern.test(<span class="string">'abc'</span>));</span><br></pre></td></tr></table></figure><p>这其中有<strong>性能隐患</strong>。先记住这一点，我们继续往下看。</p><h3 id="冷知识-lastIndex"><a href="#冷知识-lastIndex" class="headerlink" title="冷知识 lastIndex"></a>冷知识 lastIndex</h3><p>这里我们来解释下题图中的情况是怎么回事。</p><p><img src="/images/regex.jpg" alt="cover"></p><p>这其实是全局匹配的坑，也就是正则后的 <code>/g</code> 符号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/abc/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pattern.global) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>用 <code>/g</code> 标识的正则作为全局匹配，也就拥有了 global 属性并导致了题图中呈现的异常行为。</p><p>全局正则表达式的另一个属性 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex" target="_blank" rel="noopener">lastIndex</a> 用于存放上一次匹配文本之后的第一个字符的位置。</p><p><code>RegExp.prototype.exec()</code> 和 <code>RegExp.prototype.test()</code> 方法都以 <code>lastIndex</code> 属性中所存储的位置作为下次正则匹配检索的起点。连续调用这两个方法就可以遍历字符串中的所有匹配文本。</p><p><code>lastIndex</code> 属性可读写，当 <code>RegExp.prototype.exec()</code> 或 <code>RegExp.prototype.test()</code> 再也找不到可以匹配的文本时，会自动把 lastIndex 属性重置为 0。因此<strong>使用这两个方法来检索文本，是可以无限执行下去的</strong>。我们也就明白了题图中为何每次执行 <code>RegExp.prototype.test()</code> 返回的结果都不一样。</p><p>不仅如此，看看下面这段代码，能看出来有什么问题吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="regexp">/a/g</span>.test(<span class="string">'ababc'</span>)) count++;</span><br></pre></td></tr></table></figure><p>不要轻易拷贝到控制台中尝试，会把浏览器卡死的。</p><p>由于每个循环中 <code>/a/g.test(&#39;ababc&#39;)</code> 都创建了新的正则表达式对象，每次匹配都是重新开始，这一操作会无限执行下去，形成死循环。</p><p>正确的写法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">while</span> (regex.test(<span class="string">'ababc'</span>)) count++;</span><br></pre></td></tr></table></figure><p>这样，每次循环中操作的都是同一个正则表达式对象，随着每次匹配后 <code>lastIndex</code> 的增加，等到将整个字符串匹配完成后，就跳出循环了。</p><p>给以上知识点画个<strong>重点</strong>：</p><ol><li>将正则表达式保存到变量中，只在逻辑中使用这个变量，不仅性能更高，还安全。</li><li>谨慎使用全局匹配，<code>RegExp.prototype.exec()</code> 或 <code>RegExp.prototype.test()</code>这两个方法的执行结果可能每次都不同。</li><li>做到了以上两点后，还要谨慎在循环中使用正则匹配。</li></ol><h3 id="回溯陷阱-Catastrophic-Backtracking"><a href="#回溯陷阱-Catastrophic-Backtracking" class="headerlink" title="回溯陷阱 Catastrophic Backtracking"></a>回溯陷阱 Catastrophic Backtracking</h3><p>回溯陷阱是正则表达式本身的一个坑了，会导致非常严重的性能问题，事故现场可以参看<a href="https://juejin.im/post/5b287ea6f265da596d04a324" target="_blank" rel="noopener">《一个正则表达式引发的血案，让线上 CPU100% 异常！》</a>。</p><p>简单介绍一下回溯陷阱的问题源头，正则引擎分为 <code>NFA（确定型有穷自动机）</code> 和 <code>DFA（不确定型有穷自动机）</code>，<code>DFA</code> 是从匹配文本入手，同一个字符不会匹配两次（可以理解为手里捏着文本，挨个字符拿去匹配正则），时间复杂度是线性的，它的功能有限，不支持回溯。大多数编程语言选用的都是 <code>NFA</code>，相当于手里拿着正则表达式，去匹配文本。</p><p><code>/(a(bdc|cbd|bcd)/</code> 中已经有三种匹配路径，在 <code>NFA</code> 中，以文本 ‘abcd’ 为例，将花费 7 步才能匹配成功：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/1648a0bec1e52c79?w=1332&amp;h=972&amp;f=jpeg&amp;s=46788" alt="regex101"><br>（图中还包括了字符边界的匹配步骤，因此多了三步）</p><ol><li>正则中的第一个字符 a 匹配到 ‘abcd’ 中的第一个字母 ‘a’，匹配成功。</li><li>此时遇到了匹配路径的分叉口，bdc 或 cbd 或 bcd，先使用 bdc 来匹配。</li><li>bdc 中的第一个字符 b 匹配到了 ‘abcd’ 中的第二个字母 ‘b’，匹配成功。</li><li>bdc 中的第二个字符 d 与 ‘abcd’ 中的第三个字母 ‘c’ 不匹配，这条路径匹配失败，此时将发生回溯（backtrack），把 ‘b’ 还回去。选择第二条路径 cbd 进行匹配。</li><li>cbd 的第一个字符 ‘c’ 就与 ‘b’ 匹配失败。开始第三条路径 bcd 的匹配。</li><li>bcd 的第一个字符 ‘b’ 与文本 ‘b’ 匹配成功。</li><li>bcd 的第一个字符 ‘c’ 与文本 ‘c’ 匹配成功。</li><li>bcd 的第一个字符 ‘d’ 与文本 ‘d’ 匹配成功。</li></ol><p>至此匹配完成。</p><p>可想而知，如果正则中再多一些匹配路径或者匹配本文再长一点，匹配步骤将多到难以控制。</p><p>比如用 <code>/(a*)*bc/</code> 来匹配 ‘aaaaaaaaaaaabc’ 都会导致性能问题，匹配文本中每增加一个 ‘a’，都会导致执行时间翻倍。</p><p>禁止这种回溯陷阱的方法有两种：</p><ol><li>占有优先量词（Possessive Quantifiers）</li><li>原子分组（Atomic Grouping）</li></ol><p>可惜 <strong>JavaScript 不支持这两种语法</strong>，有兴趣可以 Google 自行了解下。</p><p>在 JavaScript 中我们没有方法可以直接禁止回溯陷阱，我们只能：</p><ol><li>避免量词嵌套 <code>(a*)* =&gt; a*</code></li><li>减少匹配路径</li></ol><p>除此之外，我们也可以把正则匹配放到 Service Worker 中进行，从而避免影响页面性能。</p><p>查资料的时候发现，回溯陷阱不仅会导致性能问题，也有安全问题，有兴趣可以看看先知白帽大会上的<a href="https://xianzhi.aliyun.com/forum/attachment/big_size/WAF%E6%98%AF%E6%97%B6%E5%80%99%E8%B7%9F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%B4%E5%86%8D%E8%A7%81.pdf" target="_blank" rel="noopener">《WAF是时候跟正则表达式说再见》</a>分享。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26285406/" target="_blank" rel="noopener">《正则表达式必知必会》</a></li><li><a href="https://book.douban.com/subject/26638316/" target="_blank" rel="noopener">《JavaScript 忍者秘籍》第七章</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/regex.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;正则表达式基本上每用到一次就得从头自学一次，用完了写出来了也就忘光了。&lt;/p&gt;
&lt;p&gt;前两天在 Twitter 上看到了题图，感觉又是个大坑，趁着手头还有 &lt;a href=&quot;https://caraws.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Caraws&lt;/a&gt; 给的书就又双叒叕学习了一遍正则表达式。&lt;/p&gt;
&lt;p&gt;本文试图先用最易懂的方式理顺正则表达式的知识点（就不贴一摞一摞的文档截图了，至于正则的使用场景和用处也不啰嗦了），主要介绍正则本身和在 JavaScript 中使用正则的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="regex javascript" scheme="https://blog.colafornia.me/categories/regex-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器 GPU 动画优化与 Render Pipeline</title>
    <link href="https://blog.colafornia.me/post/2018/gpu-animation-render-pipeline/"/>
    <id>https://blog.colafornia.me/post/2018/gpu-animation-render-pipeline/</id>
    <published>2018-05-28T10:17:00.000Z</published>
    <updated>2019-02-13T07:05:14.278Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/render-pipeline-cover.jpg" alt="cover"></p><p>上周在组里做了一个小的技术分享，本文是对这次分享内容的一个文字化梳理。</p><a id="more"></a><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p><img src="https://p0.meituan.net/scarlett/e328aa2a7280812a89eced601d302f3418041.jpg" alt=""></p><p>一个 Web 页面由代码最终转化为屏幕上的像素点，大致遵循图中的步骤：</p><blockquote><p>JS/CSS &gt; 样式 &gt; 布局 &gt; 绘制 &gt; 合成</p></blockquote><p>① 指由 JavaScript 和 CSS 编写的动画代码</p><p>② 浏览器根据 CSS 选择器匹配计算（计算权重等）每个元素的最终样式</p><p>③ 浏览器计算元素所占的空间大小及其在屏幕上的位置（由于元素会互相影响，计算布局这一步骤会经常发生）</p><p>④ 在多个层上填充像素进行绘制，绘制每个元素的可视部分</p><p>⑤ 合成，将上一步中绘制出的多个层，正确合成到页面上</p><p>在之前的知识中，我们都知道，要正确使用、访问 CSS 属性，尽量少触发浏览器的 <code>重排重绘</code>，从而提升动画性能。</p><p>重排重绘指的是上述的③④步骤，本文主要探讨的是步骤⑤中的<strong>合成</strong>相关的概念与优化手段。</p><h3 id="二、渲染基础概念"><a href="#二、渲染基础概念" class="headerlink" title="二、渲染基础概念"></a>二、渲染基础概念</h3><p>在研究浏览器的 Composite 步骤前，有几个渲染相关的概念必须了解。</p><p>本文主要基于 Chrome 的内核 <code>Blink</code> 的渲染概念描述。</p><h4 id="1-Blink"><a href="#1-Blink" class="headerlink" title="1.Blink"></a>1.Blink</h4><p><img src="https://p1.meituan.net/scarlett/dc2500cbb537de8934117c2579ecad3227964.jpg" alt=""></p><p>在此之前我一直以为 Chrome 的内核依然是 <code>Webkit</code>，真是村通网。</p><p>实际上 <code>Webkit</code> 内核是苹果团队的开源作品，Chrome 在 2013 年之前一直基于其作为浏览器内核。直至 <code>Webkit2</code> 与 <code>Chromium</code> 的沙箱设计存在冲突，两方团队才决定分道扬镳。</p><p>Google 团队从 Webkit 中 fork 出一份代码，将在 <code>WebKit</code> 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 <code>WebKit</code> 的影响，创造一个完全独立的 <code>Blink</code>（据说删掉了 Webkit 中 880W 行代码）。</p><p>由于此缘故，Blink 与 Webkit 对于渲染过程中的一些流程，术语并不完全相同，本文以 Blink 为准。</p><h4 id="2-RenderObject-与-RenderLayer"><a href="#2-RenderObject-与-RenderLayer" class="headerlink" title="2.RenderObject 与 RenderLayer"></a>2.RenderObject 与 RenderLayer</h4><p><img src="https://p1.meituan.net/scarlett/aabc7b208641fdf392dfe9b855a109b576936.jpg" alt=""></p><p>浏览器解析 HTML 文件生成 <code>DOM 树</code>，然而 <code>DOM 树</code>是不可以直接被用于排版的，内核还会再生成 <code>RenderObject 树</code>。每一个可见的 DOM 节点都会生成相应的 RenderObject 节点。</p><p>排版引擎经过 DOM 树与 CSS 定义对 Render 树进行排版，Render 树作为排版引擎的输出，渲染引擎的输入。</p><p>拥有相同坐标空间的 RenderObject 属于同一渲染层（RenderLayer），RenderLayer 最初被用来实现<code>层叠上下文（stacking context）</code>，以保证页面元素以正确顺序合成。</p><p>生成 RenderLayer 与具备层叠上下文的条件是一样的：</p><p><img src="https://p0.meituan.net/scarlett/85b3d7376bc7c693e872ca668bef980b232822.jpg" alt=""></p><h4 id="3-GraphicsLayer"><a href="#3-GraphicsLayer" class="headerlink" title="3.GraphicsLayer"></a>3.GraphicsLayer</h4><p><img src="https://p0.meituan.net/scarlett/d48ec20953d86e41c8fb62bb6267690d38392.jpg" alt=""></p><p>某些特殊的 <code>RenderLayer</code> 渲染层会被认为是<code>合成层（Compositing Layers）</code>，合成层拥有单独的 GraphicsLayer。这其实是浏览器为了提升动画性能做出的设计。</p><p>为了在动画的每一帧的过程中不必每次都重新绘制整个页面。在特定方式下可以触发生成一个合成层，合成层拥有单独的 <code>GraphicsLayer</code>。</p><p>需要进行动画的元素包含在这个合成层之下，这样动画的每一帧只需要去重新绘制这个 <code>GraphicsLayer</code> 即可，从而达到提升动画性能的目的。</p><p>生成 GraphicsLayer 的条件：</p><p><img src="https://p1.meituan.net/scarlett/5855a920418f70e0e50f1b0438601e42168085.jpg" alt=""></p><h3 id="三、Render-Pipeline-渲染流水线"><a href="#三、Render-Pipeline-渲染流水线" class="headerlink" title="三、Render Pipeline 渲染流水线"></a>三、Render Pipeline 渲染流水线</h3><p>在了解了以上渲染概念后，我们可以来看看一个极简版的渲染流水线示意图：</p><p><img src="https://p0.meituan.net/scarlett/ff9a521cfb9093806a408fa2ba2a51c26992.png" alt=""></p><p>Blink 内核运行在主线程上，负责 JavaScript 的解析执行，HTML/CSS 解析，DOM 操作，排版，图层树的构建和更新等任务。</p><p>Layer Compositor（图层合成器）运行在 Compositor 线程上，接收 Blink 的输入，负责图层树的管理。</p><p>Display Compositor 接收 Layer Compositor 的输入，负责输出最终的 OpenGL 绘制指令，将网页内容通过 GL 绘制到显示屏上。</p><p>将渲染流水线的内容按照线程做一下区分：</p><p><img src="https://p0.meituan.net/scarlett/f7537a196f23b0f1f6b7ed9d893fedea39673.jpg" alt=""></p><p>由此，Web 动画可以分为两大类：</p><ul><li>合成器动画：大多数基于 CSS 的动画，<code>transforms</code> 和 <code>opacity</code> 等都可以在合成线程中处理。</li><li>非合成器动画：引起了绘制、布局的动画，<code>Timer</code> 或者 <code>requestAnimationFrame</code> 等由 JavaScript 驱动的动画。</li></ul><p><strong>如果浏览器在主线程上运行一些耗时的任务，合成器动画可以继续运行而不会中断</strong>。</p><h3 id="四、Web-动画优化建议"><a href="#四、Web-动画优化建议" class="headerlink" title="四、Web 动画优化建议"></a>四、Web 动画优化建议</h3><p><img src="https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/cheap-operations.jpg" alt=""></p><p>现代浏览器在完成以上四种属性的动画时，消耗成本较低。根本原因是这四种属性生成了自己的图形层（GraphicsLayer），开启了 <code>GPU 硬件加速</code>。</p><p>开启 GPU 硬件加速的方法主要有两种：</p><ul><li>will-change</li><li>transform: translateZ(0)</li></ul><p>第二种我们应该都不陌生，第一种是 CSS3 的属性，它会通知浏览器你打算更改元素的属性。浏览器会在你进行更改之前做最合适的优化。</p><p>然而通过生成图形层（GraphicsLayer）的方式来进行性能优化却有个深坑 —— <code>隐式合成</code>。</p><p><img src="https://p1.meituan.net/scarlett/4651555d9265a7d0280b038d501d31ac60552.jpg" alt=""></p><p>如图所示，a, b两个元素都具有 absolute 和 z-index 属性，其中 a 元素的 z-index 大于 b，因此 a 位于 b 图层之上。</p><p>如果我们将 a 元素使用 left 属性，做一个移动动画，那么 a元素就有了一个合成层，动画得到了性能提升。</p><p>那么，如果 a 静止不动，我们让 b 元素做动画呢？b 元素将拥有一个独立合成层；然后它们将被 GPU 合成。但是因为 a 元素要在 b 元素的上面（因为 a 元素的 z-index 比 b 元素高），那么浏览器会做什么？<strong>浏览器会将 a 元素也单独做一个合成层！</strong></p><p>所以我们现在有三个合成层 a 元素所在的复合层、b 元素所在的合成层、其他内容及背景层。</p><p>没有自己合成层的元素要出现在有合成层元素的上方，它就会拥有自己的复合层；这种情况被称为<strong>隐式合成</strong>。</p><blockquote><p>GraphicsLayer 虽好，但不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的 GraphicsLayer ，并计算他们下一帧的重绘区域，所以过量的 GraphicsLayer 计算也会给渲染造成性能影响。</p></blockquote><p>因此我们的最终结论是：</p><ol><li>尽量保持让需要进行 CSS 动画的元素的 z-index 保持在页面最上</li><li>有节制地优化，不要过早优化（不要滥用 will-change 等 GPU 加速手段）</li><li>根据 Chrome Devtool 查看 GraphicsLayer 每层占用的内存</li></ol><h3 id="五、参考内容"><a href="#五、参考内容" class="headerlink" title="五、参考内容"></a>五、参考内容</h3><ul><li><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="noopener">CSS GPU Animation: Doing It Right</a></li><li><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">无线性能优化：Composite</a></li><li><a href="https://zhuanlan.zhihu.com/p/30534023" target="_blank" rel="noopener">浏览器渲染流水线解析与网页动画性能优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/render-pipeline-cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;上周在组里做了一个小的技术分享，本文是对这次分享内容的一个文字化梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="render animation" scheme="https://blog.colafornia.me/categories/render-animation/"/>
    
    
  </entry>
  
  <entry>
    <title>装饰者模式 =&gt; AOP =&gt; ES7 decorator =&gt; React 高阶组件</title>
    <link href="https://blog.colafornia.me/post/2018/from-decorator-to-hoc/"/>
    <id>https://blog.colafornia.me/post/2018/from-decorator-to-hoc/</id>
    <published>2018-05-19T08:56:00.000Z</published>
    <updated>2019-02-13T07:05:14.277Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/1600/1*o6Q0MpSmQni2Q_sB5y9jig.png" alt=""></p><p>五月是学习的好时节啊，翻翻书继续学习一下设计模式吧。</p><p>该到<code>装饰者模式</code>了。来，学习一下。</p><p>书里的 <code>AOP</code> 是啥？学习一下。</p><p>新时代了再看看 ES7 规范的 <code>decorator</code> 吧，学习一下。。</p><p>啊还有 <code>React 高阶组件</code>的事儿呢，都学到这了，不差这一会儿。。。</p><a id="more"></a><h3 id="一、装饰者模式是什么"><a href="#一、装饰者模式是什么" class="headerlink" title="一、装饰者模式是什么"></a>一、装饰者模式是什么</h3><p>先看一下最为精确的英文维基定义：</p><blockquote><p>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class.</p></blockquote><p>对于传统的 OOP 语言来说，给对象(object)添加功能通常使用继承的方式，这不仅导致了超类与子类间的强耦合，也违反了<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">单一职责原则</a>。</p><p>装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。</p><h3 id="二、装饰者模式的典型应用：AOP"><a href="#二、装饰者模式的典型应用：AOP" class="headerlink" title="二、装饰者模式的典型应用：AOP"></a>二、装饰者模式的典型应用：AOP</h3><p>AOP 全称为 <code>Aspect-oriented programming</code>，即<code>面向切面编程</code>。主要适用于需要有横切逻辑的场景，比如数据上报，错误处理，鉴权，请求拦截等。</p><p>理解这个概念之后，实际操作就并不复杂。可以通过在原型上设置 <code>Function.prototype.before</code> 方法和 <code>Function.prototype.after</code> 方法，实现 <code>AOP 装饰函数</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个装饰函数都接收函数作为参数，只是所接收参数的执行顺序不同。</p><p>同理，我们也可以给 service 编写装饰函数，作为接口拦截器。如 <a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a> 中的 <code>Interceptors</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给请求添加拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发起请求前 do something</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给返回添加拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理返回数据</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这样，我们就可以在拦截器中统一处理错误与数据，不再需要在每一个 Promise 中都写一遍了，也便于统一项目中的处理方式。</p><p>关于 AOP 简单介绍到这里。</p><h3 id="三、ES7-Decorator"><a href="#三、ES7-Decorator" class="headerlink" title="三、ES7 Decorator"></a>三、ES7 Decorator</h3><p>ES7 的 decorator 装饰器借鉴于 Python 的思想，由 Yehuda Katz 提出，这里有<a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="noopener">提案的细节设计与语法糖在 ES6/ES5 中的转换</a>。</p><p>定义非常简短：</p><blockquote><p>Decorators make it possible to annotate and modify classes and properties at design time.</p></blockquote><p>”装饰器可以让我们在设计时对类和类的属性进行注解和修改“</p><p>有点抽象，我们先全盘了解这些讯息再来研究到底是怎么回事。</p><p>想理解 <code>decorator</code> 的用法，离不开 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>，ES7 也正是利用 <code>Object.defineProperty</code> 实现装饰器特性。</p><h4 id="1-前置知识：Object-defineProperty"><a href="#1-前置知识：Object-defineProperty" class="headerlink" title="1. 前置知识：Object.defineProperty"></a>1. 前置知识：Object.defineProperty</h4><p>如果了解过 Vue 双向绑定的实现原理，对 <code>Object.defineProperty</code> 就一定不陌生。</p><blockquote><p><code>Object.defineProperty(obj, prop, descriptor)</code></p></blockquote><blockquote><p>可以在对象上定义新属性，或修改已有属性，并将对象返回</p></blockquote><blockquote><p>参数 <code>obj</code>：要在其上添加或修改属性的对象</p><p>参数 <code>prop</code>：属性名</p><p>参数 <code>descriptor</code>：属性描述符，可以设置属性的数据属性与访问器属性</p></blockquote><p>其中 <code>descriptor</code> 可设置的属性有：</p><p>通用描述符：</p><ul><li>enumerable：Boolean，属性可否枚举</li><li>configurable：Boolean，若为 false，任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化</li></ul><p>数据描述符 data descriptor：</p><ul><li>value：属性值</li><li>writable：Boolean，是否可写</li></ul><p>访问器描述符 accessor descriptor：</p><ul><li>get： 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。</li><li>set：一旦目标属性被赋值，就会调回此方法。</li></ul><p>（Vue 就是在 get 和 set 函数中进行了拦截，判断数据是否变化，发送通知到订阅器中，详情可参考<a href="https://blog.colafornia.me/2017/03/14/observer-pattern-in-vue/">《观察者模式以及在 Vue 源码中的实践》</a>）</p><h4 id="2-ES7-Decorator-的用法"><a href="#2-ES7-Decorator-的用法" class="headerlink" title="2. ES7 Decorator 的用法"></a>2. ES7 Decorator 的用法</h4><p>ES7 Decorator 的使用场景不少，我们先看最简单典型的一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.writable = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'喵'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Cat();</span><br><span class="line">tom.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪'</span>);</span><br><span class="line">&#125;</span><br><span class="line">tom.say()    <span class="comment">// 喵</span></span><br></pre></td></tr></table></figure><p>readonly 就是一个 decorator 装饰器，它通过设置修饰符的 <code>writable</code> 属性，使得被装饰的 <code>say()</code> 只读。</p><p>装饰器本身是一个函数，接受三个参数，target，name 和 descriptor。</p><p>写一个 log 装饰器来看看这仨参数都是啥：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">    <span class="built_in">console</span>.log(target.hasOwnProperty(<span class="string">'constructor'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(target.constructor);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    @log</span><br><span class="line">    bar() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Foo();</span><br><span class="line">test.bar();</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/decorator1.jpg" alt=""></p><p>由此可以看出，target 就是被装饰的类本身，name 为被装饰的属性名，descriptor 与前述 Object.defineProperty 方法的属性描述符完全一样。</p><p>这仅仅是作为类属性的装饰器而言。实际上 decorator 有两种使用方法：</p><ul><li>装饰 Class，作为类装饰器</li><li>装饰类的属性</li></ul><p>作为类装饰器时，由于类本身是一个函数，因此 decorator 仅有 <code>target</code> 这一个参数。</p><p>需要注意的是，<strong>decorator 不能用于函数，因为存在函数提升</strong>。</p><h4 id="3-decorator-的使用场景"><a href="#3-decorator-的使用场景" class="headerlink" title="3. decorator 的使用场景"></a>3. decorator 的使用场景</h4><p>如前面所提到的 AOP 的用途，我们可以通过 decorator 实现横切逻辑，如日志上报，鉴权等。</p><p><a href="https://github.com/jayphelps/core-decorators/tree/master/src" target="_blank" rel="noopener">core-decorators</a> 中实现了一系列基础常用的装饰器，可以参考一下其中的实现。</p><p>平时开发中难免遇到需要使用定时器的场景，于是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>遇到一个就得写一个，函数被包裹来包裹去，并不是很美观。可以编写一个简单的 <code>timeout</code> 装饰器来重构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">milliseconds = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> target, key, descriptor </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">       &#125;, milliseconds);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  @timeout()</span><br><span class="line">  doSomething() &#123;&#125;</span><br><span class="line">  @timmeout(<span class="number">2000</span>)</span><br><span class="line">  doAnotherThing() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码结构清晰多了，装饰器也起到了注释的作用。</p><h4 id="4-decorator-在什么时候运行？"><a href="#4-decorator-在什么时候运行？" class="headerlink" title="4. decorator 在什么时候运行？"></a>4. decorator 在什么时候运行？</h4><p>尝试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before class'</span>);</span><br><span class="line"></span><br><span class="line">@log(<span class="string">'class Bar'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    @log(<span class="string">'class method bar'</span>)</span><br><span class="line">    bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @log(<span class="string">'class property foo'</span>)</span><br><span class="line">    foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after class'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">    @log(<span class="string">'object method bar'</span>)</span><br><span class="line">    bar() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/images/decorator2.jpg" alt=""></p><p>由此我们可以看出：</p><blockquote><p>装饰器是在声明期就起效的，并不需要类进行实例化。</p><p>类实例化并不会致使装饰器多次执行，因此不会对实例化带来额外的开销。</p><p>按编码时的声明顺序执行，并不会将属性、方法、访问器进行重排序。</p><p>因为以上这 2 个规则，我们需要特别注意一点，在装饰器运行时，你所能得到的环境是空的，在 Bar.prototype 或者 Bar 上的属性是获取不到的，也就是说整个 target 里其实只有 constructor 这一个属性。</p><p>换句话说，装饰器运行时所有的属性和方法均未定义。</p></blockquote><h3 id="四、React-高阶组件"><a href="#四、React-高阶组件" class="headerlink" title="四、React 高阶组件"></a>四、React 高阶组件</h3><p>之所以会有<code>高阶组件 higher-order component(HOC)</code>这个东西，主要是为了实现<strong>组件的抽象</strong>。</p><h4 id="1-Mixin"><a href="#1-Mixin" class="headerlink" title="1. Mixin"></a>1. Mixin</h4><p>想了解 HOC 干了啥，以及为啥需要它。依然要用 Vue 举例，Vue 的 <code>mixins</code> 混入方法实现了组件的混入，借此我们可以将组件粒度切细，使得项目高度配置化。</p><p>官网示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个混入对象</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个使用混入对象的组件</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// =&gt; "hello from mixin!"</span></span><br></pre></td></tr></table></figure><p>Vue 中的 mixin 数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时<strong>以组件数据优先</strong>。这也是实现 mixin 的重点逻辑。</p><p>看看 <code>core-decorators</code> 中 mixin 的核心实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getOwnPropertyDescriptors &#125; <span class="keyword">from</span> <span class="string">'./private/utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; defineProperty &#125; = <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClass</span>(<span class="params">target, mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!mixins.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">`@mixin() class <span class="subst">$&#123;target.name&#125;</span> requires at least one mixin as an argument`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> descs = getOwnPropertyDescriptors(mixins[i]);</span><br><span class="line">    <span class="keyword">const</span> keys = getOwnKeys(descs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, k = keys.length; j &lt; k; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[j];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(hasProperty(key, target.prototype))) &#123;</span><br><span class="line">        defineProperty(target.prototype, key, descs[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> mixins[<span class="number">0</span>] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleClass(mixins[<span class="number">0</span>], []);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> handleClass(target, mixins);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中把待 mixin 对象的每个方法都叠加到了 target 对象的原型上。其中通过 <code>defineProperty</code> 这个方法避免了覆盖 target 的原有属性。</p><p>但是 mixin 有很多弊病，这也是为什么最后我们选择了高阶组件来实现组件的 compose。主要问题有：</p><ul><li><strong>破坏组件原有封装</strong>：被 mixin 进来的组件都有自己的 props 和 state，导致在引入的时候需要千般小心，去维护那些我们不可见的状态。</li><li><strong>命名冲突</strong>：mixin 是一个平面结构，不同 mixin 中的命名不可知，譬如 <code>handleChange</code> 这种常见名就很容易冲突，无形中增加了开发和维护成本。</li></ul><p>因此高阶组件应运而生。</p><h4 id="2-高阶组件"><a href="#2-高阶组件" class="headerlink" title="2. 高阶组件"></a>2. 高阶组件</h4><p><code>高阶组件（higher-order component）</code>的概念类似于<code>高阶函数</code>，它接受 React 组件作为输入，输出一个新的 React 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>先看一个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">'./simple-hoc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normal</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以做很多自定义逻辑</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default simpleHoc(Normal);</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simpleHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'im a hoc!'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default simpleHoc;</span><br></pre></td></tr></table></figure><p>我们所定义的 Normal 组件通过 simpleHoc 的包裹后输出的新组件后，在 Normal 本身的功能上可以多打一个 Log，并继承了 simpleHoc 的 props。这是最简单的一个例子啦，高阶组件做的事情也比较逊。我们继续看看~</p><p>实现高阶组件的方法有两种：</p><ol><li>属性代理（<code>props proxy</code>）：高阶组件通过 WrappedComponent 来操作 props</li><li>反向代理（<code>inheritance inversion</code>）：高阶组件继承于 WrappedComponent</li></ol><p>这两种方法的使用场景也各不相同。</p><h3 id="五、实现高阶组件的两种方法与使用场景"><a href="#五、实现高阶组件的两种方法与使用场景" class="headerlink" title="五、实现高阶组件的两种方法与使用场景"></a>五、实现高阶组件的两种方法与使用场景</h3><h4 id="1-属性代理"><a href="#1-属性代理" class="headerlink" title="1. 属性代理"></a>1. 属性代理</h4><p>这是较为常见的一种方法，上面的 <code>simpleHoc</code> 的实现其实就属于属性代理。<strong>通过高阶组件传递 props 的方法就是属性代理</strong>。</p><p>使用场景：</p><ul><li>操作 <code>props</code></li><li>通过 <code>Refs</code> 访问到组件实例</li><li>提取 <code>state</code></li><li>用其他元素包裹 <code>WrappedComponent</code></li></ul><p>我们主要介绍一下最常见的，操作 props。其它三种应用在网上也能找到具体例子，不赘述了（文章到这里感觉已经非常长了……）</p><p>我们可以通过属性代理，来读取，编辑，增加或是删除 WrappedComponent 的 props。但应该注意小心编辑、删除重要的 props，尽量通过<strong>对高阶组件的 props 作新的命名来避免混淆</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span> (<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">myHoc</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        user: currentLoggedInUser</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，输出的新组件就可以通过 <code>this.props.user</code> 来获得当前登录人的信息。</p><p>使用的时候可以通过 decorator 来简化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@myHoc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure><h4 id="2-反向继承"><a href="#2-反向继承" class="headerlink" title="2. 反向继承"></a>2. 反向继承</h4><p>先看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">myHoc</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高阶组件返回的组件继承于 WrappedComponent，因此被称为 <code>Inheritance Inversion</code> 反向继承。</p><p><strong>反向继承模式下的高阶组件可以通过 this 访问到 WrappedComponent 的 state、props、组件生命周期方法和 render 方法</strong>。</p><p>使用场景：</p><ul><li>渲染劫持（<code>Render Highjacking</code>）</li><li>操作 <code>state</code></li></ul><p>渲染劫持是指高阶组件可以控制 WrappedComponent 的渲染过程并修改渲染结果，这意味着可以：</p><ul><li>在由 render <strong>输出</strong>的任何 React 元素中读取、添加、编辑、删除 props</li><li>读取和修改由 render 输出的 React 元素树</li><li>有条件地渲染元素树</li><li>把样式包裹进元素树（就像在 <code>Props Proxy</code> 中的那样）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.show) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到了高阶组件可以通过 this 访问到 WrappedComponent 的 state，可以对其进行编辑、删除，但这会使得 WrappedComponent 的内部状态混乱，难以维护，应避免这样使用。</p><p>最后，我们来看下高阶组件与 Mixin 的区别：</p><p><img src="/images/decorator3.jpg" alt=""></p><p>高阶组件更符合函数式编程思想，原组件不会感知到高阶组件的存在，最后我们所使用的都是一个新组件，从而避免了 Mixin 的那些弊病。</p><h3 id="五、参考内容"><a href="#五、参考内容" class="headerlink" title="五、参考内容"></a>五、参考内容</h3><ul><li><a href="https://book.douban.com/subject/26918038/" target="_blank" rel="noopener">《深入React技术栈》</a></li><li><a href="http://efe.baidu.com/blog/introduction-to-es-decorator/" target="_blank" rel="noopener">ES Decorators简介</a></li><li><a href="https://zhuanlan.zhihu.com/p/24776678" target="_blank" rel="noopener">深入理解 React 高阶组件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*o6Q0MpSmQni2Q_sB5y9jig.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;五月是学习的好时节啊，翻翻书继续学习一下设计模式吧。&lt;/p&gt;
&lt;p&gt;该到&lt;code&gt;装饰者模式&lt;/code&gt;了。来，学习一下。&lt;/p&gt;
&lt;p&gt;书里的 &lt;code&gt;AOP&lt;/code&gt; 是啥？学习一下。&lt;/p&gt;
&lt;p&gt;新时代了再看看 ES7 规范的 &lt;code&gt;decorator&lt;/code&gt; 吧，学习一下。。&lt;/p&gt;
&lt;p&gt;啊还有 &lt;code&gt;React 高阶组件&lt;/code&gt;的事儿呢，都学到这了，不差这一会儿。。。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript react" scheme="https://blog.colafornia.me/categories/javascript-react/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 原理应知应会</title>
    <link href="https://blog.colafornia.me/post/2018/dive-into-git/"/>
    <id>https://blog.colafornia.me/post/2018/dive-into-git/</id>
    <published>2018-05-08T05:10:00.000Z</published>
    <updated>2019-02-13T07:05:14.276Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/dive-into-git/cover.jpg" alt="cover"></p><p>初学编程时，Git 算是最令人心有余悸的 Boss 了，毕竟相比于写出 Bug 这种常见事情，把自己/别人代码弄丢这种事更为可怕。</p><p>本文只介绍 Git 原理中最为硬核的部分，如果想把所有原理都探究明白，内容多到可以写本书。因此，本文只试图解答：</p><blockquote><ol><li>Git 是怎么存储内容的？存到哪里了？</li><li>工作区，暂存区，版本库，各种教程里这仨名词一看就晕，能说人话吗？</li><li>git reset 来，git reset 去，感觉啥都能 reset，我到底在干啥？</li><li>Git 快在哪里？大神都说 Git 好用，怎么还这么难学？</li></ol></blockquote><p>Let’s go!</p><a id="more"></a><h3 id="一、Git-简介"><a href="#一、Git-简介" class="headerlink" title="一、Git 简介"></a>一、Git 简介</h3><p>首先回顾一下 Git 是什么，Git 是一个<code>分布式版本控制系统（Distributed Version Control System - DVCS）</code>。由 Linux 之父 Linus Torvalds 用两周时间写出了第一个版本。经过十多年的发展，Git 的内部设计基本没有变化。</p><p>它与先前流行的版本控制系统 <code>SVN</code> 相比，区别在于，除了中央仓库，还有本地仓库。中央仓库仅负责同步团队代码，其它如查看历史，提交代码等操作可以在成员的本地仓库中进行。除此之外，SVN 存储的是版本间的文件差异，Git 存储的则是每一个版本的<code>快照</code>，后面我们将详细说明。</p><h3 id="二、Git-文件系统"><a href="#二、Git-文件系统" class="headerlink" title="二、Git 文件系统"></a>二、Git 文件系统</h3><p>我们对于 Git 的使用，都是在使用命令，例如 <code>git add</code>，<code>git commit</code> 等，它们都属于 Git 的<code>高层命令</code>。</p><p>通过 <code>git help -a</code> 查看所有的 Git 命令：</p><p><img src="/images/dive-into-git/dive-into-git1.jpg" alt="dive-into-git1"></p><p>实际上，Git 有一百多个命令，其中<code>底层命令</code>被设计为 Unix 风格，由脚本调用，并不常用。我们平时所使用的<code>高层命令</code>设计的更为友好（可以理解为是被高度封装过的现成工具）。因此，想要了解 Git 原理就必须从<code>底层命令</code>入手。</p><p><img src="https://yanhaijing.com/blog/464.png" alt=""></p><p>每当执行 <code>git init</code> 时，Git 便会创建一个 <code>.git</code> 目录，几乎 Git 所储存，操作的所有内容都在这个目录下（如果想拷贝一个 Git 仓库，拷贝这个目录即可）。了解 Git 原理也可以称为了解这个这个目录各部分是做什么的。</p><p><img src="/images/dive-into-git/dive-into-git2.jpg" alt="dive-into-git2"><br>（图中是我的一个小项目的 <code>.git</code> 目录）</p><ul><li>指针 (HEAD, FETCH_HEAD, ORIG_HEAD)</li><li>对象<ul><li>objects/（所有的对象，包括blob， tree， commit）</li><li>refs/ （所有的引用）<ul><li>local branch</li><li>remote branch</li><li>tag</li></ul></li></ul></li><li>index (索引)</li><li>config (设置)</li></ul><p>接下来我们来重点介绍一下 objects 和 refs 两个部分。</p><h4 id="1-objects"><a href="#1-objects" class="headerlink" title="1. objects"></a>1. objects</h4><p><img src="/images/dive-into-git/dive-into-git7.jpg" alt="dive-into-git7"><br>（刚初始化的项目，objects 目录下只有两个空文件夹）</p><p>首先看一下最基本的部分，objects 目录，Git 所存储的数据都在这里。我们来看看 Git 到底是怎么存储内容的吧。</p><p>前面提到了 Git 存储的是<code>快照</code>，这实际上说的是 <code>SHA-1 哈希值</code>。</p><blockquote><p>Git 为每份内容生成一个文件，取得其 SHA-1 哈希值，用哈希值的前两个字符为名称创建子目录，用剩下 38 个字符为文件命名 (保存至子目录下)。</p></blockquote><p>听起来有点绕口，我们可以动手操作实验一下，通过底层命令 <code>hash-object</code> 可以计算内容的 SHA-1 值：</p><p><img src="/images/dive-into-git/dive-into-git3.jpg" alt="dive-into-git3"><br>字符串 hello git 的哈希结果是 <code>8d0e41234f24b6da002d962a26c2495ea16a425f</code></p><p>把这段字符串保存在一个文件中再计算 SHA-1：</p><p><img src="/images/dive-into-git/dive-into-git4.jpg" alt="dive-into-git4"></p><p>得到了一样的哈希值。</p><p>改变一下文件的文本内容，哈希值则发生了改变：</p><p><img src="/images/dive-into-git/dive-into-git5.jpg" alt="dive-into-git5"></p><p>至此，我们已经知道：</p><blockquote><ol><li>Git 由文件内容计算其哈希值</li><li>哈希值相同则文件内容相同（即使我们将一个文件拷贝到不同目录下，Git 也仅存储一份内容）</li></ol></blockquote><p>现在我们把 hello.txt 文件提交：</p><p><img src="/images/dive-into-git/dive-into-git8.jpg" alt="dive-into-git8"></p><p>再看一下 objects 目录。</p><p><img src="/images/dive-into-git/dive-into-git6.jpg" alt=""></p><p>发现多了三个文件夹！其中 8d 文件夹和子文件名加起来（<code>8d0e4123...</code>）正好是字符串 hello git 的哈希结果。而 10 文件夹则是本次 commit 的哈希值。</p><p>除了 <code>hash-object</code> 命令之外，还有一个好用的底层命令 <code>cat-file</code>，它可以将数据内容取回，传入 <code>-p</code> 参数可以让该命令输出数据内容的类型。我们拿 commit 的哈希值试一试：</p><p><img src="/images/dive-into-git/dive-into-git9.jpg" alt="dive-into-git9"><br>我们得到了 commit 对象，其中包含了本次提交的时间，commit message，提交者信息，以及一个类型为 <code>tree</code> 的哈希值 07ed5a7。对其取值查看，发现了第三个哈希对象，类型为 blob，其哈希值为 hello.txt 内容的哈希值。</p><p>三个哈希对象之间的关系：</p><p><img src="/images/dive-into-git/dive-into-git10.jpg" alt="dive-into-git10"><br>在此，我们已经知道了三种 <code>Git 基本对象</code>：</p><ul><li>Blob 对象：对单个文件的压缩存储</li><li>Tree 对象：对文件目录树的存储</li><li>Commit 对象：对 tree 对象的包装，带有其它提交信息</li></ul><p>因此仓库中的一个常规项目结构，在 .git 中会存储为右图所示的结构：</p><p><img src="/images/dive-into-git/dive-into-git12.jpg" alt="dive-into-git12"></p><p>现在我们再把 bye.txt 也提交了。可以发现新的 commit 哈希对象中还包含了 parent 信息，其值为上一个 commit 的哈希值。</p><p>Git history 中的各个 commit 其实是一个<code>单向链表</code>的结构，通过 parent 关联父节点。</p><p><img src="/images/dive-into-git/dive-into-git11.jpg" alt="dive-into-git11"><br>其中每个 commit 中都包含了当时仓库的目录结构与文件内容。这便是达成版本管理的基础。</p><h4 id="2-refs"><a href="#2-refs" class="headerlink" title="2. refs"></a>2. refs</h4><p>refs 目录存储了所有的引用文件。</p><p><img src="/images/dive-into-git/dive-into-git13.jpg" alt="dive-into-git13"><br>引用文件的内容也都是 40 位的 SHA-1 值。先看一下 master 是什么：</p><p><code>cat .git/refs/heads/master</code></p><p>哈希值为 <code>38779e1ee3e4959e21e599ad0974a2c915613d9e</code>，就是第二次提交 commit 的哈希值。我们可以猜测，<strong>branch 其实就是 commit 的引用</strong>。为了验证一下这个想法，我们新建一个分支试试：</p><p><img src="/images/dive-into-git/dive-into-git14.jpg" alt="dive-into-git14"><br>可以发现，refs 目录中多了一个与新分支同名的文件，且其哈希值依然为第二次提交 commit 的哈希值。所以我们的猜想没错。</p><p>但是当我们新建 new-branch 分支时，Git 是怎么知道最后一次提交的 SHA-1 值呢？答案就是 <code>HEAD 文件</code>。<strong><code>HEAD 文件</code>是一个指向你当前所在分支的引用标识符</strong>。也就是我们每次查找 log 时看到的 HEAD 标记：</p><p><img src="/images/dive-into-git/dive-into-git15.jpg" alt="dive-into-git15"></p><p>介绍到这里，我们可以发现<strong>Git 中的引用是非常廉价的</strong>，开新的 branch 和 tag 都只是多了一个引用文件，而有些中央式版本控制系统开分支时会复制一份内容，非常耗费资源。</p><p>分支是一种移动的引用。而标签则是静止的引用。<code>.git/refs</code> 目录下的 tags 目录就是保存标签信息的地方，标签同样也是 commit 对象的引用，只是它<strong>永远指向同一个 commit，不会变化</strong>。</p><p>最后一种引用类型是 <code>remote reference 远程引用</code>，我们每次执行将提交 push 到远端后，<code>.git/refs/remotes/</code> 目录下就会记录此次与远端通信的最后一个 commit 的哈希值。</p><p>与 Git 的引用文件强相关的高层命令是 <code>git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</code>，虽然这个命令后面可以加很多参数，但实际上它们所操作的都是 <code>.git/refs/heads</code> 目录下当前分支对应的引用文件。</p><h3 id="三、Git-暂存区"><a href="#三、Git-暂存区" class="headerlink" title="三、Git 暂存区"></a>三、Git 暂存区</h3><p>工作区，暂存区，版本库，这三个名词是我一开始看各种 Git 教程时最脑阔疼的东西，每次都要小心辨认，再心里默念一遍才分的清楚。其中工作区和版本库还好理解，<code>暂存区</code> 是最为懵逼的一个概念。</p><p>所以来看看 Git 暂存区到底是什么，为什么需要这个东西呢。</p><p>在 .git 目录下中有一个 index 文件它与暂存区的概念相关，我们动手实验看看它是干啥的。就着前面的实验，我们继续操作一下，改一下 hello.txt 的内容，然后执行 <code>git checkout</code> 撤销对这个文件的修改：</p><p><img src="/images/dive-into-git/dive-into-git16.jpg" alt="dive-into-git16"><br>撤销后工作区已经没有文件改动了，发现 <code>.git/index</code>文件的时间戳是 17:02:00。</p><p><img src="/images/dive-into-git/dive-into-git17.jpg" alt="dive-into-git17"><br>再通过 <code>git status</code> 看一下工作区状态，发现 <code>.git/index</code> 文件的时间戳没有变化。</p><p>我们用 Linux 命令 <code>touch</code> 改一下 hello.txt 的时间戳再看看：</p><p><img src="/images/dive-into-git/dive-into-git18.jpg" alt="dive-into-git18"><br>发现虽然文件没有变化，<code>.git/index</code> 文件的时间戳却发生了改变。</p><blockquote><p>这是因为 <code>git status</code> 命令查看工作区状态时，先根据 .git/index 文件中记录的时间戳，长度等信息判断工作区文件是否改变。如果时间戳变了，说明文件<strong>有可能</strong>发生改变，Git 需要读取文件，与原始文件进行对比，去判断它是否发生变化。如果没有改变，则将文件新的时间戳记录到 .git/index 文件中。</p><p><strong>因为判断文件是否更改，使用时间戳、文件长度等信息进行比较要比通过文件内容比较要快的多</strong>，所以 Git 这样的实现方式可以让工作区状态扫描更快速的执行，这也是 Git 高效的因素之一。</p></blockquote><p><strong>.git/index 文件实际上是一个包含文件索引的目录树，就是所谓的<code>暂存区</code></strong>，它记录了文件的名称，时间戳，长度等信息，但并不储存文件，文件内容依然位于 <code>.git/objects</code> 中。<code>.git/index</code> 中的索引建立了文件和对象库中对象实体之间的对应。</p><p><img src="https://www.worldhello.net/wpfiles/2010/11/git-stage.png" alt="index"></p><p>图中版本库中的 index 区域就是暂存区，可以看到 index 区域与 master 区域其实都是对 objects 中存储的文件内容的索引。与先前了解到的一致，游标形状的 <code>HEAD</code> 是一个指向当前所在分支的标识符。</p><p>图中还列出了 Git 命令是如何影响工作区与暂存区的。值得注意的是 <code>git reset HEAD</code> 命令。</p><p><code>git reset</code> 有两种使用方法：</p><ol><li><code>git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</code></li><li><code>git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;</code></li></ol><p>在前面我们了解到第一种使用方法实际上是改变了引用文件。 git reset 的第二种使用方法并不会改变引用，它会用已经 commit 到版本库的文件替换掉暂存区中的文件。因此，<code>git reset HEAD &lt;paths&gt;</code> 就是取消之前执行 <code>git commit &lt;paths&gt;</code> 时所改变的暂存区。</p><h3 id="四、Git-的痛点"><a href="#四、Git-的痛点" class="headerlink" title="四、Git 的痛点"></a>四、Git 的痛点</h3><p>粗浅地了解了以上原理之后，对于 Git 的痛点也可以窥知一二。</p><p>Git 的诞生经历和 JavaScript 有些相似，都是短时间内打造的兵器，其设计思路一开始就是很粗糙的，甚至有些不合理反人类的地方。（但是 JavaScript 还有 ECMAScript 一年一年的修补，Git 却没啥指望改进了……）</p><p>最明显的一个痛点是，一个 Git 命令身兼数职的情况非常多（git rebase，git reset，git checkout 是重灾区），这也是造成新手入门时每天一脸懵逼的一个主要原因。</p><p>Git 本身的设计理念是非常清晰明确的，如果可以重新设计的话，希望指令可以与其设计思路统一，指令分为四类：</p><blockquote><ol><li>操作当前指针</li><li>操作分支</li><li>操作版本</li><li>操作工作环境</li></ol></blockquote><p>有一篇论文<a href="https://groups.csail.mit.edu/sdg/pubs/2016/gitless-oopsla16.pdf" target="_blank" rel="noopener">《Purposes, Concepts, Misfits, and a Redesign of Git》</a>专门分析 Git 的设计问题。最后设计了一款新工具叫 Gitless。</p><p>除了这一点之外，由于 Git 存储的是文件快照，如果项目需要频繁修改大文件的话很容易造成存储库的膨胀，这一点虽然有<a href="https://blog.colafornia.me/2018/03/09/slove-git-clone-speed/">解决方案</a>，但不可否认依然是其痛点之一。</p><h3 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h3><p>除了以上介绍到的内容，git rebase，git reflog，git checkout，git cherry-pick 也都是值得探究的命令。</p><h4 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h4><ul><li><a href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain" target="_blank" rel="noopener">Git Internals</a></li><li><a href="https://gotgit.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Git 权威指南</a></li><li><a href="https://yanhaijing.com/git/2017/02/08/deep-git-3/" target="_blank" rel="noopener">起底Git-Git内部原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/dive-into-git/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;初学编程时，Git 算是最令人心有余悸的 Boss 了，毕竟相比于写出 Bug 这种常见事情，把自己/别人代码弄丢这种事更为可怕。&lt;/p&gt;
&lt;p&gt;本文只介绍 Git 原理中最为硬核的部分，如果想把所有原理都探究明白，内容多到可以写本书。因此，本文只试图解答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Git 是怎么存储内容的？存到哪里了？&lt;/li&gt;
&lt;li&gt;工作区，暂存区，版本库，各种教程里这仨名词一看就晕，能说人话吗？&lt;/li&gt;
&lt;li&gt;git reset 来，git reset 去，感觉啥都能 reset，我到底在干啥？&lt;/li&gt;
&lt;li&gt;Git 快在哪里？大神都说 Git 好用，怎么还这么难学？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s go!&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://blog.colafornia.me/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Thrift 速记</title>
    <link href="https://blog.colafornia.me/post/2018/thrift-note/"/>
    <id>https://blog.colafornia.me/post/2018/thrift-note/</id>
    <published>2018-03-27T03:11:00.000Z</published>
    <updated>2019-02-13T07:05:14.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>Apache Thrift</code> 是一款 <code>RPC</code> (跨语言的服务)框架，传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。</p><p><img src="/images/thrift.png" alt=""></p><h3 id="RPC-是什么"><a href="#RPC-是什么" class="headerlink" title="RPC 是什么"></a>RPC 是什么</h3><p><code>Remote Procedure Call</code> 即远程过程调用。</p><blockquote><p>RPC 是一个 <code>计算机通信协议</code>。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 —— 中文维基</p></blockquote><a id="more"></a><p>远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。</p><p>标准化的 RPC 大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。</p><p>相比于 <a href="http://www.ruanyifeng.com/blog/2011/09/restful" target="_blank" rel="noopener">RESTful</a>，RPC 的优势在于：</p><ul><li>采用二进制的传输格式，相比于 RESTful 采用的 JSON 格式体积更小速度更快</li><li>支持多种传输协议与传输格式</li><li>支持同步和异步通信</li></ul><h3 id="Thrift-文件概览"><a href="#Thrift-文件概览" class="headerlink" title="Thrift 文件概览"></a>Thrift 文件概览</h3><p>以 <code>.thrift</code> 为后缀的文件，是服务消费方（Consumer）与服务提供方（Provider）之间用来进行接口描述（IDL）的文件。</p><h4 id="1-代码示例："><a href="#1-代码示例：" class="headerlink" title="1.代码示例："></a>1.代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thrift 文件一般包含两部分的内容</span></span><br><span class="line"><span class="comment">// 1) 类型说明，类似于前后端所约定的请求对象有哪些字段值</span></span><br><span class="line"><span class="comment">// 2) 接口服务 Service 说明，包含一系列的方法，类似于前后端之间约定的请求方法</span></span><br><span class="line"><span class="comment">// IDL 中可以定义以下一些类型：基本数据类型，结构体，容器，异常、服务</span></span><br><span class="line"><span class="comment">// 以下 IDL 定义了一个叫 Sample 的服务，其有一个叫 getOrderById 的方法</span></span><br><span class="line"></span><br><span class="line">struct Order &#123;</span><br><span class="line">  <span class="number">1</span>:i64 id;</span><br><span class="line">  <span class="number">2</span>:i32 status;</span><br><span class="line">&#125;</span><br><span class="line">service Sample</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Order <span class="title">getOrderById</span><span class="params">(<span class="number">1</span>:i64 id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-基本类型："><a href="#2-基本类型：" class="headerlink" title="2.基本类型："></a>2.基本类型：</h4><ul><li><p><code>bool</code>: 布尔类型</p></li><li><p><code>byte</code>: 有符号字节</p></li><li><p><code>i16/i32/i64</code>: 16/32/64位有符号整型</p></li><li><p><code>double</code>: 64位浮点数</p></li><li><p><code>string</code>: 未知编码或者二进制的字符串</p></li></ul><h4 id="3-容器："><a href="#3-容器：" class="headerlink" title="3.容器："></a>3.容器：</h4><ul><li><p><code>list&lt;t1&gt;</code>: 排序数组，可以重复</p></li><li><p><code>set&lt;t1&gt;</code>: 集合，每个元素唯一</p></li><li><p><code>map&lt;t1, t2&gt;</code>: key/value 键值对（key 的类型是 t1且 key 唯一，value 类型是 t2）</p></li></ul><h4 id="4-通过-IDL-文件生成代码"><a href="#4-通过-IDL-文件生成代码" class="headerlink" title="4.通过 IDL 文件生成代码"></a>4.通过 IDL 文件生成代码</h4><p>通过 IDL 一般生成两种类型的文件，1）类型文件 2）接口文件</p><p>形如 <code>xxx_types.js</code> 即是将 IDL 文件中的类型说明输出为类型文件。</p><p>形如 <code>xxxService.js</code> 即是接口文件，服务消费方通过接口文件来创建和 Provider 的连接。</p><p>在通信的过程中，thrift 会对数据进行序列化后传递给另一方，在接收方则对数据进行反序列化后映射成对应的语言对象。于是，我们就可以不关心数据格式和类型转换，直接调用远程服务了。</p><h3 id="Node-Thrift-应用"><a href="#Node-Thrift-应用" class="headerlink" title="Node Thrift 应用"></a>Node Thrift 应用</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p>除了<a href="http://thrift.apache.org/docs/install/os_x" target="_blank" rel="noopener">官网下载</a>，Mac 下比较方便的安装方式是使用 homebrew：</p><p><code>brew install thrift</code></p><h4 id="2-生成代码"><a href="#2-生成代码" class="headerlink" title="2.生成代码"></a>2.生成代码</h4><p>语法为 <code>thrift --gen &lt;language&gt; &lt;Thrift filename&gt;</code></p><p>生成 Node.js 代码的话：</p><p><code>thrift --gen js:node Service.thrift</code></p><p>在实际项目中一般会封装多个 shell 脚本来做这件事，方便维护与使用。</p><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><p>Apache 已经推出了 <a href="http://thrift.apache.org/tutorial/nodejs" target="_blank" rel="noopener">官方的 Node.js 库</a></p><p>Client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此示例代码大致浏览即可</span></span><br><span class="line"><span class="keyword">var</span> thrift = <span class="built_in">require</span>(<span class="string">'thrift'</span>);</span><br><span class="line"><span class="keyword">var</span> Calculator = <span class="built_in">require</span>(<span class="string">'./gen-nodejs/Calculator'</span>);</span><br><span class="line"><span class="keyword">var</span> ttypes = <span class="built_in">require</span>(<span class="string">'./gen-nodejs/tutorial_types'</span>);</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transport = thrift.TBufferedTransport;</span><br><span class="line"><span class="keyword">var</span> protocol = thrift.TBinaryProtocol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> connection = thrift.createConnection(<span class="string">"localhost"</span>, <span class="number">9090</span>, &#123;</span><br><span class="line">  transport : transport,</span><br><span class="line">  protocol : protocol</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  assert(<span class="literal">false</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Calculator client with the connection</span></span><br><span class="line"><span class="keyword">var</span> client = thrift.createClient(Calculator, connection);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client.ping(<span class="function"><span class="keyword">function</span>(<span class="params">err, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ping()'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client.add(<span class="number">1</span>,<span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"1+1="</span> + response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，就可以调用其它语言编写的服务了。</p><p>公司内部有一个封装好了连接过程的 thrift 包，使用起来更简单些，把端口号，ip 等信息传进去即可使用。</p><p>更多语言和使用示例可参考 <a href="http://thrift-tutorial.readthedocs.io/en/latest/usage-example.html" target="_blank" rel="noopener">thrift-tutorial</a></p><h3 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h3><p>一直以来都是使用 HTTP 协议进行接口调用，只知道有一些“后端之间的服务调用”是使用 Thrift 接口，没有想过前端项目中也会直接调用。</p><p>之所以会用到 Thrift，是因为公司采用的是“面向服务的架构”，我们所开发的 Web 应用也是一个服务，其中还会依赖其它服务。</p><p><code>SOA（Service-Oriented Architecture，面向服务的架构）</code>是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信。</p><p>微服务架构是 SOA 的一种特定方法。</p><p><img src="/images/2018-3-microservices.png" alt="microservices"></p><p>更多内容参考<a href="https://book.douban.com/subject/26772677/" target="_blank" rel="noopener">《微服务设计》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Apache Thrift&lt;/code&gt; 是一款 &lt;code&gt;RPC&lt;/code&gt; (跨语言的服务)框架，传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/thrift.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;RPC-是什么&quot;&gt;&lt;a href=&quot;#RPC-是什么&quot; class=&quot;headerlink&quot; title=&quot;RPC 是什么&quot;&gt;&lt;/a&gt;RPC 是什么&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Remote Procedure Call&lt;/code&gt; 即远程过程调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RPC 是一个 &lt;code&gt;计算机通信协议&lt;/code&gt;。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 —— 中文维基&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="thrift" scheme="https://blog.colafornia.me/categories/thrift/"/>
    
    
  </entry>
  
  <entry>
    <title>解决 git clone 慢的问题</title>
    <link href="https://blog.colafornia.me/post/2018/slove-git-clone-speed/"/>
    <id>https://blog.colafornia.me/post/2018/slove-git-clone-speed/</id>
    <published>2018-03-09T08:20:00.000Z</published>
    <updated>2019-02-13T07:05:14.280Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018-3-git.png" alt="git-cover"></p><p>年后这段时间连续遇到了两次 git clone 龟速缓慢，一天之内都 clone 不下来的问题。这里记录一下解决方法和原理。</p><p>git clone 太慢的常规原因有两种，<strong>第一种是 git 仓库本身导致的，第二种是我们使用者的网络问题</strong>。</p><a id="more"></a><h2 id="一、Git-仓库体积太大"><a href="#一、Git-仓库体积太大" class="headerlink" title="一、Git 仓库体积太大"></a>一、Git 仓库体积太大</h2><p>大体积 Git 仓库一般也有两种，一是 commit 历史长，协作分支多导致的仓库自身体积变大，二是有过多的二进制文件。</p><h4 id="1-commit-历史长，协作分支多导致的仓库自身体积变大"><a href="#1-commit-历史长，协作分支多导致的仓库自身体积变大" class="headerlink" title="1. commit 历史长，协作分支多导致的仓库自身体积变大"></a>1. commit 历史长，协作分支多导致的仓库自身体积变大</h4><p>Git 会把文件的每一个差异化版本都存储起来，随着 commit 越来越多，每一次小的修改 Git 都会存储一个新的快照，自然版本库体积也会越来越大。</p><h5 id="①-浅克隆-shallow-clone"><a href="#①-浅克隆-shallow-clone" class="headerlink" title="① 浅克隆 shallow clone"></a>① 浅克隆 shallow clone</h5><p><code>git clone --depth n git://someserver/somerepo</code></p><p>很多时候我们只对版本库的最近几次提交感兴趣，就可以通过 shallow clone 仅仅克隆最新的 n 条记录到本地，节省了非常多的时间。这种方法适用于当我们想对查看研究某远端库时使用，如果想在浅克隆的库上推送提交，会有一些限制。</p><blockquote><p>通过浅克隆方式克隆出来的版本库，每一个提交的 SHA1 哈希值和源版本库的相同，包括提交的根节点也是如次，但是 git 通过特殊的实现，使得浅克隆的根节点提交看起来没有父提交。正因为浅克隆的提交对象的 SHA1 哈希值和源版本库一致，所以浅克隆版本库可以执行 git fetch 或者 git pull 从源版本库获取新的提交。</p></blockquote><h4 id="②-只-clone-一个分支"><a href="#②-只-clone-一个分支" class="headerlink" title="② 只 clone 一个分支"></a>② 只 clone 一个分支</h4><p><code>git clone URL --branch branch_name --single-branch [folder]</code></p><p>一般可以指定只 clone master 分支到本地，同样了节省了很多时间。</p><h4 id="2-有过多的二进制文件"><a href="#2-有过多的二进制文件" class="headerlink" title="2. 有过多的二进制文件"></a>2. 有过多的二进制文件</h4><p>Git 主要适用于对文本文件进行版本控制，并不能很好地处理二进制文件的增量提交，每次更新一个二进制文件就会把这份文件的完整内容存储一份，随着更新修改越来越多，版本库的体积也会非常大，影响代码的拉取速度（这应该也是游戏团队主要还在使用 SVN 的原因）。</p><p>这种情况较少会发生在前端项目仓库中，针对这种原因造成的 git clone 慢依然可以通过上面两种方法来节省克隆时间，除此之外在此简单介绍一下<strong>如何解决由于二进制文件造成的版本库体积过大问题</strong>。</p><h4 id="①-稀疏检出-sparse-checkout"><a href="#①-稀疏检出-sparse-checkout" class="headerlink" title="① 稀疏检出 sparse checkout"></a>① 稀疏检出 sparse checkout</h4><p>通过 Git 在 1.7.0 版本之后提供的稀疏检出功能，可以设置只 checkout 出自己想要的内容。此时就可以通过它来跳过二进制文件。Worktree 中就只有我们指定检出的文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config core.sparseCheckout true // 开启稀疏检出功能</span><br><span class="line">echo &quot;path1/&quot; &gt;&gt; .git/info/sparse-checkout // 指定检出路径</span><br></pre></td></tr></table></figure><blockquote><p>原理是 git 在暂存区为每个文件提供一个名为 <code>skip-worktree</code> 标识位，如果标识位开启则无论工作区对应的文件存在与否，是否被修改，git 都认为该文件的版本是最新的，没有变化。</p></blockquote><h4 id="②-大文件储存-Git-LFS"><a href="#②-大文件储存-Git-LFS" class="headerlink" title="② 大文件储存 Git LFS"></a>② 大文件储存 Git LFS</h4><p>Github 和 Gitlab 目前都已经使用 <a href="https://git-lfs.github.com/" target="_blank" rel="noopener">Git LFS</a> 来支持二进制大文件的版本控制，将二进制文件存在版本库之外，在版本库内使用文本指针来代替。</p><p><img src="https://git-lfs.github.com/images/facebook-promo.png" alt="Git LFS"></p><h2 id="二、网络被墙"><a href="#二、网络被墙" class="headerlink" title="二、网络被墙"></a>二、网络被墙</h2><p>我这两次遇到的问题其实都是网络问题。春节前后辽宁那边的网络都是这个状况，年后回来我司的网络也被 github 墙了。这里介绍一下给 Git 设置代理的方法。</p><p>git clone 有两种协议可供选择：</p><p><img src="/images/git-clone-shot.jpeg" alt="git clone"></p><p>这里介绍的是针对 HTTPS 协议的代理。</p><p>首先来看一下自己的 SS 代理设置 socks5 监听端口是多少，比如我的端口就是1086：</p><p><img src="/images/ss.jpeg" alt="ss"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:1086</span><br></pre></td></tr></table></figure><p>这个设置只代理了 github，不会对国内仓库使用代理。</p><h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><ul><li><a href="https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html" target="_blank" rel="noopener">GotGit： 稀疏检出和浅克隆</a></li><li><a href="https://segmentfault.com/q/1010000000118837" target="_blank" rel="noopener">segmentfault：如何为 Git 设置代理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2018-3-git.png&quot; alt=&quot;git-cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;年后这段时间连续遇到了两次 git clone 龟速缓慢，一天之内都 clone 不下来的问题。这里记录一下解决方法和原理。&lt;/p&gt;
&lt;p&gt;git clone 太慢的常规原因有两种，&lt;strong&gt;第一种是 git 仓库本身导致的，第二种是我们使用者的网络问题&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://blog.colafornia.me/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>回顾一下 JavaScript 中的深浅拷贝以及内存管理</title>
    <link href="https://blog.colafornia.me/post/2018/review-copy-in-javascript/"/>
    <id>https://blog.colafornia.me/post/2018/review-copy-in-javascript/</id>
    <published>2018-01-13T01:05:00.000Z</published>
    <updated>2019-02-13T07:05:14.280Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/review-copy-in-javascript.png" alt="cover"></p><p>最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 <code>JSON.parse(JSON.stringify(target))</code> 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。</p><a id="more"></a><h3 id="基本类型-VS-引用类型，值传递-VS-引用传递"><a href="#基本类型-VS-引用类型，值传递-VS-引用传递" class="headerlink" title="基本类型 VS 引用类型，值传递 VS 引用传递"></a>基本类型 VS 引用类型，值传递 VS 引用传递</h3><p>首先回顾一下高程中的基本概念。</p><p>ECMAScript 变量包含两种数据类型的值：基本类型值与引用类型值。基本类型指的是简单的数据段，如 <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code>（ES6 中出现的 <code>Symbol</code> 也属于基本类型）。引用类型指的是可能由多个值构成的对象。</p><p>基本类型是按值访问的，<strong>可以操作保存在变量中的实际的值</strong>。</p><p>引用类型的值是保存在内存中的对象，<strong>JavaScript 不允许直接访问内存中的位置</strong>，因此我们在操作对象时，是在操作对象的引用而不是实际的对象。</p><p>然而访问变量有按值和按引用两种方式，而 <strong>参数只能按值传递</strong>。在向参数传递引用类型的值时，会把值在内存中的地址复制给另一个局部变量。</p><h3 id="深入内存"><a href="#深入内存" class="headerlink" title="深入内存"></a>深入内存</h3><p>以上虽然不难理解，但是不深层挖掘一下还是很难完全记住。所以来看看内存中到底发生了什么吧。</p><p>先看看内存的生命周期：</p><p><img src="https://raw.githubusercontent.com/dt-fe/weekly/master/assets/29/1.jpg" alt="life"></p><p>即 内存分配 =&gt; 内存读写 =&gt; 内存释放</p><p>JavaScript 在定义变量时即完成了内存分配。<strong>运算符= 就是创建或修改变量在内存中的指向。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;; <span class="comment">// a 为引用类型，给 a 分配内存 &#123; b: 1 &#125;， a 存储的即为 &#123; b: 1 &#125; 的地址</span></span><br><span class="line"><span class="keyword">var</span> c = a; <span class="comment">// 给 c 分配内存 指向 a 存储的地址，即 &#123; b: 1 &#125; 的地址</span></span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 修改 a 的内存指向到 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// c 存储的仍为 &#123; b: 1 &#125; 的地址，因此结果为 &#123; b: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>前两行代码在内存中的分布为：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">内存</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">{ b: 1 } 地址</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">{ b: 1 } 地址</td></tr></tbody></table><p>第三行修改了内存指向：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">内存</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">2</td></tr></tbody></table><p>变量 c 仍然指向 { b: 1 } 的地址。</p><p>再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">var</span> n = m; <span class="comment">// 复制引用类型的值，使 n 和 m 指向同一地址</span></span><br><span class="line">n.a = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.a);</span><br></pre></td></tr></table></figure><p>还是先看前两行：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">内存</th></tr></thead><tbody><tr><td style="text-align:center">m</td><td style="text-align:center">{ a: 10, b: 20 } 地址</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">{ a: 10, b: 20 } 地址</td></tr></tbody></table><p>第三行通过 n.a 修改了变量，但 m 和 n 仍然指向同一地址不变，因此 m.a 的值也为 15</p><p>对于参数传递过程中的内存变化不是本文重点，可以观摩 <a href="https://github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="noopener">JavaScript深入之参数按值传递</a> 下面精彩的评论来学习。</p><p>有很多博文还针对 JavaScript 的内存空间，栈内存与堆内存进行了讲解，但是对于这方面实在没有经验，没什么鉴别能力，暂时先不说了。</p><h3 id="JavaScript-中的深浅拷贝"><a href="#JavaScript-中的深浅拷贝" class="headerlink" title="JavaScript 中的深浅拷贝"></a>JavaScript 中的深浅拷贝</h3><p>回顾完以上知识点后，可以发现对于对象的拷贝，其实分为两种情况（这里，将被拷贝对象称为源对象）：</p><ul><li>shallow clone 浅拷贝：如果对象中某个属性值是对象的话，浅拷贝的只是内存指针，当内存中的值发生变化后，拷贝对象与源对象与都会发生改变。</li><li>deep clone 深拷贝：拷贝对象与源对象是完全单独的对象，没有属性值是指向同一内存指针的，源对象发生任何修改都不会引起拷贝对象发生变化。</li></ul><p>需要注意一点，ES6 中 Object 的新方法 <code>Object.assign</code> 执行的就是浅拷贝，Stack Overflow 上有一个高票回答误将其答为深拷贝，我就踩了坑，避免加深错误印象，这里不放链接了。</p><p>ES6 中的 Object <code>rest/spread destructuring</code> 也是浅拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> existing = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; ...clone &#125; = existing;</span><br></pre></td></tr></table></figure><p>对于深拷贝，可想而知，需要对嵌套对象进行递归遍历，但是真正实现 deep clone 没有想象的简单，主要原因在于 deep clone 的定义并不统一，以及 edge case 非常多，包含 DOM/BOM 对象如何处理，函数如何处理，原型链如何处理等问题。但是希望 “做出修改不影响其它引用” 确实是一个常见场景。</p><p>最简单的方法就是开头提到的 <code>JSON.parse(JSON.stringify(target))</code>。缺点在于无法处理 Date、Function 等类型的属性值。</p><p>因此在业务中推荐使用 lodash 的 <a href="https://lodash.com/docs/4.17.4#cloneDeep" target="_blank" rel="noopener">_.cloneDeep</a> 实现深拷贝，简洁可靠。</p><p>实际上，在 <a href="http://facebook.github.io/immutable-js/" target="_blank" rel="noopener">immutable.js</a> 出现后，实现数据结构的持久化有了更优雅的方式。</p><h3 id="希望之光-Immutable"><a href="#希望之光-Immutable" class="headerlink" title="希望之光 Immutable"></a>希望之光 Immutable</h3><p><img src="https://camo.githubusercontent.com/4c698f4cef2ae6b69873aa7de91f6d10f28162e1/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69312f544231796b395f4b585858585862565846585845745848387058582d3930302d3334322e706e67" alt="Immutable"></p><p>JavaScript 中的对象一般都是可变的（mutable），虽然节省了内存，却给复杂的大型应用造成很多隐患。Immutable Data 为一旦创建，就不能再被修改的数据。通过 <strong>Persistent Data Structure</strong>（持久化数据结构）使得在使用旧数据创建新数据时，也保证了旧数据同时可用且不变。</p><p>前面所述的 deep clone 方法是把所有节点都复制一遍，性能损耗非常大。Immutable 使用了 <strong>Structural Sharing</strong>（结构共享），性能提升很多。</p><p>通过 immutable.js 实现 deep clone:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultConfig = Immutable.fromJS(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> config = defaultConfig.merge(initConfig); <span class="comment">// defaultConfig不会改变，返回新值给 config</span></span><br><span class="line"><span class="keyword">var</span> config = defaultConfig.mergeDeep(initConfig); <span class="comment">// 深层merge</span></span><br></pre></td></tr></table></figure><p>immutable.js 提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record。</p><p>虽然 immutable.js 通常与 facebook 同厂出品的 React 一起使用，但是它其实是一个完全独立的库，无论基于什么框架都可以使用。说它是希望之光并没有言过其实。更多内容可以查看 <a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="noopener">Immutable 详解及 React 中实践</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/review-copy-in-javascript.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 &lt;code&gt;JSON.parse(JSON.stringify(target))&lt;/code&gt; 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://blog.colafornia.me/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>2017 年度总结</title>
    <link href="https://blog.colafornia.me/post/2017/2017-review/"/>
    <id>https://blog.colafornia.me/post/2017/2017-review/</id>
    <published>2017-12-31T04:00:00.000Z</published>
    <updated>2019-02-13T07:05:14.274Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tokyo-in-2017.jpg" alt="tokyo in 2017"></p><p>2017: no silver bullet.</p><a id="more"></a><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>二月底入职了美团，到现在也快一年了。</p><p>借助于在下厨房时一行一行代码 review 出的好习惯以及一些技术选型上的经验红利，这大半年包括职级晋升也过得还是很顺利。在此非常感谢也怀念在下厨房的那些菜鸟日子。</p><p>美团的知识wiki 藏龙卧虎，有完善的新人培养以及 Mentor 机制，每天各个 BU 都有些质量很不错的技术分享，精力足够的话在新人期是有非常多的机会去学习观摩的。在终端组时还有被要求记录 work log，虽然一开始有些痛苦，最后还是养成了注重人效与时间管理的习惯。</p><p>除了以上，最大的感受还是在于，一直被培养“做事的方法”，要求注重软素质。在大厂当螺丝钉，基本不会遇到每天应付 PM 改需求，调整开发时间这类事。PM 包办了项目管理，与业务方的沟通等事情，作为 FE 只需要确定好自己的估时排期，关注后端提供的接口定义就可以。好处显而易见，坏处就是过于螺丝钉了，没什么机会去做自身领域外的事情。今后还是需要自己多努力扩展能力边界。</p><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><p>四月的时候去了趟日本，走了东京和伊东两座城市。在东京六本木的观景台拍了题图这张夜景。伊豆半岛的性价比很高，和牛比在东京吃的更好吃，因为没什么游客，看到了蛮多更市井的场景。感觉出来玩还是慢悠悠的会比较有意思。</p><p>生活中最重要的事是，年底把户口迁到了成都。买房和定居还不一定是什么时候，应该要等工作能力再提高一些，不那么菜之后再说。时隔三年又去了一次成都，除了好吃更感觉是真的安逸。</p><p>就在跨年这两天，我搬家到了望京这边，换了一个一居室，更适合猫猫住。离公司近一些，节省了通勤时间，想把节省的时间用在健身上。毕业一年半，体质是稳步地下降，精力不太够用，嗜糖这一坏习惯也没有多大好转。再这样下去应该是迟早 💊。</p><p>今年有在做基金定投，收益 10% 左右，只是年底由于订明年出行的机票酒店吃了波土，最后两个月没有继续投入了。这种强制储蓄的理财方式确实很实用，只是需要每月都在发薪日投出去，免得最后又花超了变月光。</p><h4 id="📚-和-🎬"><a href="#📚-和-🎬" class="headerlink" title="📚 和 🎬"></a>📚 和 🎬</h4><p>今年一共看了 13 本书，去年制定的看书计划基本完成了。</p><blockquote><ol><li>《学习JavaScript数据结构与算法》</li><li>《禅与摩托车维修艺术》</li><li>《程序员修炼之道 : 从小工到专家》</li><li>《Node.js实战》</li><li>《图解HTTP》</li><li>《Web全栈工程师的自我修养》</li><li>《牛津通识读本 : 数学》</li><li>《刻意练习》</li><li>《淘宝技术这十年》</li><li>《亲密关系》</li><li>《地球与太空》</li><li>《一首小夜曲》</li><li>《死神的精确度》</li></ol></blockquote><p>只是技术上没看什么大部头，还有几本已经看到最后几章但是计划被打乱迟迟没有看完。</p><p>电影看了 79 部，从豆瓣的报告来看还是院线片居多，可能也反映出了心态比较浮躁吧。</p><h4 id="新的计划"><a href="#新的计划" class="headerlink" title="新的计划"></a>新的计划</h4><p>这里只列举一些急切需要完成（三个月内）的事。在此推荐一个最近感觉很好用的 APP， <a href="https://www.v2ex.com/t/413134#reply11" target="_blank" rel="noopener">我的小目标</a>，是由一名 iOS 开发者独立开发的个人作品，其中集成了番茄钟与单核工作法，金币积攒与消耗这种类似于打怪升级的模式很适合我。</p><p>待办事项：<br>1.读完《JavaScript 设计模式与开发实践》<br>2.完成《Git 原理解析》的 blog &amp;&amp; 分享<br>3.移动端预渲染方案</p><p>习惯养成：<br>1.leetcode每周一题<br>2.每周健身一次（看看前五周降体脂的效果如何<br>3.每周在掘金翻译计划校对/推荐文章一次</p><h4 id="Less-is-more"><a href="#Less-is-more" class="headerlink" title="Less is more"></a>Less is more</h4><p>最后还是总结一下，生活和工作上都没有银弹，好好管理生活与代码的复杂度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/tokyo-in-2017.jpg&quot; alt=&quot;tokyo in 2017&quot;&gt;&lt;/p&gt;
&lt;p&gt;2017: no silver bullet.&lt;/p&gt;
    
    </summary>
    
      <category term="summary" scheme="https://blog.colafornia.me/categories/summary/"/>
    
    
  </entry>
  
  <entry>
    <title>《Pragmatic Programmer》</title>
    <link href="https://blog.colafornia.me/post/2017/reading-pragmatic-programmer/"/>
    <id>https://blog.colafornia.me/post/2017/reading-pragmatic-programmer/</id>
    <published>2017-09-15T15:32:00.000Z</published>
    <updated>2019-02-13T07:05:14.280Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&amp;fm=27&amp;gp=0.jpg" alt="cover"></p><p><a href="https://book.douban.com/subject/5387402/" target="_blank" rel="noopener">豆瓣地址</a><br>这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。<br>定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）<br><a id="more"></a></p><h3 id="一、工程意识"><a href="#一、工程意识" class="headerlink" title="一、工程意识"></a>一、工程意识</h3><p>① <code>Don&#39;t Live with Broken Windows: 不要容忍破窗户</code><br>这其实就是所说的“破窗理论”，破窗户（低劣的设计，糟糕的代码，临时凑合出的可以 work 的奇怪 hack function）具有传染性，只会导致项目中破窗户越来越多，一堆临时的 hack 修补引起连环问题，直到难以修复，程序崩溃。<br>熵增定律告诉我们，一个封闭系统总是趋向于熵增，也就是系统的无序程度只会不断增加。软件开发中也是如此，不要容忍破窗户，尽快修复任何已察觉到的问题。</p><p>② <code>DRY - Don&#39;t Repeat Yourself 不要重复你自己</code><br>   <code>Make It Easy to Reuse 让复用变得容易</code><br>   <code>There Are No Final Decisions 不存在最终决策</code><br>也是非常有名的 <code>DRY</code> 原则，与在《重构》与《设计模式》中学习到的类似，应使得我们的程序更<br>介绍了几种可能出现重复的场景，应使得程序具有正交性，不仅出于好维护的目的，也为了避免由于需求变更而扩展性不够导致需要重写。（从这里看来软件开发的常见问题这么多年都没啥变化）<br>要警惕自己出于懒惰而做的 Copy&amp;Paste，它不仅对项目没什么好处，也是一种“恶劣习惯”的开始。<br>维持代码正交性的方法（其实也是重构原则）：</p><ul><li>让你的代码保持解耦：<code>Law of Demeter</code></li><li>避免使用全局数据</li><li>避免编写相似的函数：可以通过策略模式实现</li></ul><p>③ <code>Estimate to Avoid Superises: 估算，以避免发生意外</code><br>   <code>Iterate the Schedule with the Code: 通过代码对进度表进行迭代</code><br>书中提到“使用的时间单位会对结果的解读造成影响”，并由此提到了相应的建议估算单位，这个还是很有意思的:<br><img src="https://file.sankuai.com/pan/im/1/image/AQhd2cqjdxpb_PAKXwAAElX88ApY@640w_1l?t=b&amp;w=640&amp;h=222" alt="estimate"></p><p>这只算一些估算经验，真正想进行准确有效的估算，还是要不断复盘检测，建立自己的系统模型，组织开发中所用的步骤，进行合理的模块划分来估算项目进度。</p><p>④ <code>Keep Knowledge in Plain Text: 用纯文本保存知识</code><br>   <code>Configure, Don&#39;t Integrate: 要配置，不要集成</code><br>   <code>Put Abstractions in Code, Details in Metdata: 将抽象放进代码，细节放进元数据</code><br>这里提到了使耦合减少至最少的一个方法，使用 <code>Metadata</code> 元数据，让我们的系统变得高度可配置。元数据是关于数据的数据，比如说数据库 <code>schema</code>，对字段进行描述。<br>通过以声明方式思考，由元数据驱动的应用将迫使我们解除设计耦合，推迟细节处理并大大提到了可复用性，能快速响应由需求变更导致的改动。</p><p>⑤ <code>Don&#39;t Program by Coincidence 不要靠巧合编程</code><br>这是一个很简单也显而易见的事，然而还是会经常出现“好不容易跑起来了，哪都不要动，先这样吧”。不仅如此，很多时候也是会不经意地忽略这件事，需要警惕，此时能实现很可能是由于正处于边界条件，只是偶然。<br>因此不仅要用 case 测试我们的代码，还要对测试 case 进行深思，通过一些覆盖不全、偶然情况的 case 并不意味着代码是 OK 的。</p><h3 id="二、开始实际的开发"><a href="#二、开始实际的开发" class="headerlink" title="二、开始实际的开发"></a>二、开始实际的开发</h3><p>① <code>Estimate the Order of Your Algorithms 算法速率</code><br>书中也简单介绍了 <code>大O表示法</code> 与一些常见算法的复杂度。在这里要牢记，要根据实际情况做出选择，过度追求算法上的优化而增加了测试维护的成本得不偿失。</p><p>② <code>Don&#39;t Gather Requirement - Dig for Them 不要搜集需求——挖掘它们</code><br><code>Abstractions Live Longer than Details 抽象比细节活得更长久</code><br>要对需求敏感，不假思索完全按照 PM 提过来的需求描述进行开发，可能会导致项目中的代码扩展性不好。举个例子，“只有人事部门可以查看档案”与“只有指定人员才能查看员工档案”这就是两个不一样的概念。完全按照前者来开发，很有可能只是将人事部门的组织id写入代码，而后者意味着我们可能需要做一个权限服务而与业务逻辑分离。</p><p>因此，应该 <strong>把政策的文档与需求的文档分开，使需求称为一般陈述，并把政策信息作为例子发给开发者，作为在具体视线中需要支持的一个 Case，最后政策可以称为应用中的元数据</strong>。</p><p>找出用户为何要做特定事情的<code>起因</code>，而不只是他们目前做这件事的<code>方式</code>。因为作为开发者是要解决用户的商业问题，而不只是满足用户陈述的需求，解决需求的方式是很有可能发生变化的，而深入挖掘到要解决的根本问题，才是可以使得系统高效，开发人员也不必为需求疲于奔命的解决方式。</p><p>在编写我们开发人员自己使用、查阅的需求文档时，应注重<code>保持抽象</code>，在涉及需求的地方，最简单的，能够准确地反映商业需要的陈述才是最好的，必须把<code>底层的语义不变项</code>当做需求进行捕捉。如上个例子，控制可以查看档案的权限，即是语义不变项。</p><p>③ <code>Listen to Nagging Doubts -Start When You&#39;re Ready 等你准备好再开始</code><br>这里讨论了“启动恐惧症”，这件事我也经常遇到，但是并没有反思在什么情况下会出现启动恐惧症，每次都是拖延许久最后在无限抵触和焦虑中把项目赶完了。</p><p>书中提出应该注意到自己的疑虑，在长时间的积累后，我们的直觉也会很有用处。除此之外，如果我们发现这种疑虑只是出于拖延的话，应该 <strong>选择一个你觉得会有困难的地方，开始进行某种“概念验证”</strong>，这样可以有效快速地使启动起来了，因为行动结果无非有两种，一种是我们发现，这个困难可以解决然后就可以消除疑虑正式投入开发，另一种我们发现这个地方确实有问题，然后通过求助外界或者更改需求来推进它，总之项目是有了一个不小的进展。</p><p>上述只是记了一些我在阅读中感触比较多的地方，实际上这本书虽然是一个蛮远久的“名著”，其中概念都很经典并不过时，书中每页都有启示。还是希望我在实习期就有机会看到这本书的，现在开始也并不晚，并且应该多回顾，随着开发经验的增多应该收获也会越来越多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/5387402/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;豆瓣地址&lt;/a&gt;&lt;br&gt;这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。&lt;br&gt;定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）&lt;br&gt;
    
    </summary>
    
      <category term="programmer reading" scheme="https://blog.colafornia.me/categories/programmer-reading/"/>
    
    
  </entry>
  
  <entry>
    <title>Make Shell/Git Better</title>
    <link href="https://blog.colafornia.me/post/2017/make-shell-and-git-better/"/>
    <id>https://blog.colafornia.me/post/2017/make-shell-and-git-better/</id>
    <published>2017-09-15T09:43:00.000Z</published>
    <updated>2019-02-13T07:05:14.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-起手式-oh-my-zsh"><a href="#1-起手式-oh-my-zsh" class="headerlink" title="1.起手式 oh-my-zsh"></a>1.起手式 oh-my-zsh</h2><p><img src="https://camo.githubusercontent.com/5c385f15f3eaedb72cfcfbbaf75355b700ac0757/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6f686d797a73682f6f682d6d792d7a73682d6c6f676f2e706e67" alt="oh-my-zsh"></p><p>zsh 被称作是最强大的 shell，而 oh-my-zsh 则是最流行的 zsh 配置文件，提供了丰富的主题以及大量插件，极大地扩展了 zsh 的功能。<br>可以无脑引入，便得到了最基本又好用的文件夹跳转，路径、命令、参数补全等便利操作。<br>推荐 plugin: git, <a href="https://github.com/wting/autojump/wiki" target="_blank" rel="noopener">autojump</a>, <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx" target="_blank" rel="noopener">osx</a></p><h2 id="2-优化你的-Git"><a href="#2-优化你的-Git" class="headerlink" title="2.优化你的 Git"></a>2.优化你的 Git</h2><p><strong>① 美化 diff</strong><br>Git 自己的 git diff 还是蛮不好用也不好看的，文件名和 diff 内容不太好定位。<br>基于 <a href="https://github.com/so-fancy/diff-so-fancy" target="_blank" rel="noopener">diff-so-fancy</a> 我们可以做一些美化工作。</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install diff-so-fancy -g</span><br></pre></td></tr></table></figure><p>然后在 <code>~/.gitconfig</code> 文件中编辑<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">  d = "!f() &#123; [ -z \"$GIT_PREFIX\" ] || cd \"$GIT_PREFIX\" &amp;&amp; git diff --color \"$@\" | diff-so-fancy  | less --tabs=4 -    RFX; &#125;; f"</span><br></pre></td></tr></table></figure></p><p>可以参考 <code>diff-so-fancy</code> 中的推荐颜色做配置，然后通过 <code>git d</code> 命令就可以看到优化过的 diff 信息了<br>（git diff VS git d）<br><img src="https://cloud.githubusercontent.com/assets/39191/13622719/7cc7c54c-e555-11e5-86c4-7045d91af041.png" alt="diff"></p><p><strong>② 美化 log</strong><br>git log 打出来的日志结构是完全扁平的，信息也不够全，依然是很难一眼找到自己想要的信息<br>依然是在 <code>~/.gitconfig</code> 中编辑：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">lg = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset)     %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all</span><br></pre></td></tr></table></figure></p><p>这样信息清晰好看了很多，也可以看到每个提交所在的分支及其分化衍合的情况<br>(git log VS git lg)</p><p><img src="http://o7ts2uaks.bkt.clouddn.com/6E897688-D526-4DC5-A373-05FB41734A91.png" alt="log"><br><img src="http://o7ts2uaks.bkt.clouddn.com/84B43431-AB74-446F-8442-3DFCD8E8E8BE.png" alt="lg"></p><p><strong>③ 命令加强 <a href="https://github.com/tj/git-extras" target="_blank" rel="noopener">git-extras</a></strong><br>TJ出品的 git 命令扩展集，应有尽有，要啥有啥，按需取用</p><h2 id="3-终端复用神器-Tmux"><a href="#3-终端复用神器-Tmux" class="headerlink" title="3.终端复用神器 Tmux"></a>3.终端复用神器 Tmux</h2><p>Tmux 是 Linux 中一种管理窗口的程序，用 Tmux 的主要原因是它提供了一个窗体组随时存储和恢复的功能。<br>现在我们经常在开发时给一个项目起很多 server，webpack server 占一个 tab，mock server 占一个 tab，开的时候开半天，哪个断了还要挨个找。<br>或者，在用 SSH 登录远程服务器进行调试时，开了N多窗口，过了一会儿发现 <code>Broken Pipe</code> 管子裂了，又得重来。<br>Tmux 可以帮助我们 split 窗口以及进行终端复用保证工作现场不丢失。<br><a href="http://cenalulu.github.io/linux/tmux/" target="_blank" rel="noopener">使用与安装方法</a></p><h2 id="4-给命令行使用的代理工具-proxychains-ng"><a href="#4-给命令行使用的代理工具-proxychains-ng" class="headerlink" title="4.给命令行使用的代理工具 proxychains-ng"></a>4.给命令行使用的代理工具 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">proxychains-ng</a></h2><p>用公司的 mnpm 镜像其实就基本不需要这个了。<br>自己搭服务器或者在家里办公有需求的话可以用。</p><h2 id="5-commit-message-规范工具-commitizen"><a href="#5-commit-message-规范工具-commitizen" class="headerlink" title="5. commit message 规范工具 commitizen"></a>5. commit message 规范工具 <a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a></h2><p>制定 Code Review 规范时看到了 <a href="https://eggjs.org/zh-cn/contributing.html" target="_blank" rel="noopener">Egg.js 的代码贡献规范</a><br>其中总结了一条好的，有意义的 commit message 应该包含：</p><blockquote><p>① type: 本次 commit 的类型(feat/fix/stype/perf….)<br>② scope: 改动范围<br>③ subject: 简要概述本次提交做了什么<br>④ body: 补充 subject, 可以不写<br>⑤ footer: 本次提交关联的 issue, task</p></blockquote><p>手动按这个写还挺累挺难的，因此决定在团队中推行使用 commitizen<br>简单好用，立竿见影<br><img src="https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png" alt="commitizen"></p><h2 id="6-好玩的-thefuck"><a href="#6-好玩的-thefuck" class="headerlink" title="6.好玩的 thefuck"></a>6.好玩的 <a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">thefuck</a></h2><p><img src="https://raw.githubusercontent.com/nvbn/thefuck/master/example.gif" alt="thefuck"></p><p>一个好玩的小工具，给开发添点乐趣。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-起手式-oh-my-zsh&quot;&gt;&lt;a href=&quot;#1-起手式-oh-my-zsh&quot; class=&quot;headerlink&quot; title=&quot;1.起手式 oh-my-zsh&quot;&gt;&lt;/a&gt;1.起手式 oh-my-zsh&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5c385f15f3eaedb72cfcfbbaf75355b700ac0757/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6f686d797a73682f6f682d6d792d7a73682d6c6f676f2e706e67&quot; alt=&quot;oh-my-zsh&quot;&gt;&lt;/p&gt;
&lt;p&gt;zsh 被称作是最强大的 shell，而 oh-my-zsh 则是最流行的 zsh 配置文件，提供了丰富的主题以及大量插件，极大地扩展了 zsh 的功能。&lt;br&gt;可以无脑引入，便得到了最基本又好用的文件夹跳转，路径、命令、参数补全等便利操作。&lt;br&gt;推荐 plugin: git, &lt;a href=&quot;https://github.com/wting/autojump/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;autojump&lt;/a&gt;, &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;osx&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-优化你的-Git&quot;&gt;&lt;a href=&quot;#2-优化你的-Git&quot; class=&quot;headerlink&quot; title=&quot;2.优化你的 Git&quot;&gt;&lt;/a&gt;2.优化你的 Git&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;① 美化 diff&lt;/strong&gt;&lt;br&gt;Git 自己的 git diff 还是蛮不好用也不好看的，文件名和 diff 内容不太好定位。&lt;br&gt;基于 &lt;a href=&quot;https://github.com/so-fancy/diff-so-fancy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;diff-so-fancy&lt;/a&gt; 我们可以做一些美化工作。&lt;/p&gt;
    
    </summary>
    
      <category term="shell git linux" scheme="https://blog.colafornia.me/categories/shell-git-linux/"/>
    
    
  </entry>
  
  <entry>
    <title>解决中文拼音输入法在input监听的问题</title>
    <link href="https://blog.colafornia.me/post/2017/fix-chinese-input-listener/"/>
    <id>https://blog.colafornia.me/post/2017/fix-chinese-input-listener/</id>
    <published>2017-08-22T12:16:00.000Z</published>
    <updated>2019-02-13T07:05:14.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h3><p><img src="/images/chinese-pinyin.gif" alt="cover"></p><p>在通过监听用户输入，将输入作为 Keyword 进行查询时（做了防抖）发现有如图问题，使用中文拼音输入法时，未选中所要的字词前，会自动将输入法分词过的拼音作为文本，由于实时监听输入，就存在将 ce’shi 作为 keyword 查询的问题了。<br>在这里，前端需要对拼音输入法的这种情况进行处理。<br><a id="more"></a></p><h3 id="二、TL-DR-解决方法"><a href="#二、TL-DR-解决方法" class="headerlink" title="二、TL;DR 解决方法"></a>二、TL;DR 解决方法</h3><p>可以借鉴 <code>Vue.js</code> 的处理方法，引入 <code>compositionstart</code> 和 <code>compositionend</code> 事件来捕获 <code>IME(input method editor)</code> 的启动和关闭。<br>这两个事件，目前是IE9+支持，移动端 Safari &lt; 10.2 &amp; UIWebView 暂时无法触发，因此可以作为 PC 端产品的靠谱方案。<br>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'._orgtree'</span>);</span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line">  <span class="keyword">var</span> fireLock = <span class="literal">false</span>;</span><br><span class="line">  node.addEventListener(<span class="string">'compositionstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fireLock = <span class="literal">true</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  node.addEventListener(<span class="string">'compositionend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fireLock = <span class="literal">false</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  node.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!fireLock) &#123;</span><br><span class="line">          searchOrgTree();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、怎么更放心地用"><a href="#三、怎么更放心地用" class="headerlink" title="三、怎么更放心地用"></a>三、怎么更放心地用</h3><p>这里还是看看 Vue.js 的代码：<a href="https://github.com/vuejs/vue/blob/c90b140e80f1bd5d01c733a5bd9fa6e9cb3c2b4d/src/platforms/web/runtime/directives/model.js" target="_blank" rel="noopener">src/platforms/web/runtime/directives/model.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只贴我们用到的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inserted (el, binding, vnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.tag === <span class="string">'textarea'</span> || isTextInputType(el.type)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!binding.modifiers.lazy) &#123;</span><br><span class="line">        <span class="comment">// Safari &lt; 10.2 &amp; UIWebView doesn't fire compositionend when</span></span><br><span class="line">        <span class="comment">// switching focus before confirming composition choice</span></span><br><span class="line">        <span class="comment">// this also fixes the issue where some browsers e.g. iOS Chrome</span></span><br><span class="line">        <span class="comment">// fires "change" instead of "input" on autocomplete.</span></span><br><span class="line">        el.addEventListener(<span class="string">'change'</span>, onCompositionEnd)</span><br><span class="line">        <span class="keyword">if</span> (!isAndroid) &#123;</span><br><span class="line">          el.addEventListener(<span class="string">'compositionstart'</span>, onCompositionStart)</span><br><span class="line">          el.addEventListener(<span class="string">'compositionend'</span>, onCompositionEnd)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCompositionStart</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.target.composing = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCompositionEnd</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// prevent triggering an input event for no reason</span></span><br><span class="line">  <span class="keyword">if</span> (!e.target.composing) <span class="keyword">return</span></span><br><span class="line">  e.target.composing = <span class="literal">false</span></span><br><span class="line">  trigger(e.target, <span class="string">'input'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span> (<span class="params">el, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>)</span><br><span class="line">  e.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">  el.dispatchEvent(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>For languages that require an IME (Chinese, Japanese, Korean etc.), you’ll notice that v-model doesn’t get updated during IME composition. If you want to cater for these updates as well, use input event instead.</p></blockquote><p>Vue.js 在编写 <code>v-model</code> 这一核心指令时用到了 <code>compositionstart</code> 和 <code>compositionend</code>  这两个事件，保证在输入框交互过程中的文本并不会触发 <code>v-model</code> 更新，在源码中也是针对 Safari 做了兼容处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题&quot;&gt;&lt;a href=&quot;#一、问题&quot; class=&quot;headerlink&quot; title=&quot;一、问题&quot;&gt;&lt;/a&gt;一、问题&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/chinese-pinyin.gif&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;在通过监听用户输入，将输入作为 Keyword 进行查询时（做了防抖）发现有如图问题，使用中文拼音输入法时，未选中所要的字词前，会自动将输入法分词过的拼音作为文本，由于实时监听输入，就存在将 ce’shi 作为 keyword 查询的问题了。&lt;br&gt;在这里，前端需要对拼音输入法的这种情况进行处理。&lt;br&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="https://blog.colafornia.me/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>You Don&#39;t Know setTimeout</title>
    <link href="https://blog.colafornia.me/post/2017/from-settimeout-to-event-loop/"/>
    <id>https://blog.colafornia.me/post/2017/from-settimeout-to-event-loop/</id>
    <published>2017-06-04T13:15:00.000Z</published>
    <updated>2019-02-13T07:05:14.278Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jstips-animation.gif" alt="cover"></p><h3 id="几个可能不知道的定时器⏲特性"><a href="#几个可能不知道的定时器⏲特性" class="headerlink" title="几个可能不知道的定时器⏲特性"></a>几个可能不知道的定时器⏲特性</h3><p>首先，<strong>setTimeout()/setInterval()</strong> 方法不是 ECMAScript 规范定义的内容，而是属于 BOM 提供的功能，也就是说定时器作为 BOM 对象和方法的一部分才能在浏览器中使用。</p><p>需要注意的是 <strong>setTimeout() 与 setInterval() 在触发周期的定义上完全不一样</strong>，在下面例子 setTimeout() 代码中，要在前一个 callback 回调执行结束并延迟 10ms 以后才能再次执行 setTimeout()，即延迟是要求运行时(runtime) 处理请求所需的最小时间，但不是有所保证的时间。而 setInterval() 则是每隔 10ms 就执行一次 callback 回调，不会关注 callback 何时执行结束。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于触发周期定义不同，以下两个定时器有非常大的区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 timeout 定时器，每10毫秒重新调用自己</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">repeatMe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  setTimeout(repeatMe, <span class="number">10</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 interval 定时器，每10毫秒触发一次</span></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>除此之外，在 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers" target="_blank" rel="noopener">HTML spec</a> 中定义 <strong>setTimeout 的最小延迟时间是4ms</strong>，但通常认为浏览器可实现的定时器的最小延迟时间是10ms，即 setTimeout(fn, 0) 也是会延迟至少10ms，如果想实现 0 delay 的话可以通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">window.postMessage</a> 实现。</p><p>定时器还有一个小特性，在开发移动公告的滚动动画时发现，从动画所在的 tab 页切换到别的 tab 之后再切回，动画会完全乱掉，并不会按代码中所设置的延迟时间进行。这是为了减少背景 tab 页面的代码运行消耗（电量），<strong>背景 tab 页面中定时器的间隔会增加到1000ms</strong>，如果遇到需要解决这个问题的场景，可以通过 <a href="https://robertnyman.com/2010/03/25/using-html5-web-workers-to-have-background-computational-power/" target="_blank" rel="noopener">HTML5 Web Workers</a> 或者用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a> 代替定时器来解决。</p><p>最后，由于 webkit 中 timer 类的实现原理决定：<strong>预期延时时间最小的任务最先被执行，同时，预期延时时间相同的两个任务，其执行顺序是按照注册的先后顺序执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn1'</span>);</span><br><span class="line">&#125;, <span class="number">20</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2'</span>);</span><br><span class="line">&#125;, <span class="number">30</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'another fn2'</span>);</span><br><span class="line">&#125;, <span class="number">30</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn3'</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start while'</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span> - start &lt; <span class="number">1000</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end while'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line"><span class="comment">// start while</span></span><br><span class="line"><span class="comment">// end while</span></span><br><span class="line"><span class="comment">// fn3</span></span><br><span class="line"><span class="comment">// fn1</span></span><br><span class="line"><span class="comment">// fn2</span></span><br><span class="line"><span class="comment">// another fn2</span></span><br></pre></td></tr></table></figure><h3 id="Event-Loop-相关概念"><a href="#Event-Loop-相关概念" class="headerlink" title="Event Loop 相关概念"></a>Event Loop 相关概念</h3><p>浏览器让一个单线程共用于解释和执行 JavaScript，我们可以将它称为是“主线程”。其它的处理AJAX请求的线程、处理DOM事件的线程、定时器线程等等可以称为是“工作线程”。</p><p>JavaScript 的单线程意味着只有一个 call stack，也意味着同一时间是能做一件事。</p><p><img src="http://o7ts2uaks.bkt.clouddn.com/v2-25076e938167ad11c6a2a9ec099e0973_b.png" alt="Event Loop"></p><ul><li><p>调用栈(call stack): 后进先出，函数被调用时会被加入到调用栈顶部，等执行结束再从顶部移除。</p></li><li><p>堆(heap): 内存分配区</p></li><li><p>消息队列(quene): 也叫任务队列。先进先出，一旦调用栈中的所有任务执行完毕，栈清空，就会读取消息队列。<strong>消息/任务就是注册异步任务时添加的回调函数</strong>。</p></li><li><p>同步任务: 在主线程的调用栈排队执行的任务。</p></li><li><p>异步任务: 主线程发起执行异步函数的请求，对应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到消息队列，主线程通过事件循环过程去取消息，然后执行回调。</p></li><li><p>事件循环(event loop): 事件循环是指主线程重复从消息队列中取消息、执行的过程。<strong><br>取一个消息并执行的过程叫做一次循环</strong>。</p></li><li><p>Web APIs: 如 AJAX，定时器，DOM事件这些异步事务并不在 V8(JavaScript)运行环境中，是由浏览器提供的 Web API</p></li></ul><p>相关概念就是这些，<a href="http://latentflip.com/loupe/" target="_blank" rel="noopener">http://latentflip.com/loupe/</a> 是一个可视化调用栈的网站，可以把自己的代码敲到里面运行来看 event loop 的具体动态。</p><h3 id="定时器和线程是如何工作的"><a href="#定时器和线程是如何工作的" class="headerlink" title="定时器和线程是如何工作的"></a>定时器和线程是如何工作的</h3><p><img src="https://johnresig.com/files/Timers.png" alt="timer"></p><p>以此图为例，来理解 JavaScript 中异步事件的执行。</p><blockquote><p>0ms: 启动即执行第一段 JavaScript 代码块，启动一个10ms延迟定时器(timeout)和10ms间隔定时器(interval)，延迟定时器是先于间隔定时器声明启动的。</p></blockquote><blockquote><p>5ms: 鼠标单击，但是由于现在正在执行第一个代码块，调用栈不为空，单击事件的处理函数不能立即执行，只能在消息队列中进行排队</p></blockquote><blockquote><p>10ms: 延迟定时器触发，间隔定时器触发，同理也都进行排队</p></blockquote><blockquote><p>18ms: 第一段代码块执行结束，调用栈为空，此时有三个代码块在排队执行(click 事件处理函数，延迟定时器处理函数，间隔定时器第一次触发的处理函数)，按顺序此时主线程中执行 click 事件回调。消息队列中此时还有两个回调。</p></blockquote><blockquote><p>20ms: 间隔定时器又触发了，由于间隔定时器第一次触发的处理函数仍在排队，浏览器不会对同一 interval 处理函数的多个实例同时进行排队，于是此次调用作废，消息队列不变，仍然还是那两个回调。</p></blockquote><blockquote><p>28ms: click 事件回调函数执行完毕，按顺序，此时主线程中将执行延时定时器处理函数。消息队列中只有间隔定时器的第一次触发回调在排队。</p></blockquote><blockquote><p>30ms: 间隔定时器再一次触发了，仍然因为第一次触发的回调仍在排队，此次调用作废。</p></blockquote><blockquote><p>34ms: 延时定时器回调函数执行完毕。开始执行间隔定时器第一次触发的回调函数。此时消息队列为空。</p></blockquote><blockquote><p>40ms: 间隔定时器再一次触发了，导致新的 interval 回调函数进入消息队列中排队。</p></blockquote><blockquote><p>42ms: 间隔定时器第一次回调函数执行完毕，正在排队的回调开始执行。消息队列再次为空。</p></blockquote><blockquote><p>47ms: 回调执行完毕，此时还没有到触发 interval 的时间，因此下一个 interval 回调可以等到触发事件立即执行。</p></blockquote><p>由此，我们可以知道：</p><ul><li>如果无法立即执行定时器，该定时器会被推迟到下一个可用的执行时间点上(验证了实际延迟时间必然会比指定的延迟时间更长)</li><li>同一个 interval 执行程序的多个实例不能同时进行排队</li><li>延迟时间足够长的话，很有可能会有两个 interval 回调会无延迟连续执行</li></ul><h3 id="setTimeout-fn-0"><a href="#setTimeout-fn-0" class="headerlink" title="setTimeout(fn, 0)"></a>setTimeout(fn, 0)</h3><p>由上述内容可知，setTimeout(fn, 0) 中的代码并不是为了 fn 立即执行，而是将 fn 插入到消息队列，使得待调用栈为空时将立即调用执行 fn，保证了 fn 的后执行。因此我们可以通过这一特性，<strong>用 setTimeout(fn, 0) 调整事件的发生顺序</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input[type=button]'</span>)[<span class="number">0</span>];</span><br><span class="line">input.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    input.value +=<span class="string">' input'</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  input.value += <span class="string">' body'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 模拟事件捕获，实现父元素的事件回调函数先发生</span></span><br></pre></td></tr></table></figure><p>在《高性能JavaScript》中认为 <strong>单个 JavaScript 操作花费的总时间不应该超过100毫秒</strong>。否则用户会感到与界面失去联系。实际上，如果一段 js 代码的运行时间超过 500ms，Firefox 和 Opera 浏览器将弹出警告对话框，Safari 会默认终止运行时间超过500 ms 的脚本。因此我们需要定时器将计算量大耗时长的任务分割成不会让浏览器挂掉的碎片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 会造成浏览器阻塞</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0xA00000</span>;i&lt;<span class="number">0xFFFFFF</span>;i++) &#123;</span><br><span class="line">  div.style.backgroundColor = <span class="string">'#'</span>+i.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分割成小的任务</span></span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0x100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  timer = setTimeout(func, <span class="number">0</span>);</span><br><span class="line">  div.style.backgroundColor = <span class="string">'#'</span>+i.toString(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (i++ == <span class="number">0xFFFFFF</span>) clearInterval(timer);</span><br><span class="line">&#125;</span><br><span class="line">timer = setTimeout(func, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="定时器的其它应用"><a href="#定时器的其它应用" class="headerlink" title="定时器的其它应用"></a>定时器的其它应用</h3><p>这里就是说函数节流(throttle)与函数防抖(debounce)</p><p>以 Underscore.js 中 debounce 的实现为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125; func        传入函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125;  immediate   设置为ture时，调用触发于开始边界而不是结束边界</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 last 为当前时间与上次触发的时间间隔</span></span><br><span class="line">    <span class="keyword">var</span> last = _.now() - timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔小于所传入的 wait</span></span><br><span class="line">      <span class="comment">// 还没到触发时间，继续设置定时器</span></span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 到了触发时间，清空计时器，避免影响下次触发</span></span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用</span></span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        <span class="comment">// 执行 func</span></span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 每次触发之后 更新时间戳为此次触发时间</span></span><br><span class="line">    timestamp = _.now();</span><br><span class="line">    <span class="comment">// 判断是否符合立即触发的条件</span></span><br><span class="line">    <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="comment">// 如果延时不存在，重新设定延时</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      <span class="comment">// 立即触发</span></span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>管理多个定时器会产生许多问题，同时创建大量的定时器将会在浏览器中增加垃圾回收任务发生的可能性</strong>。</p><p>定时器是一个特殊的垃圾回收问题，这是由于它们是在 JavaScript 主线程之外的浏览器线程进行管理的。不同浏览器垃圾回收的周期不同，这也是通过定时器处理动画时，动画在有的浏览器上很流畅，有的浏览器上特别卡的原因之一。因此应该注意减少同时使用的定时器的数量或者使用中央定时器来管理多个回调。</p><h3 id="几个后续值得探究的问题"><a href="#几个后续值得探究的问题" class="headerlink" title="几个后续值得探究的问题"></a>几个后续值得探究的问题</h3><ul><li>HTML5 Web Workers: HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中</li><li>requestAnimationFrame: 更适合动画使用的“定时循环器”</li><li>setImmediate: 一个比较新的定时器，setTimeout(0)的替代版</li><li>Node.js 中的 Event Loop</li></ul><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ul><li><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=669s" target="_blank" rel="noopener">Philip Roberts: What the heck is the event loop anyway</a></p></li><li><p><a href="https://johnresig.com/blog/how-javascript-timers-work/" target="_blank" rel="noopener">John Resig: How JavaScript Timers Work</a></p></li><li><p><a href="http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/" target="_blank" rel="noopener">AlloyTeam: 从 setTimeout 说起事件循环</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop" target="_blank" rel="noopener">阮一峰: JavaScript 运行机制详解——再谈Event Loop</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jstips-animation.gif&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;几个可能不知道的定时器⏲特性&quot;&gt;&lt;a href=&quot;#几个可能不知道的定时器⏲特性&quot; class=&quot;headerlink&quot; title=&quot;几个可能不知道的定时器⏲特性&quot;&gt;&lt;/a&gt;几个可能不知道的定时器⏲特性&lt;/h3&gt;&lt;p&gt;首先，&lt;strong&gt;setTimeout()/setInterval()&lt;/strong&gt; 方法不是 ECMAScript 规范定义的内容，而是属于 BOM 提供的功能，也就是说定时器作为 BOM 对象和方法的一部分才能在浏览器中使用。&lt;/p&gt;
&lt;p&gt;需要注意的是 &lt;strong&gt;setTimeout() 与 setInterval() 在触发周期的定义上完全不一样&lt;/strong&gt;，在下面例子 setTimeout() 代码中，要在前一个 callback 回调执行结束并延迟 10ms 以后才能再次执行 setTimeout()，即延迟是要求运行时(runtime) 处理请求所需的最小时间，但不是有所保证的时间。而 setInterval() 则是每隔 10ms 就执行一次 callback 回调，不会关注 callback 何时执行结束。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="https://blog.colafornia.me/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式以及在 Vue 源码中的实践</title>
    <link href="https://blog.colafornia.me/post/2017/observer-pattern-in-vue/"/>
    <id>https://blog.colafornia.me/post/2017/observer-pattern-in-vue/</id>
    <published>2017-03-14T10:30:00.000Z</published>
    <updated>2019-02-13T07:05:14.280Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-reactive.jpg" alt="vue"></p><p>在 ES6 把 Promise 写进语言标准前，为实现异步编程，经常会采用 <strong>观察者模式（发布-订阅模式）</strong> 作为替代传递回调函数的方案。</p><p>它定义了一种一对多的关系，让多个观察者订阅同一主题对象，当主题状态发生改变则立即发布，通知所有的订阅者。发布者和订阅者之间完全解耦，仅仅是共享同一自定义事件的名称。当新的订阅者出现，发布者无需做任何修改，反之亦然。</p><a id="more"></a><h2 id="常见的需要观察者模式的场景："><a href="#常见的需要观察者模式的场景：" class="headerlink" title="常见的需要观察者模式的场景："></a>常见的需要观察者模式的场景：</h2><p>在任意一个需要登录的网站中，header，navbar，消息列表，购物车等模块的渲染，都需要登陆后拿到用户信息。但是ajax登录请求完成的时间无法确定，如果在ajax回调中调用各模块的方法来更新用户信息的话，耦合性太强，新增/修改模块的成本太高，业务模块更复杂的时候很难维护。这个时候需要的就是观察者模式。</p><p>Vue 在实现数据绑定时也采用的观察者模式来实现数据的订阅，订阅者维护每一次更新之前的数据，当数据发生变化，订阅者将执行自身设定的回调逻辑，并更新所维护数据的值。</p><h2 id="实现观察者模式："><a href="#实现观察者模式：" class="headerlink" title="实现观察者模式："></a>实现观察者模式：</h2><blockquote><ol><li>指定发布者</li><li>给发布者添加一个缓存列表，用于存放回调函数以通知订阅者</li><li>发布消息时，遍历缓存列表，触发每一个订阅者回调函数</li></ol></blockquote><p>并且除了缓存列表之外，还需要订阅，发布，取消订阅这三个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">  <span class="comment">// 缓存列表</span></span><br><span class="line">  clientList: [],</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  listen: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.clientList[key]) &#123;</span><br><span class="line">      <span class="comment">// 订阅列表中没有这个 key 则把初始化这个 key 的队列为空</span></span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  trigger: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="keyword">this</span>.clientList[key]</span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 遍历缓存列表，挨个触发回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ];)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  remove: <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="keyword">this</span>.clientList[key]</span><br><span class="line">    <span class="keyword">if</span> (!fns)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fn)&#123;</span><br><span class="line">      fns &amp;&amp; (fns.length = <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> l = fns.length - <span class="number">1</span>; l &gt;=<span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="keyword">var</span> _fn = fns[l]</span><br><span class="line">        <span class="keyword">if</span> (_fn === fn)&#123;</span><br><span class="line">          fns.splice(l, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是观察者模式的一个通用实现。</p><p>在实际场景中，有可能需要多个发布者对象，需要多个类似上面 event 对象的绑定，非常麻烦，发布订阅也并没有完全解耦，需要知道这个对象的名字。因此也可以采用 <strong>全局的 Event 对象</strong> 来实现。<br>同时，也有可能为了避免命名冲突，需要 <strong>创建命名空间</strong> ，或者是由于为了实现可以先发布再订阅，<strong>创建离线堆栈</strong> 等等，可定制高级版的观察者模式。</p><h2 id="采用观察者模式需要注意的问题："><a href="#采用观察者模式需要注意的问题：" class="headerlink" title="采用观察者模式需要注意的问题："></a>采用观察者模式需要注意的问题：</h2><ul><li>实现观察者模式本身需要耗费内存，如果发布并不常发生，而订阅却始终存在于内存中，造成了一定程度的浪费</li><li>由于模块之间的联系由具体的耦合转为抽象，因此过多使用观察者模式的话，模块关系很难追溯，代码也很难维护</li></ul><h2 id="Vue源码中的使用："><a href="#Vue源码中的使用：" class="headerlink" title="Vue源码中的使用："></a>Vue源码中的使用：</h2><p>Vue 实现数据绑定依靠的是 <strong>Object.defineProperty() 的自定义getter/setter</strong> 来进行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理，通知订阅者</span></span><br><span class="line"><span class="comment">// 定义缓存列表，为外部提供 添加订阅/通知订阅者 的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 缓存列表</span></span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        <span class="comment">// 添加订阅，即向缓存列表中添加新项</span></span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        <span class="comment">// 通知所有的订阅者(Watcher)，触发订阅者的相应回调</span></span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub.update())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入订阅管理模块</span></span><br><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'Dep'</span></span><br><span class="line"><span class="comment">// 定义订阅</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接受三个参数，实例，所订阅数据，指定的回调</span></span><br><span class="line">    <span class="keyword">constructor</span>(vm, expOrFn, cb)&#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm <span class="comment">// 取到 Vue 实例，从而拿到实例上的 data</span></span><br><span class="line">        <span class="keyword">this</span>.cb = cb <span class="comment">// 数据更新时触发的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.expOrFn = expOrFn <span class="comment">// 被订阅的数据</span></span><br><span class="line">        <span class="keyword">this</span>.val = <span class="keyword">this</span>.get() <span class="comment">// 赋值为定义订阅时的数据，即更新前的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露的接口，数据更新时发布者将调用这个接口</span></span><br><span class="line">    update()&#123;</span><br><span class="line">        <span class="keyword">this</span>.run()</span><br><span class="line">    &#125;</span><br><span class="line">    run()&#123;</span><br><span class="line">        <span class="comment">// 订阅数据发生变化时，更新 val ，触发回调</span></span><br><span class="line">        <span class="comment">// val 为当前值， this.val 为更新前的值</span></span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">this</span>.get()</span><br><span class="line">        <span class="keyword">if</span>(val !== <span class="keyword">this</span>.val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="comment">// 读取所订阅数据的最新值</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">this</span>.vm._data[<span class="keyword">this</span>.expOrFn]</span><br><span class="line">        <span class="comment">// 指针置空</span></span><br><span class="line">        Dep.target = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Observer 数据监听器</span></span><br><span class="line"><span class="comment">// 引入 Dep 订阅管理模块</span></span><br><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'Dep'</span></span><br><span class="line"><span class="comment">// 定义 Observer 类，将所监听数据遍历每一项传入到 defineReactive 以加入 get/set 方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">    walk(value)&#123;</span><br><span class="line">        <span class="comment">// 遍历所监听对象、数组的每一项</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.convert(key, value[key]))</span><br><span class="line">    &#125;</span><br><span class="line">    convert(key, val)&#123;</span><br><span class="line">        defineReactive(<span class="keyword">this</span>.value, key, val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建新的订阅</span></span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 给当前属性的值添加监听</span></span><br><span class="line">    <span class="keyword">var</span> chlidOb = observe(val)</span><br><span class="line">    <span class="comment">// 加上 get/set</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="comment">// 设置为属性可遍历</span></span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 属性可删除，可修改其 emumerable/writable 等属性</span></span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: ()=&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">            <span class="comment">// Dep.target 为 watcher 实例</span></span><br><span class="line">            <span class="comment">// 如果存在这个 watcher 则将其加入到 sub 队列</span></span><br><span class="line">            <span class="comment">// Watcher实例在实例化过程中，会触发当前get方法</span></span><br><span class="line">            <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">                dep.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: (newVal) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果数据被修改则会触发这段 set 函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'new value seted'</span>)</span><br><span class="line">            <span class="keyword">if</span>(val === newVal) <span class="keyword">return</span></span><br><span class="line">            val = newVal</span><br><span class="line">            <span class="comment">// 监听新值</span></span><br><span class="line">            chlidOb = observe(newVal)</span><br><span class="line">            <span class="comment">// 通知所有订阅者，数值被改变了</span></span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建监听，在调用Observer类的外面加了层判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当值不存在，或者不是对象，就不监听了</span></span><br><span class="line">    <span class="keyword">if</span>(!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observer(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有些文章中，观察者模式与发布/订阅模式还有些差别，可以观摩这篇 <a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript" target="_blank" rel="noopener">ObserverPattern</a>去学习一下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/vue-reactive.jpg&quot; alt=&quot;vue&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 ES6 把 Promise 写进语言标准前，为实现异步编程，经常会采用 &lt;strong&gt;观察者模式（发布-订阅模式）&lt;/strong&gt; 作为替代传递回调函数的方案。&lt;/p&gt;
&lt;p&gt;它定义了一种一对多的关系，让多个观察者订阅同一主题对象，当主题状态发生改变则立即发布，通知所有的订阅者。发布者和订阅者之间完全解耦，仅仅是共享同一自定义事件的名称。当新的订阅者出现，发布者无需做任何修改，反之亦然。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end javascript pattern" scheme="https://blog.colafornia.me/categories/front-end-javascript-pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>由匿名函数展开的一系列知识点</title>
    <link href="https://blog.colafornia.me/post/2016/basic-review-from-anonymous-function-to-iife/"/>
    <id>https://blog.colafornia.me/post/2016/basic-review-from-anonymous-function-to-iife/</id>
    <published>2016-11-23T14:00:00.000Z</published>
    <updated>2019-02-13T07:05:14.275Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/iife.png" alt="cover"></p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近在进行 <a href="https://github.com/Colafornia/underscore-analysis" target="_blank" rel="noopener">underscore.js 源码分析</a>，也顺便看了些别的库的大致封装方式<br>underscore:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</span><br><span class="line">    <span class="keyword">this</span>._wrapped = obj;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// blabla</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><a id="more"></a><p>早期的 jQuery:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello'</span>);&#125;);</span><br><span class="line"><span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd &amp;&amp; define.amd.jQuery ) &#123;</span><br><span class="line">    define( <span class="string">"jquery"</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> jQuery; &#125; );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// blabla</span></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure><p>这个封装和调用方式一看就是匿名函数嘛，可是匿名函数，然后呢？<br>于是趁着下午比较闲翻开高程从匿名函数这个地方开始看，发现了一系列的知识点……<br>大概脉络是: 函数定义方式 → 匿名函数的创建 → 匿名函数自执行还是IIFE？ → IIFE 的应用</p><h3 id="函数定义方式"><a href="#函数定义方式" class="headerlink" title="函数定义方式"></a>函数定义方式</h3><ol><li><p>函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo () &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>函数声明提升</strong> ：可以把函数声明放在调用它的语句后面</p></li><li><p>函数表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = function () &#123;&#125;</span><br></pre></td></tr></table></figure><p>也属于匿名函数</p></li><li><p>使用Function构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = new Function ()</span><br></pre></td></tr></table></figure></li></ol><h3 id="匿名函数的创建"><a href="#匿名函数的创建" class="headerlink" title="匿名函数的创建"></a>匿名函数的创建</h3><ol><li><p>上述 使用函数表达式创建</p></li><li><p><code>(function (x, y) {alert(x + y)})(2, 3)</code><br>在第一个括号内创建匿名函数，第二个括号用于调用该匿名函数，并传入参数</p><ul><li><code>function (x,y) {alert(x + y)}</code>部分为所声明的函数</li><li>然后用括号把函数声明包起来 <code>(function (x,y) {alert(x + y)})</code></li><li>最后调用此函数 <code>(function (x, y) {alert(x + y)})(2, 3)</code></li></ul></li></ol><blockquote><p>在这里我们也可以看到，创建匿名函数的方式有两种，第二种方式才会声明后立即执行，即不是所有的匿名函数都是可以立即执行的</p></blockquote><h3 id="“匿名函数自执行”-vs-IIFE"><a href="#“匿名函数自执行”-vs-IIFE" class="headerlink" title="“匿名函数自执行” vs  IIFE"></a>“匿名函数自执行” vs  IIFE</h3><p>自执行，有的地方会写为自调用，是一个经常会听到的的概念，我们再深究一下它吧。所谓的“匿名函数自执行”指的是 <code>Self-executing anonymous function</code> ，经常与 <code>IIFE</code> 混淆， <code>Immediately-Invoked Function Expression</code> 即 <strong>立即调用的函数表达式</strong> ，含义上的辨析 <a href="https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">先戳一下中文wiki</a> 吧。</p><p>IIFE 的具体的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 第一个例子</span><br><span class="line">(function (x) &#123; return x + 1;&#125;(2)) // =&gt; 3</span><br><span class="line">// 第二个例子</span><br><span class="line">var result = function (x) &#123; return x + 1; &#125;(2); // =&gt; result 的值为3</span><br></pre></td></tr></table></figure><p>把第一个例子敲到控制台中，我们可以看到这个 <code>()</code> 中的代码立即执行了，返回3。对于第二个例子，它实际上执行的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo = function (x) &#123;return x + 1;&#125;</span><br><span class="line">var result = foo(2)</span><br></pre></td></tr></table></figure><p>这里有一个知识点： <strong>对于函数类对象，不论是一个现场定义的匿名函数，还是一个之前定义的有名字的函数，它们在不加括号的时候都代表了这个函数对象本身，而加了括号就代表调用这个函数，也就是这个函数 return 的对象。</strong></p><p>再回到匿名函数自执行与 IIFE 的辨析上，匿名函数自执行(Self-executing anonymous function)是一个不够准确的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 它是一个自执行的匿名函数，它必须用 arguments.callee() 来递归地调用自己</span><br><span class="line">var foo = function() &#123; arguments.callee(); &#125;;</span><br><span class="line">// 它是一个立即执行的匿名函数，只是立即执行了一段 code ，并不是调用自己</span><br><span class="line">(function () &#123; /* code */ &#125; ());</span><br></pre></td></tr></table></figure><p>因此 <code>自执行</code> 意味着调用自己， <code>立即调用，立即执行</code> 强调的是定义函数的时候就直接执行了函数，与函数体内是否调用自身无关。只能说这是两个看起来有些类似的概念，但实际上所强调的内容完全不一样。IIFE 也可以调用自己，匿名函数可以立即执行。</p><h3 id="IIFE-的应用"><a href="#IIFE-的应用" class="headerlink" title="IIFE 的应用"></a>IIFE 的应用</h3><p>立即调用的函数表达式的根本作用是 <strong>创建一个独立的作用域</strong>。</p><ol><li><p>模拟块级作用域，在ES6之前 JavaScript 是没有块级作用域的。<br>在实际应用场景中，项目引用了很多不同的库 ，库与库之间是如何保证变量不被覆盖呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libA.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// blabla</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// libB.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// blabla</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样的话，就如同我们在前面看到的 jquery underscore 那样，使自身作用域独立，不会互相覆盖。</p></li><li><p>解决闭包的坑： <strong>闭包只能取得包含函数中任何变量的最后一个值</strong><br>这次改造一下《高程三》中提到的例子作为参照吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(foo)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = test()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>,len = res.length; i &lt; len; i++)&#123;</span><br><span class="line">  res[i]()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台中打出来的是10个10，而不是1，2，3...</span></span><br><span class="line"><span class="comment">// i 是贯穿整个作用域的，而不是给每个 foo 分配了一个 i</span></span><br><span class="line"><span class="comment">// test()执行完毕后才调用 console.log() 一定是发生在for循环已循环结束后，此时i值为10</span></span><br></pre></td></tr></table></figure><p>在线例子可以戳 <a href="https://jsfiddle.net/46x5s72a/" target="_blank" rel="noopener">JSFiddle</a><br>这个坑该怎么处理呢？引入IIFE！下面代码是可用的，把 i 的值作为索引锁住了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决思路是给每个foo函数创建一个独立的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 添加一个IIFE</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(index);&#125;;</span><br><span class="line">      result.push(foo)</span><br><span class="line">   &#125;)(i);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> res = test()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>,len = res.length; i &lt; len; i++)&#123;</span><br><span class="line">    res[i]()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ul><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">汤姆大叔的博客:深入理解JavaScript系列（4）: 立即调用的函数表达式</a></li><li><a href="http://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript" target="_blank" rel="noopener">stackoverflow: What is the purpose of a self executing function in javascript</a></li><li><a href="http://weizhifeng.net/immediately-invoked-function-expression.html" target="_blank" rel="noopener">weizhifeng.net: JavaScript中的立即执行函数表达式</a></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/iife.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;最近在进行 &lt;a href=&quot;https://github.com/Colafornia/underscore-analysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;underscore.js 源码分析&lt;/a&gt;，也顺便看了些别的库的大致封装方式&lt;br&gt;underscore:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// blabla&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="https://blog.colafornia.me/categories/front-end-javascript/"/>
    
    
  </entry>
  
</feed>
