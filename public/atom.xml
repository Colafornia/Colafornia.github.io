<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Minibase</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mechanicianw.github.io/"/>
  <updated>2016-12-18T08:48:42.000Z</updated>
  <id>http://mechanicianw.github.io/</id>
  
  <author>
    <name>Mechanician</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>由匿名函数展开的一系列知识点</title>
    <link href="http://mechanicianw.github.io/2016/11/23/basic-review-from-anonymous-function-to-iife/"/>
    <id>http://mechanicianw.github.io/2016/11/23/basic-review-from-anonymous-function-to-iife/</id>
    <published>2016-11-23T14:00:00.000Z</published>
    <updated>2016-12-18T08:48:42.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/iife.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;最近在进行 &lt;a href=&quot;https://github.com/MechanicianW/underscore-analysis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;underscore.js 源码分析&lt;/a&gt;，也顺便看了些别的库的大致封装方式&lt;br&gt;underscore:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped = obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// blabla&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;早期的 jQuery:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; window, undefined &lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; jQuery = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;);&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.jQuery = &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.$ = jQuery;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; define === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; &amp;amp;&amp;amp; define.amd &amp;amp;&amp;amp; define.amd.jQuery ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    define( &lt;span class=&quot;string&quot;&gt;&quot;jquery&quot;&lt;/span&gt;, [], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; jQuery; &amp;#125; );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// blabla&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)( &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt; );&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个封装和调用方式一看就是匿名函数嘛，可是匿名函数，然后呢？&lt;br&gt;于是趁着下午比较闲翻开高程从匿名函数这个地方开始看，发现了一系列的知识点……&lt;br&gt;大概脉络是: 函数定义方式 → 匿名函数的创建 → 匿名函数自执行还是IIFE？ → IIFE 的应用&lt;/p&gt;
&lt;h3 id=&quot;函数定义方式&quot;&gt;&lt;a href=&quot;#函数定义方式&quot; class=&quot;headerlink&quot; title=&quot;函数定义方式&quot;&gt;&lt;/a&gt;函数定义方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;函数声明     &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function foo () &amp;#123;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数声明提升&lt;/strong&gt; ：可以把函数声明放在调用它的语句后面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数表达式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var foo = function () &amp;#123;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也属于匿名函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Function构造函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var foo = new Function ()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;匿名函数的创建&quot;&gt;&lt;a href=&quot;#匿名函数的创建&quot; class=&quot;headerlink&quot; title=&quot;匿名函数的创建&quot;&gt;&lt;/a&gt;匿名函数的创建&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;上述 使用函数表达式创建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(function (x, y) {alert(x + y)})(2, 3)&lt;/code&gt;&lt;br&gt;在第一个括号内创建匿名函数，第二个括号用于调用该匿名函数，并传入参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function (x,y) {alert(x + y)}&lt;/code&gt;部分为所声明的函数&lt;/li&gt;
&lt;li&gt;然后用括号把函数声明包起来 &lt;code&gt;(function (x,y) {alert(x + y)})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后调用此函数 &lt;code&gt;(function (x, y) {alert(x + y)})(2, 3)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;在这里我们也可以看到，创建匿名函数的方式有两种，第二种方式才会声明后立即执行，即不是所有的匿名函数都是可以立即执行的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;“匿名函数自执行”-vs-IIFE&quot;&gt;&lt;a href=&quot;#“匿名函数自执行”-vs-IIFE&quot; class=&quot;headerlink&quot; title=&quot;“匿名函数自执行” vs  IIFE&quot;&gt;&lt;/a&gt;“匿名函数自执行” vs  IIFE&lt;/h3&gt;&lt;p&gt;自执行，有的地方会写为自调用，是一个经常会听到的的概念，我们再深究一下它吧。所谓的“匿名函数自执行”指的是 &lt;code&gt;Self-executing anonymous function&lt;/code&gt; ，经常与 &lt;code&gt;IIFE&lt;/code&gt; 混淆， &lt;code&gt;Immediately-Invoked Function Expression&lt;/code&gt; 即 &lt;strong&gt;立即调用的函数表达式&lt;/strong&gt; ，含义上的辨析 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;先戳一下中文wiki&lt;/a&gt; 吧。&lt;/p&gt;
&lt;p&gt;IIFE 的具体的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 第一个例子&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(function (x) &amp;#123; return x + 1;&amp;#125;(2)) // =&amp;gt; 3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 第二个例子&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var result = function (x) &amp;#123; return x + 1; &amp;#125;(2); // =&amp;gt; result 的值为3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把第一个例子敲到控制台中，我们可以看到这个 &lt;code&gt;()&lt;/code&gt; 中的代码立即执行了，返回3。对于第二个例子，它实际上执行的是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var foo = function (x) &amp;#123;return x + 1;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var result = foo(2)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有一个知识点： &lt;strong&gt;对于函数类对象，不论是一个现场定义的匿名函数，还是一个之前定义的有名字的函数，它们在不加括号的时候都代表了这个函数对象本身，而加了括号就代表调用这个函数，也就是这个函数 return 的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再回到匿名函数自执行与 IIFE 的辨析上，匿名函数自执行(Self-executing anonymous function)是一个不够准确的概念：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 它是一个自执行的匿名函数，它必须用 arguments.callee() 来递归地调用自己&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var foo = function() &amp;#123; arguments.callee(); &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 它是一个立即执行的匿名函数，只是立即执行了一段 code ，并不是调用自己&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(function () &amp;#123; /* code */ &amp;#125; ());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因此 &lt;code&gt;自执行&lt;/code&gt; 意味着调用自己， &lt;code&gt;立即调用，立即执行&lt;/code&gt; 强调的是定义函数的时候就直接执行了函数，与函数体内是否调用自身无关。只能说这是两个看起来有些类似的概念，但实际上所强调的内容完全不一样。IIFE 也可以调用自己，匿名函数可以立即执行。&lt;/p&gt;
&lt;h3 id=&quot;IIFE-的应用&quot;&gt;&lt;a href=&quot;#IIFE-的应用&quot; class=&quot;headerlink&quot; title=&quot;IIFE 的应用&quot;&gt;&lt;/a&gt;IIFE 的应用&lt;/h3&gt;&lt;p&gt;立即调用的函数表达式的根本作用是 &lt;strong&gt;创建一个独立的作用域&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;模拟块级作用域，在ES6之前 JavaScript 是没有块级作用域的。&lt;br&gt;在实际应用场景中，项目引用了很多不同的库 ，库与库之间是如何保证变量不被覆盖呢？&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// libA.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// blabla&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// libB.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// blabla&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的话，就如同我们在前面看到的 jquery underscore 那样，使自身作用域独立，不会互相覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决闭包的坑： &lt;strong&gt;闭包只能取得包含函数中任何变量的最后一个值&lt;/strong&gt;&lt;br&gt;这次改造一下《高程三》中提到的例子作为参照吧：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    result.push(foo)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; res = test()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,len = res.length; i &amp;lt; len; i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  res[i]()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 控制台中打出来的是10个10，而不是1，2，3...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// i 是贯穿整个作用域的，而不是给每个 foo 分配了一个 i&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// test()执行完毕后才调用 console.log() 一定是发生在for循环已循环结束后，此时i值为10&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在线例子可以戳 &lt;a href=&quot;https://jsfiddle.net/46x5s72a/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSFiddle&lt;/a&gt;&lt;br&gt;这个坑该怎么处理呢？引入IIFE！下面代码是可用的，把 i 的值作为索引锁住了&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 解决思路是给每个foo函数创建一个独立的作用域&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 添加一个IIFE&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;index&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(index);&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      result.push(foo)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	   &amp;#125;)(i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; res = test()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,len = res.length; i &amp;lt; len; i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    res[i]()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;汤姆大叔的博客:深入理解JavaScript系列（4）: 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow: What is the purpose of a self executing function in javascript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://weizhifeng.net/immediately-invoked-function-expression.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;weizhifeng.net: JavaScript中的立即执行函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/iife.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;最近在进行 &lt;a href=&quot;https://github.com/MechanicianW/underscore-analysis&quot;&gt;underscore.js 源码分析&lt;/a&gt;，也顺便看了些别的库的大致封装方式&lt;br&gt;underscore:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped = obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// blabla&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="http://mechanicianw.github.io/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Before learning the functional programming and design patterns</title>
    <link href="http://mechanicianw.github.io/2016/11/17/javascript-patterns/"/>
    <id>http://mechanicianw.github.io/2016/11/17/javascript-patterns/</id>
    <published>2016-11-17T13:15:00.000Z</published>
    <updated>2016-12-18T08:50:15.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/JavaScript-for-Kids.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;h3 id=&quot;OOP-In-JavaScript&quot;&gt;&lt;a href=&quot;#OOP-In-JavaScript&quot; class=&quot;headerlink&quot; title=&quot;OOP In JavaScript&quot;&gt;&lt;/a&gt;OOP In JavaScript&lt;/h3&gt;&lt;h4 id=&quot;Duck-Typing-鸭子类型&quot;&gt;&lt;a href=&quot;#Duck-Typing-鸭子类型&quot; class=&quot;headerlink&quot; title=&quot;Duck Typing 鸭子类型&quot;&gt;&lt;/a&gt;Duck Typing 鸭子类型&lt;/h4&gt;&lt;p&gt;JavaScript 是一门动态类型语言，与静态类型语言相比，在进行变量赋值时并不需要考虑它的类型。在动态类型语言的面向对象设计中， &lt;code&gt;鸭子类型&lt;/code&gt; 的概念非常重要：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸭子类型 (duck typing)&lt;/a&gt; 的通俗说法是““当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”” 鸭子类型指导我们只关注对象的行为，而不专注对象本身，即关注 HAS-A,而不是IS-A。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h4&gt;&lt;p&gt;多态的含义是“同一操作作用于不同对象上面，可以产生不同的解释和执行结果”，背后的思想是把“不变的事物”与“可能改变的事物”分离开来，把不变的部分隔离出来，把可变的部分封装起来，使得代码变得可扩展，修改代码也变得更加安全。 &lt;strong&gt;不必再向对象询问“你是什么类型”再根据得到的答案调用对象的某个行为，直接调用就是了&lt;/strong&gt; 。JavaScript 的多态性与生俱来，它在编译时没有类型检查的过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;多态最根本的作用在于通过 &lt;strong&gt;把过程化的条件分支语句转化为对象的多态性&lt;/strong&gt; 。将行为分布在各个对象中，由对象负责自己的行为，避免代码中充斥着错综复杂的if-else判断。&lt;/p&gt;
&lt;p&gt;一个实际开发中的例子，“引用了不同地图应用的API，使其在页面中渲染地图”&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; googleMap = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  show: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;开始渲染google地图&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; baiduMap = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  show: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;开始渲染baidu地图&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 不具有多态性的代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; renderMap = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type === &lt;span class=&quot;string&quot;&gt;&#39;google&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    googleMap.show()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type === &lt;span class=&quot;string&quot;&gt;&#39;baidu&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    baiduMap.show()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;renderMap(&lt;span class=&quot;string&quot;&gt;&#39;google&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;renderMap(&lt;span class=&quot;string&quot;&gt;&#39;baidu&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 具有多态性的代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; renderMap = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;map&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (map.show &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    map.show()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;renderMap(googleMap)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;renderMap(googleMap)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h4&gt;&lt;p&gt;封装为的是使信息隐藏，使得对象内部的变化对其它对象是不可见的。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中依赖变量的作用域来实现封装特性 ，以及 ES6 提供的新的变量声明命令 &lt;code&gt;let&lt;/code&gt; 和 新的数据类型 &lt;code&gt;Symbol&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myObject = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _name = &lt;span class=&quot;string&quot;&gt;&#39;encapsulation&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    getName: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myObject._name) &lt;span class=&quot;comment&quot;&gt;//undefined&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myObject.getName()) &lt;span class=&quot;comment&quot;&gt;// encapsulation&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从 &lt;a href=&quot;http://efe.baidu.com/blog/javascript-private-implement/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在 JavaScript 中依赖变量的作用域来实现封装特性&lt;/a&gt; 可以发现， &lt;code&gt;Symbol + 类WeakMap 的整合方案&lt;/code&gt; 是一个较好的实现方式。&lt;/p&gt;
&lt;p&gt;未完待续&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/JavaScript-for-Kids.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;h3 id=&quot;OOP-In-JavaScript&quot;&gt;&lt;a href=&quot;#OOP-In-JavaScript&quot; class=&quot;headerlink&quot; title=&quot;OOP In JavaScript&quot;&gt;&lt;/a&gt;OOP In JavaScript&lt;/h3&gt;&lt;h4 id=&quot;Duck-Typing-鸭子类型&quot;&gt;&lt;a href=&quot;#Duck-Typing-鸭子类型&quot; class=&quot;headerlink&quot; title=&quot;Duck Typing 鸭子类型&quot;&gt;&lt;/a&gt;Duck Typing 鸭子类型&lt;/h4&gt;&lt;p&gt;JavaScript 是一门动态类型语言，与静态类型语言相比，在进行变量赋值时并不需要考虑它的类型。在动态类型语言的面向对象设计中， &lt;code&gt;鸭子类型&lt;/code&gt; 的概念非常重要：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B&quot;&gt;鸭子类型 (duck typing)&lt;/a&gt; 的通俗说法是““当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”” 鸭子类型指导我们只关注对象的行为，而不专注对象本身，即关注 HAS-A,而不是IS-A。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h4&gt;&lt;p&gt;多态的含义是“同一操作作用于不同对象上面，可以产生不同的解释和执行结果”，背后的思想是把“不变的事物”与“可能改变的事物”分离开来，把不变的部分隔离出来，把可变的部分封装起来，使得代码变得可扩展，修改代码也变得更加安全。 &lt;strong&gt;不必再向对象询问“你是什么类型”再根据得到的答案调用对象的某个行为，直接调用就是了&lt;/strong&gt; 。JavaScript 的多态性与生俱来，它在编译时没有类型检查的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="http://mechanicianw.github.io/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读《高性能JavaScript》(下)</title>
    <link href="http://mechanicianw.github.io/2016/10/03/high-performance-javascript-b/"/>
    <id>http://mechanicianw.github.io/2016/10/03/high-performance-javascript-b/</id>
    <published>2016-10-03T08:43:00.000Z</published>
    <updated>2016-12-18T08:49:51.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-04%20%E4%B8%8B%E5%8D%888.18.32.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;接&lt;a href=&quot;http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/&quot;&gt;前四节的总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-字符串和正则表达式&quot;&gt;&lt;a href=&quot;#5-字符串和正则表达式&quot; class=&quot;headerlink&quot; title=&quot;5.字符串和正则表达式&quot;&gt;&lt;/a&gt;5.字符串和正则表达式&lt;/h2&gt;&lt;h4 id=&quot;字符串构建原理&quot;&gt;&lt;a href=&quot;#字符串构建原理&quot; class=&quot;headerlink&quot; title=&quot;字符串构建原理&quot;&gt;&lt;/a&gt;字符串构建原理&lt;/h4&gt;&lt;p&gt;&lt;code&gt;str += &amp;#39;one&amp;#39; + &amp;#39;two&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这行代码运行时会经历四个步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.在内存中创建一个临时字符串&lt;br&gt;2.链接后的字符串 ‘onetwo’ 被赋值给该临时字符串&lt;br&gt;3.临时字符串与 str 当前值连接&lt;br&gt;4.结果赋给 str&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;过程中产生的临时字符串造成了较大的性能开销，应当避免在字符串构建过程中创建临时字符串：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str = str + &amp;#39;one&amp;#39; + &amp;#39;two&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于IE之外的浏览器会给表达式左侧字符串分配更多内存，然后把第二个字符串拷贝到最左侧字符串的末尾，因此如果在循环中，基础字符串位于最左端，就可以避免重复拷贝一个逐渐变大的基础字符串。&lt;/p&gt;
&lt;p&gt;除此之外，使用数组项合并的方法（&lt;code&gt;Array.prototype.join&lt;/code&gt;）比其它字符串连接方法更慢，&lt;code&gt;String.prototype.concat&lt;/code&gt; 也比简单的 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;+=&lt;/code&gt;更慢，构建大字符串时会造成灾难性的性能问题。&lt;/p&gt;
&lt;p&gt;在此也拓展一个vajoy大大提到的知识点， &lt;strong&gt;字符串方法是如何调用的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串（String）类型属于基本类型，它不是对象，那我们是怎么调用它的 &lt;code&gt;concat&lt;/code&gt;、&lt;code&gt;substring&lt;/code&gt; 等字符串属性方法呢？&lt;/p&gt;
&lt;p&gt;在 JavaScript 的世界中万物皆对象&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s1.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(s1.color);  &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实在每次调用 s1 的属性方法时，后台都会默默地先执行 &lt;code&gt;s1=new String(&amp;#39;some text&amp;#39;)&lt;/code&gt; ，从而让我们可以顺着原型链调用到String对象的属性（比如第二行调用了 &lt;code&gt;substring&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;在调用完毕后，后台会再默默销毁掉这个先前创建的包装对象，因此在第三行代码执行完毕之后， &lt;code&gt;s1&lt;/code&gt;即被销毁，最后 alert 的结果是 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。” ——《高程三》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;正则表达式优化&quot;&gt;&lt;a href=&quot;#正则表达式优化&quot; class=&quot;headerlink&quot; title=&quot;正则表达式优化&quot;&gt;&lt;/a&gt;正则表达式优化&lt;/h4&gt;&lt;p&gt;本节内容最重要的是理解 &lt;strong&gt;回溯&lt;/strong&gt; ：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;回溯法采用试错的思想，它尝试分步的去解决一个问题。&lt;/p&gt;
&lt;p&gt;在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。&lt;/p&gt;
&lt;p&gt;回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：&lt;/p&gt;
&lt;p&gt;1.找到一个可能存在的正确的答案&lt;/p&gt;
&lt;p&gt;2.在尝试了所有可能的分步方法后宣告该问题没有答案&lt;/p&gt;
&lt;p&gt;在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回溯是正则表达式匹配过程中的基础部分，使用不当也会造成非常大的计算消耗。提高效率的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;加快匹配失败的过程：正则表达式慢的原因通常是匹配失败的过程慢：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;eABC21323AB213&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    r1 = &lt;span class=&quot;regexp&quot;&gt;/\bAB/&lt;/span&gt;.test(str),   &lt;span class=&quot;comment&quot;&gt;//匹配失败的过程较长&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    r2 = &lt;span class=&quot;regexp&quot;&gt;/^AB/&lt;/span&gt;.test(str);    &lt;span class=&quot;comment&quot;&gt;//匹配失败的过程很短&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;减少分支条件，具体化量词：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;cat 1990&#39;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//需匹配：19XX年出生的猫或蝙蝠&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; r1 = &lt;span class=&quot;regexp&quot;&gt;/(cat|bat)\s\d&amp;#123;4&amp;#125;/&lt;/span&gt;.test(str);  &lt;span class=&quot;comment&quot;&gt;//不推荐&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; r1 = &lt;span class=&quot;regexp&quot;&gt;/[bc]at\s19\d&amp;#123;2&amp;#125;/&lt;/span&gt;.test(str);  &lt;span class=&quot;comment&quot;&gt;//推荐，减少分支，具体化量词&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用非捕获组，在不需要反向引用的时候&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只捕获感兴趣的文本以减少后处理：如果需要引用匹配的一部分，应该先捕获那些片段，再用反向引用来处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拆开复杂的表达式：避免在一个正则表达式中处理太多任务。复杂的搜索问题需要条件逻辑，拆分成两个或多个正则表达式更容易解决，通常也会更高效&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;6-快速响应的用户界面&quot;&gt;&lt;a href=&quot;#6-快速响应的用户界面&quot; class=&quot;headerlink&quot; title=&quot;6.快速响应的用户界面&quot;&gt;&lt;/a&gt;6.快速响应的用户界面&lt;/h2&gt;&lt;p&gt;有一次和一位月饼厂的安卓开发聊天，她说她最近跟合作的前端沟通很费劲，她一直想弄明白浏览器UI线程是不是单线程，可是那个前端也不明白这个概念，由此引出了对一些前端开发人员业务知识薄弱的吐槽。听的时候我也没法做任何反应，我也并不清楚这个概念 = =&lt;/p&gt;
&lt;p&gt;好在这一章节就围绕浏览器的UI线程展开的，依然是干货很多让人“知其所以然”。&lt;/p&gt;
&lt;h4 id=&quot;浏览器UI线程&quot;&gt;&lt;a href=&quot;#浏览器UI线程&quot; class=&quot;headerlink&quot; title=&quot;浏览器UI线程&quot;&gt;&lt;/a&gt;浏览器UI线程&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;大多数浏览器让一个单线程共用于执行 JavaScript 和更新用户界面，每个时刻只能执行其中一种操作，这意味着当 JavaScript 代码正在执行时用户界面无法响应输入，反之亦然。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好像是很容易理解的，但还是深入了解一下 wikipedia 中 &lt;code&gt;线程&lt;/code&gt; 的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再看一下什么是 &lt;code&gt;进程&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程（英语：process），是计算机中已运行程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。&lt;/p&gt;
&lt;p&gt;用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。&lt;br&gt;进程需要一些资源才能完成工作，如CPU使用时间、内存、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而常规浏览器并不会只有一个线程在运作，主要线程可归类为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/561179/201601/561179-20160103131737151-1750514444.jpg&quot; alt=&quot;common thread&quot;&gt;&lt;/p&gt;
&lt;p&gt;基础知识补到这里，半路出家的程序员心好累。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UI线程的工作基于一个简单的队列系统&lt;/strong&gt; ，任务会保存到队列中直到线程空闲，一旦空闲队列中的下一个任务就被重新提取出来并运行。先看一个简单的交互例子来理解UI线程的队列系统：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;html&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;head&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;title&amp;gt;Browser UI Thread Example&amp;lt;/title&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;/head&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;body&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;button onclick=&quot;handleClick()&quot;&amp;gt;Click Me&amp;lt;/button&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      function handleClick()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        var div = document.createElement(&quot;div&quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        div.innerHTML = &quot;Clicked!&quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        document.body.appendChild(div);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;/script&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;/body&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;按钮上绑定了一个点击事件，点击后会调用 &lt;code&gt;handleClick()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201005/31/0_12752710809o5M.gif&quot; alt=&quot;thread&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;按钮被点击，触发UI线程创建两个任务并添加到队列中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新按钮UI&lt;/li&gt;
&lt;li&gt;执行 JavaScript 即执行 &lt;code&gt;handleClick()&lt;/code&gt; 函数段代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行 JavaScript 过程中创建了新的 div 元素并附加在 body 后，又触发了一次UI更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大多数浏览器在 JavaScript 运行时会停止吧新任务加入 UI 线程的队列中，因此如果用户试图在任务运行期间与页面交互，不仅没有即时的 UI 更新，可能连 UI 更新任务都不会加入到队列中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当脚本执行时，UI 不随用户交互而更新，执行时间段内用户交互行为所引发的 JavaScript 任务会被加入队列中，并在最初的 JavaScript 任务完成后一次执行。而这段时间里由交互行为引发的 UI 更新会被自动跳过。因此在一个脚本运行期间点击一个按钮，将无法看到它被按下的样式，尽管它的 onclick 事件处理器会被执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;使用定时器进行优化&quot;&gt;&lt;a href=&quot;#使用定时器进行优化&quot; class=&quot;headerlink&quot; title=&quot;使用定时器进行优化&quot;&gt;&lt;/a&gt;使用定时器进行优化&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;单个 JavaScript 操作花费的总时间不应该超过100毫秒。否则用户会感到与界面失去联系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一些复杂的任务无法在100毫秒内执行完毕则需要停止 JavaScript 的执行，让出线程控制权使得 UI 可以更新。因此我们需要使用定时器进行优化。&lt;/p&gt;
&lt;p&gt;创建一个定时器会造成 UI 线程暂停，也会重置所有相关的浏览器限制，包括长时间运行脚本定时器和调用栈。这使得定时器成为长时间运行 JavaScript 代码理想的跨浏览器解决方案。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; button = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;my-button&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;button.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  oneMethod();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;notice&quot;&lt;/span&gt;).style.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;number&quot;&gt;250&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意 &lt;code&gt;setTimeout()&lt;/code&gt; 和 &lt;code&gt;setInterval()&lt;/code&gt; 函数中的第二个参数表示任务何时被添加到 UI 队列，而不是一定会在这段时间后执行。定时器代码只有在创建它的函数执行完成之后才有可能被执行。如果调用setTimeout()的函数又调用了其他任务，耗时超过定时器延时，定时器代码将立即被执行，它与主调函数之间没有可察觉的延迟。&lt;/p&gt;
&lt;p&gt;同时需要注意的是定时器的精度问题： &lt;strong&gt;定时器延迟通常并不精准，不可用于测量实际时间。所以延迟的最小值建议为25毫秒，以免加上误差延时实际上变得更小，不够进行UI刷新。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我以前还想过用定时器来 console.log 打印出来运行耗费时间来进行优化测试之类的，这样看来还是 too naive ，所以该怎么记录代码的运行时间？&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; start = +&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;(),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stop;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;someLongProcess();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stop = +&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stop-start &amp;lt; &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  alert(&lt;span class=&quot;string&quot;&gt;&quot;Just about right.&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  alert(&lt;span class=&quot;string&quot;&gt;&quot;Taking too long.&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们也可以利用类似思路，把需要长时间运行的脚本切割成小任务来执行：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timedProcessArray&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;items, process, callback&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; todo = items.concat(); &lt;span class=&quot;comment&quot;&gt;//create a clone of the original&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; start = +&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      process(todo.shift());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (todo.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (+&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;() - start &amp;lt; &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 检查是否仍有任务需执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (todo.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      setTimeout(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.callee, &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      callback(items);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;克隆需执行的任务数组来进行操作，每次取一项并从数组中移除这项(array.shift())，如果此时程序所耗费时间少于50毫秒，那就见缝插针地继续指向任务项，否则就先停止执行代码，25毫秒后继续。&lt;/p&gt;
&lt;p&gt;定时器很好用，但是滥用也同样会导致性能问题。&lt;/p&gt;
&lt;p&gt;在上面定时器的例子中，我想到了另一个通过定时器来实现的优化点：&lt;code&gt;函数节流 throttele&lt;/code&gt; 与 &lt;code&gt;函数防抖 debounce&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;Throttle-and-Debounce&quot;&gt;&lt;a href=&quot;#Throttle-and-Debounce&quot; class=&quot;headerlink&quot; title=&quot;Throttle and Debounce&quot;&gt;&lt;/a&gt;Throttle and Debounce&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Throttle 和 Debounce 函数都可以限定函数的执行时间点，在 &lt;code&gt;window.onresize&lt;/code&gt; 事件中：&lt;br&gt;使用 &lt;code&gt;throttle(action, time)&lt;/code&gt; 可以让 &lt;code&gt;action&lt;/code&gt; 在 &lt;code&gt;time&lt;/code&gt; 时间内一定执行且只执行一次;&lt;br&gt;使用 &lt;code&gt;debounce(action, time)&lt;/code&gt; 函数可以让 &lt;code&gt;action&lt;/code&gt; 在 &lt;code&gt;resize&lt;/code&gt; 停止 &lt;code&gt;time&lt;/code&gt; 时间之后执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数节流与防抖都是避免了连续触发事件而导致浏览器崩溃，简单的封装实现：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; throttle = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;action, time&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; startTime = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ctx = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currentTime = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentTime - startTime &amp;gt; time) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            action.apply(ctx);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            startTime = currentTime;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;resize&#39;&lt;/span&gt;, throttle(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;resize event&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即事件连续触发时，&lt;code&gt;throttle(action, time)&lt;/code&gt; 中的 &lt;code&gt;action&lt;/code&gt; 会每隔 &lt;code&gt;time&lt;/code&gt; 时间就触发一次。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; debounce = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;action, time&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ctx = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (timer) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            clearTimeout(timer);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        timer = setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            action.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;, time);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;resize&#39;&lt;/span&gt;, debounce(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;resize&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即事件连续触发时，&lt;code&gt;debounce(action, time)&lt;/code&gt; 中的 &lt;code&gt;action&lt;/code&gt; 并不会立即执行；当第二次触发 &lt;code&gt;window.onresize&lt;/code&gt; 事件时，如果两次事件发生的间隔小于 &lt;code&gt;time&lt;/code&gt;，则仍然不执行 &lt;code&gt;action&lt;/code&gt;，只有两次间隔大于 &lt;code&gt;time&lt;/code&gt; 才会执行 &lt;code&gt;action&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;更多内容可以阅读 &lt;a href=&quot;https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《浅谈 Underscore.js 中 &lt;em&gt;.throttle 和 &lt;/em&gt;.debounce 的差异》&lt;/a&gt;，文中用电梯策略来讲解节流与防抖的区别，以及在 Underscore.js 中的实现，非常值得一看。&lt;/p&gt;
&lt;h2 id=&quot;7-Ajax&quot;&gt;&lt;a href=&quot;#7-Ajax&quot; class=&quot;headerlink&quot; title=&quot;7.Ajax&quot;&gt;&lt;/a&gt;7.Ajax&lt;/h2&gt;&lt;p&gt;这一节内容比较杂，并且一些内容和优化建议现在并不实用了，大概参考一下吧。&lt;/p&gt;
&lt;h4 id=&quot;GET-与-POST-的区别&quot;&gt;&lt;a href=&quot;#GET-与-POST-的区别&quot; class=&quot;headerlink&quot; title=&quot;GET 与 POST 的区别&quot;&gt;&lt;/a&gt;GET 与 POST 的区别&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;GET 请求是幂等的，经 GET 请求的数据会被缓存起来，对于少量数据而言 GET 请求往服务器只发送一个数据包，POST 请求发送两个数据包，一个装载头信息一个装载 POST 正文。只有当请求的 URL 加上参数的长度接近或超过2048个字符时才使用 POST 获取数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是书中给的信息，然而是不准确的。&lt;/p&gt;
&lt;p&gt;实际上，&lt;strong&gt;URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。&lt;/strong&gt;，区别主要在语义上，POST 请求并不是明文因而相对更安全，以及书中提到的数据包数量的区别。&lt;/p&gt;
&lt;p&gt;更多详细内容可参考 &lt;a href=&quot;http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《浅谈HTTP中Get与Post的区别》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;8-编程实践&quot;&gt;&lt;a href=&quot;#8-编程实践&quot; class=&quot;headerlink&quot; title=&quot;8.编程实践&quot;&gt;&lt;/a&gt;8.编程实践&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免双重求值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免以 &lt;code&gt;new Function()&lt;/code&gt; 的形式来创建函数&lt;/li&gt;
&lt;li&gt;避免用 &lt;code&gt;setTimeout/setInterval&lt;/code&gt; 执行字符串，可改为传入函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 Object/Array 直接量可以加快运行并且也节省了代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;用速度最快的部分（位操作，原生 JavaScript）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面两章没有太多可参考的新内容，都比较过时，就不记录了~ done!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-04%20%E4%B8%8B%E5%8D%888.18.32.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;接&lt;a href=&quot;http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/&quot;&gt;前四节的总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-字符串和正则表达式&quot;&gt;&lt;a href=&quot;#5-字符串和正则表达式&quot; class=&quot;headerlink&quot; title=&quot;5.字符串和正则表达式&quot;&gt;&lt;/a&gt;5.字符串和正则表达式&lt;/h2&gt;&lt;h4 id=&quot;字符串构建原理&quot;&gt;&lt;a href=&quot;#字符串构建原理&quot; class=&quot;headerlink&quot; title=&quot;字符串构建原理&quot;&gt;&lt;/a&gt;字符串构建原理&lt;/h4&gt;&lt;p&gt;&lt;code&gt;str += &amp;#39;one&amp;#39; + &amp;#39;two&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这行代码运行时会经历四个步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.在内存中创建一个临时字符串&lt;br&gt;2.链接后的字符串 ‘onetwo’ 被赋值给该临时字符串&lt;br&gt;3.临时字符串与 str 当前值连接&lt;br&gt;4.结果赋给 str&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://mechanicianw.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读《高性能JavaScript》(上)</title>
    <link href="http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/"/>
    <id>http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/</id>
    <published>2016-09-26T15:22:00.000Z</published>
    <updated>2016-12-18T08:49:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://img1.doubanio.com/lpic/s28879959.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇只包含前四章节。&lt;/p&gt;
&lt;h2 id=&quot;1-加载与执行&quot;&gt;&lt;a href=&quot;#1-加载与执行&quot; class=&quot;headerlink&quot; title=&quot;1.加载与执行&quot;&gt;&lt;/a&gt;1.加载与执行&lt;/h2&gt;&lt;p&gt;浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。&lt;/p&gt;
&lt;p&gt;减少脚本执行对性能影响的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把所有 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签尽可能放到 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 标签底部。&lt;/li&gt;
&lt;li&gt;合并脚本，减少HTTP请求带来的额外性能开销。&lt;/li&gt;
&lt;li&gt;无阻塞下载执行JavaScript脚本：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 的 &lt;code&gt;defer&lt;/code&gt; 属性可以使脚本下载后先不执行，老版本浏览器不支持&lt;/li&gt;
&lt;li&gt;书中未提到的 HTML5 &lt;code&gt;async&lt;/code&gt; 属性可以使脚本异步加载执行&lt;/li&gt;
&lt;li&gt;使用XHR对象动态加载脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/image003.jpg&quot; alt=&quot;js-load&quot;&gt;&lt;/p&gt;
&lt;p&gt;这部分的知识是刚接触JavaScript时就看过的，&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IBM开发者的文章&lt;/a&gt;介绍的很详尽。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-数据存取&quot;&gt;&lt;a href=&quot;#2-数据存取&quot; class=&quot;headerlink&quot; title=&quot;2.数据存取&quot;&gt;&lt;/a&gt;2.数据存取&lt;/h2&gt;&lt;p&gt;本章主要讲通过改变数据的存取位置来提高读写性能，其中又详细讲解了作用域链，原型链的工作原理，干货不少。&lt;/p&gt;
&lt;p&gt;首先要了解，一共有四种基本的数据存取位置：字面量，本地（局部）变量，数组元素，对象成员。其中字面量和局部变量的存取很快，数组元素和对象成员相对较慢，尤其是在老版本浏览器。&lt;/p&gt;
&lt;h4 id=&quot;作用域与作用域链&quot;&gt;&lt;a href=&quot;#作用域与作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域与作用域链&quot;&gt;&lt;/a&gt;作用域与作用域链&lt;/h4&gt;&lt;p&gt;每一个JavaScript函数都可以表示为一个对象，Function对象既有可编程访问的属性，又有&lt;strong&gt;仅供JavaScript引擎存取的内部属性&lt;/strong&gt;，其中一个内部属性是&lt;code&gt;[[scope]]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;作用域链是&lt;code&gt;[[scope]]&lt;/code&gt;所包含的函数被创建的作用域中对象的集合，作用域链决定了哪些数据可被函数访问以及查找数据的顺序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行函数时会创建一个 &lt;code&gt;execution context 执行上下文&lt;/code&gt; ，它是一个内部对象，函数每次执行时对应的执行上下文都是不一样的。函数执行完毕，执行上下文就被销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;执行上下文&lt;/code&gt; 被创建时，它的作用域链就初始为执行函数的 &lt;code&gt;[[scope]]&lt;/code&gt; 属性中的对象。这些值按顺序被复制到作用域链中，这一过程完成，即创建好了“活动对象”。&lt;/li&gt;
&lt;li&gt;活动对象是函数运行时的变量对象，包含所有局部变量，命名参数集合以及 &lt;code&gt;this&lt;/code&gt;。然后活动对象会被推入作用域链的最前端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在函数执行过程中，每遇到一个变量都会在搜索其作用域链，从头部（即活动对象）搜索直到找到标识符，&lt;strong&gt;正是这个搜索过程影响了性能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在执行环境的作用域链中，一个标识符所在的位置越深，读写速度越慢。所以&lt;strong&gt;读写局部变量最快，全局变量最慢。全局变量总是在作用域链的最末端&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经验：如果一个跨作用域的值在函数中被引用一次以上，那就把它存储在局部变量里。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;两种改变作用域链的情况&quot;&gt;&lt;a href=&quot;#两种改变作用域链的情况&quot; class=&quot;headerlink&quot; title=&quot;两种改变作用域链的情况&quot;&gt;&lt;/a&gt;两种改变作用域链的情况&lt;/h4&gt;&lt;p&gt;有两个语句可以在执行时&lt;em&gt;临时&lt;/em&gt;改变作用域链：&lt;code&gt;with语句&lt;/code&gt;与&lt;code&gt;try-catch中的catch子句&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;with语句&lt;/code&gt; 有性能问题，应避免使用。它是创建了一个包含参数制定对象属性的新对象，并把它推入作用域链最前端，使得局部变量位置变深读写变慢。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;try-catch的catch子句&lt;/code&gt;在执行中是把捕捉到的错误对象推入作用域链首位，也会造成同上的性能问题。解决办法是，在子句中把错误委托给一个函数来处理：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  methodThatMightCauseAnError()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  handle(e)  &lt;span class=&quot;comment&quot;&gt;// 委托给错误处理函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;闭包，作用域与内存&quot;&gt;&lt;a href=&quot;#闭包，作用域与内存&quot; class=&quot;headerlink&quot; title=&quot;闭包，作用域与内存&quot;&gt;&lt;/a&gt;闭包，作用域与内存&lt;/h4&gt;&lt;p&gt;有了先前理论的了解，我们就可以理解一下与闭包有关的性能问题。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignEvents&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id = &lt;span class=&quot;string&quot;&gt;&#39;xdi9952&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;save-btn&#39;&lt;/span&gt;).onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    saveDocument(id)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201005/28/0_1275041109tO2h.gif&quot; alt=&quot;clourse&quot;&gt;&lt;/p&gt;
&lt;p&gt;闭包函数在执行时，它的作用域链与属性 &lt;code&gt;[[scope]]&lt;/code&gt; 中所引用的两个相同的作用域链对象一起被初始化，作用域链首位是闭包函数的活动对象，然后是外部函数的活动对象，最后是全局对象。闭包函数执行时用到的&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;saveDocument&lt;/code&gt;在作用域链第一位之后，这就是使用闭包需要关注的性能点。&lt;/p&gt;
&lt;h4 id=&quot;对象成员，原型与原型链&quot;&gt;&lt;a href=&quot;#对象成员，原型与原型链&quot; class=&quot;headerlink&quot; title=&quot;对象成员，原型与原型链&quot;&gt;&lt;/a&gt;对象成员，原型与原型链&lt;/h4&gt;&lt;p&gt;前文提到的，&lt;strong&gt;访问对象成员的速度慢于访问字面量和局部变量&lt;/strong&gt; ，原因是什么？&lt;/p&gt;
&lt;p&gt;脚本引擎在读取对象属性时，也会按顺序检索。具体可参考&lt;a href=&quot;www.cnblogs.com/snandy/archive/2012/09/01/2664134.html&quot;&gt;这篇博文&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;3-DOM编程-生来缓慢，我很抱歉&quot;&gt;&lt;a href=&quot;#3-DOM编程-生来缓慢，我很抱歉&quot; class=&quot;headerlink&quot; title=&quot;3.DOM编程 生来缓慢，我很抱歉&quot;&gt;&lt;/a&gt;3.DOM编程 生来缓慢，我很抱歉&lt;/h2&gt;&lt;p&gt;JS引擎和DOM引擎是分开的，所以脚本中对DOM的访问非常耗费性能。最坏的情况是在循环中访问或者修改DOM，此时应该把DOM缓存在局部变量中。&lt;/p&gt;
&lt;h4 id=&quot;HTML集合&quot;&gt;&lt;a href=&quot;#HTML集合&quot; class=&quot;headerlink&quot; title=&quot;HTML集合&quot;&gt;&lt;/a&gt;HTML集合&lt;/h4&gt;&lt;p&gt;需要区分一下HTML集合和数组,使用jQuery选择器或者DOM节点引用的，返回的都是&lt;code&gt;HTML集合&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;document.getElementById(&amp;#39;one&amp;#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(&amp;#39;#one&amp;#39;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前在lodash文档里也发现Collection和Array是分开的栏目，当时没当回事儿，现在想想其实是我压根就没有&lt;code&gt;HTML集合&lt;/code&gt;的概念，HTML集合并不是数组，也没有数组可用的方法（etc.&lt;code&gt;slice()&lt;/code&gt;），只是提供了length属性并且可通过数字索引来访问集合中的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML集合是低效之源&lt;/strong&gt; ，集合是实时性的，一直保持着与文档的连接，任何操作和访问都会重复DOM操作。在相同的内容和数量下，遍历一个数组的速度明显快于遍历一个HTML集合。因此也更不应该遍历或循环HTML集合。如果非要进行这种操作的话，建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要在循环的条件控制语句中读取 length 属性（这个无论是集合还是数组都通用）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把集合转为数组再操作&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;toArray&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;coll&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, a = [], len = coll.length; i&amp;lt;len; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a[i] = coll[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问集合时使用局部变量，把length缓存在循环外部，把需要多次读取的元素存在局部变量中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;querySelectorAll&quot;&gt;&lt;a href=&quot;#querySelectorAll&quot; class=&quot;headerlink&quot; title=&quot;querySelectorAll()&quot;&gt;&lt;/a&gt;querySelectorAll()&lt;/h4&gt;&lt;p&gt;关于选择器API，建议使用 &lt;code&gt;document.querySelectorAll()&lt;/code&gt; 的原生DOM方法来获取元素列表。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;getElementById&lt;/code&gt;等api不同，&lt;code&gt;querySelectorAll()&lt;/code&gt; 仅返回一个 NodeList 而非HTML集合，因此这些返回的节点集不会对应实时的文档结构，在遍历节点时可以比较放心地使用该方法。&lt;/p&gt;
&lt;h4 id=&quot;重绘与重排&quot;&gt;&lt;a href=&quot;#重绘与重排&quot; class=&quot;headerlink&quot; title=&quot;重绘与重排&quot;&gt;&lt;/a&gt;重绘与重排&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;此博文：《网页性能管理详解》&lt;/a&gt;中也详细介绍了关于浏览器重排与重绘相关的知识。&lt;/p&gt;
&lt;p&gt;调用一下方法时会 &lt;strong&gt;强制浏览器刷新队列并触发重排&lt;/strong&gt; ：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;offsetTop/offsetLeft/offsetWidth/offsetHeight&lt;br&gt;scrollTop/scrollLeft/scrollWidth/scrollHeight&lt;br&gt;clientTop/clientLeft/clientWidth/clientHeight&lt;br&gt;getComputedStyle()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此如果需要多次查询布局信息如&lt;code&gt;offsetTop&lt;/code&gt;时，应把其缓存起来。&lt;/p&gt;
&lt;p&gt;减少重排的方法有三种，使元素脱离文档流(&lt;code&gt;display:none&lt;/code&gt;)，在文档之外创建并更新一个文档片段并附加到原始列表(&lt;code&gt;document.createDocumentFragment&lt;/code&gt;)，克隆节点(&lt;code&gt;cloneNode&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;比较推荐的是第二个方案，所产生的DOM遍历和重排次数最少：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fragment = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.createDocumentFragment()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;appendDataToElement(fragment, data)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;mylist&#39;&lt;/span&gt;).appendChild(fragment)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;事件委托&quot;&gt;&lt;a href=&quot;#事件委托&quot; class=&quot;headerlink&quot; title=&quot;事件委托&quot;&gt;&lt;/a&gt;事件委托&lt;/h4&gt;&lt;p&gt;每绑定一个事件处理器都是有代价的，要么加重了页面负担，要么增加了运行期的执行时间。所以我们需要使用事件委托来减少事件处理器的数量，而不是给每个元素都绑上事件处理器。&lt;/p&gt;
&lt;p&gt;关于事件委托也是一个坑，先参考一下&lt;a href=&quot;http://stackoverflow.com/questions/1687296/what-is-dom-event-delegation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow: What is DOM Event delegation&lt;/a&gt;，后续再参考高程研究一波。&lt;/p&gt;
&lt;h2 id=&quot;4-算法和流程控制&quot;&gt;&lt;a href=&quot;#4-算法和流程控制&quot; class=&quot;headerlink&quot; title=&quot;4.算法和流程控制&quot;&gt;&lt;/a&gt;4.算法和流程控制&lt;/h2&gt;&lt;p&gt;也是很涨姿势的一章。&lt;/p&gt;
&lt;h4 id=&quot;循环语句&quot;&gt;&lt;a href=&quot;#循环语句&quot; class=&quot;headerlink&quot; title=&quot;循环语句&quot;&gt;&lt;/a&gt;循环语句&lt;/h4&gt;&lt;p&gt;ECMA-262 标准中一共有四种循环类型，&lt;code&gt;for循环&lt;/code&gt;，&lt;code&gt;while循环&lt;/code&gt;，&lt;code&gt;do-while循环&lt;/code&gt;，&lt;code&gt;for-in循环&lt;/code&gt;。前三种循环类型性能所差无几，只有&lt;code&gt;for-in&lt;/code&gt;比其它几种明显要慢，&lt;strong&gt;除了明确需要迭代一个属性数量未知的对象，否则应避免使用for-in循环&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;改善循环性能的切入点有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;减少迭代工作量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;减少对象成员及数组项的查找次数：如上一章所提到的，把数组的length存到局部变量中&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len=items.length; i &amp;lt; len; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  process(items[i])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;采用倒序循环：在每次循环中减少了一次查找属性，减少了控制条件中的一次数值比较&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=items.length;i--; ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  process(items[i])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;减少迭代次数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个涨姿势的概念 &lt;a href=&quot;http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420163.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;达夫设备（Duff’s Device）&lt;/a&gt; 适合迭代次数超过1000的场景(虽然现在应该不会再引用这种方法，但是switch-case的思想可以借鉴)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了上述四种基本的循环类型，数组后续还引入了基于函数的迭代方法&lt;code&gt;forEach()&lt;/code&gt;，但是在所有情况下，基于循环的迭代比基于函数的迭代快8倍。&lt;/p&gt;
&lt;h4 id=&quot;条件语句&quot;&gt;&lt;a href=&quot;#条件语句&quot; class=&quot;headerlink&quot; title=&quot;条件语句&quot;&gt;&lt;/a&gt;条件语句&lt;/h4&gt;&lt;p&gt;&lt;code&gt;if-else&lt;/code&gt;与&lt;code&gt;switch&lt;/code&gt;比较之下，条件数量较小时使用&lt;code&gt;if-else&lt;/code&gt;，较多时使用&lt;code&gt;switch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优化&lt;code&gt;if-else&lt;/code&gt;的方法一是确保最可能出现的条件放在首位，二是把&lt;code&gt;if-else&lt;/code&gt;组织成嵌套的&lt;code&gt;if-else&lt;/code&gt;语句。&lt;/p&gt;
&lt;h4 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h4&gt;&lt;p&gt;这里更涨姿势了，不过描述的内容和场景目前基本没遇到过，不会把那么大的数据量放在前端处理，用Node写服务器端的话可能会遇到。先记住这几个结论吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器的调用栈大小限制了递归算法在 JavaScript 中的应用，栈溢出错误会导致其它代码中断运行。&lt;br&gt;如果遇到栈溢出错误，可以把方法改成迭代算法。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img1.doubanio.com/lpic/s28879959.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇只包含前四章节。&lt;/p&gt;
&lt;h2 id=&quot;1-加载与执行&quot;&gt;&lt;a href=&quot;#1-加载与执行&quot; class=&quot;headerlink&quot; title=&quot;1.加载与执行&quot;&gt;&lt;/a&gt;1.加载与执行&lt;/h2&gt;&lt;p&gt;浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。&lt;/p&gt;
&lt;p&gt;减少脚本执行对性能影响的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把所有 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签尽可能放到 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 标签底部。&lt;/li&gt;
&lt;li&gt;合并脚本，减少HTTP请求带来的额外性能开销。&lt;/li&gt;
&lt;li&gt;无阻塞下载执行JavaScript脚本：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 的 &lt;code&gt;defer&lt;/code&gt; 属性可以使脚本下载后先不执行，老版本浏览器不支持&lt;/li&gt;
&lt;li&gt;书中未提到的 HTML5 &lt;code&gt;async&lt;/code&gt; 属性可以使脚本异步加载执行&lt;/li&gt;
&lt;li&gt;使用XHR对象动态加载脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://mechanicianw.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>一些关于 fetch api 的基本设定</title>
    <link href="http://mechanicianw.github.io/2016/08/22/basic-fetch-api/"/>
    <id>http://mechanicianw.github.io/2016/08/22/basic-fetch-api/</id>
    <published>2016-08-22T08:24:00.000Z</published>
    <updated>2016-12-18T08:52:12.000Z</updated>
    
    <content type="html">&lt;p&gt;长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api &lt;code&gt;Fetch&lt;/code&gt;来替换它。&lt;/p&gt;
&lt;h3 id=&quot;XMLHttpRequest的缺陷&quot;&gt;&lt;a href=&quot;#XMLHttpRequest的缺陷&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest的缺陷&quot;&gt;&lt;/a&gt;XMLHttpRequest的缺陷&lt;/h3&gt;&lt;p&gt;先看一个典型的XHR例子：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; xhr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLHttpRequest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.open(&lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, url);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.responseType = &lt;span class=&quot;string&quot;&gt;&#39;json&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.onload = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(xhr.response);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.onerror = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;Booo&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.send();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Fetch-Api的特点&quot;&gt;&lt;a href=&quot;#Fetch-Api的特点&quot; class=&quot;headerlink&quot; title=&quot;Fetch Api的特点&quot;&gt;&lt;/a&gt;Fetch Api的特点&lt;/h3&gt;&lt;p&gt;fetch api是基于&lt;code&gt;Promise&lt;/code&gt;设计的，定义在BOM的&lt;code&gt;window&lt;/code&gt;对象之中。建议阅读资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fetch Living Standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN: GlobalFetch 文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://caniuse.com/#search=fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;caniuse 浏览器支持率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-18%20%E4%B8%8B%E5%8D%8810.03.45.png&quot; alt=&quot;caniuse-fetch&quot;&gt;&lt;/p&gt;
&lt;p&gt;截止到2016年8月，Chrome43+，Firefox47+支持fetch api，对于低版本的浏览器，github上有许多&lt;a href=&quot;https://github.com/camsong/fetch-ie8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;polyfill&lt;/a&gt;可以使其兼容。&lt;/p&gt;
&lt;p&gt;一个典型的fetch例子：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fetch(url).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.json();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;Booo&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;用ES6的箭头函数重构之后：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fetch(url).then(r =&amp;gt; r.json())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  .then(data =&amp;gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  .catch(e =&amp;gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;Booo&quot;&lt;/span&gt;))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;用还处于草案阶段的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/async#async函数&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ES7的async函数&lt;/a&gt;再重构一下：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; response = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; fetch(url);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; data = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; response.json();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;Booo&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就可以把一个异步的请求代码结构写得看起来跟同步请求差不多了。&lt;/p&gt;
&lt;p&gt;由此可见，&lt;code&gt;Fetch&lt;/code&gt;基于Promise实现，支持async/await，语法更简洁。&lt;/p&gt;
&lt;h3 id=&quot;How-to-Use&quot;&gt;&lt;a href=&quot;#How-to-Use&quot; class=&quot;headerlink&quot; title=&quot;How to Use&quot;&gt;&lt;/a&gt;How to Use&lt;/h3&gt;&lt;h4 id=&quot;fetch&quot;&gt;&lt;a href=&quot;#fetch&quot; class=&quot;headerlink&quot; title=&quot;fetch()&quot;&gt;&lt;/a&gt;fetch()&lt;/h4&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fetch(input, init).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123; ... &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;input&lt;/code&gt; :要获取的资源&lt;ul&gt;
&lt;li&gt;字符串，资源的url&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;Request&lt;/code&gt;对象（后面会介绍Request)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; :可选，是请求的配置项&lt;ul&gt;
&lt;li&gt;method: 请求方式，GET/POST/PUT/DELETE等等&lt;/li&gt;
&lt;li&gt;headers: 请求头，可能是&lt;code&gt;Headers 对象&lt;/code&gt;或者 ByteString&lt;/li&gt;
&lt;li&gt;body: 请求的Body信息&lt;/li&gt;
&lt;li&gt;mode: 请求的模式，cors/no-cors/same-origin&lt;/li&gt;
&lt;li&gt;credentials: 请求的credentials，omit/same-origin/include&lt;/li&gt;
&lt;li&gt;cache: 请求的缓存模式， default/no-store/reload/ no-cache/force-cache/only-if-cached&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回值：返回一个&lt;code&gt;Promise对象&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Fetch引入了3个接口，它们分别是 &lt;code&gt;Headers&lt;/code&gt;,&lt;code&gt;Request&lt;/code&gt; 以及 &lt;code&gt;Response&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;Headers&quot;&gt;&lt;a href=&quot;#Headers&quot; class=&quot;headerlink&quot; title=&quot;Headers()&quot;&gt;&lt;/a&gt;Headers()&lt;/h4&gt;&lt;p&gt;Headers()是一个可检索的多映射名值表，也可穿多维数组或者json&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reqHeaders = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Headers();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reqHeaders = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Headers(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;Content-Length&quot;&lt;/span&gt;: content.length.toString(),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reqHeaders.append(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(reqHeaders.has(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(reqHeaders.has(&lt;span class=&quot;string&quot;&gt;&quot;Set-Cookie&quot;&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Headers()有一个&lt;code&gt;guard&lt;/code&gt;属性来规定哪些参数是可写的。&lt;/p&gt;
&lt;h4 id=&quot;Requset&quot;&gt;&lt;a href=&quot;#Requset&quot; class=&quot;headerlink&quot; title=&quot;Requset()&quot;&gt;&lt;/a&gt;Requset()&lt;/h4&gt;&lt;p&gt;语法，参数与fetch()类似：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var myRequest = new Request(input, init);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中可选的init配置项比fetch()多了几项(redirect/integrity/referrer)&lt;/p&gt;
&lt;h4 id=&quot;Response&quot;&gt;&lt;a href=&quot;#Response&quot; class=&quot;headerlink&quot; title=&quot;Response()&quot;&gt;&lt;/a&gt;Response()&lt;/h4&gt;&lt;p&gt;在fetch()的回调中我们可以获得一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Response&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Response实例&lt;/a&gt;。Response有很多实用的只读属性，比如Response.ok/Response.type/Response.headers等等。&lt;/p&gt;
&lt;h3 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN: GlobalFetch 文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jakearchibald.com/2015/thats-so-fetch/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jake Archibald: That’s so fetch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hacks Mozilla: This API is so Fetching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/camsong/blog/issues/2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;camsong: 传统Ajax 已死，Fetch 永生&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api &lt;code&gt;Fetch&lt;/code&gt;来替换它。&lt;/p&gt;
&lt;h3 id=&quot;XMLHttpRequest的缺陷&quot;&gt;&lt;a href=&quot;#XMLHttpRequest的缺陷&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest的缺陷&quot;&gt;&lt;/a&gt;XMLHttpRequest的缺陷&lt;/h3&gt;&lt;p&gt;先看一个典型的XHR例子：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; xhr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLHttpRequest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.open(&lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, url);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.responseType = &lt;span class=&quot;string&quot;&gt;&#39;json&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.onload = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(xhr.response);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.onerror = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;Booo&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xhr.send();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://mechanicianw.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>关于浏览器缓存</title>
    <link href="http://mechanicianw.github.io/2016/07/18/browser-cache-summary/"/>
    <id>http://mechanicianw.github.io/2016/07/18/browser-cache-summary/</id>
    <published>2016-07-18T13:36:00.000Z</published>
    <updated>2016-07-19T09:57:02.000Z</updated>
    
    <content type="html">&lt;p&gt;浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。&lt;/p&gt;
&lt;p&gt;浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置&lt;code&gt;meta标签&lt;/code&gt;来实现。&lt;/p&gt;
&lt;h2 id=&quot;与缓存相关的首部字段&quot;&gt;&lt;a href=&quot;#与缓存相关的首部字段&quot; class=&quot;headerlink&quot; title=&quot;与缓存相关的首部字段&quot;&gt;&lt;/a&gt;与缓存相关的首部字段&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/CACHE.png&quot; alt=&quot;http首部字段&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/w704.jpg&quot; alt=&quot;状态图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Pragma与Expires&quot;&gt;&lt;a href=&quot;#Pragma与Expires&quot; class=&quot;headerlink&quot; title=&quot;Pragma与Expires&quot;&gt;&lt;/a&gt;Pragma与Expires&lt;/h3&gt;&lt;p&gt;由上表可以看到，Pragma与Expires是http1.0中的内容，是早期的浏览器缓存策略，现在我们也会经常看到看到这两个字段，为的是http协议向下兼容。&lt;br&gt;Pragma属于通用首部字段，在请求和响应报文章都可以设置，一般要求Pragama指令设定在html文件中的&lt;code&gt;&amp;lt;meta&amp;gt;标签&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;不过Pragma一般只有在设置于响应报文中时才会生效。&lt;/p&gt;
&lt;p&gt;Expires是响应头字段，用来启用缓存和规定缓存失效时间。Expires的值对应一个GMT时间，比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。&lt;/p&gt;
&lt;p&gt;如果在meta标签中设置expires只是能设置页面在IE浏览器中是否缓存（对页面资源无效）。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。需要注意的是，expires设置的缓存时间是相对服务器上时间而言的，如果客户端时间与服务器时间不一致，这个缓存也就没意义了。&lt;/p&gt;
&lt;p&gt;另外，同时设置Expires和Pragma的话，Pragma的优先级会更高。&lt;/p&gt;
&lt;h3 id=&quot;Cache-Control&quot;&gt;&lt;a href=&quot;#Cache-Control&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control&quot;&gt;&lt;/a&gt;Cache-Control&lt;/h3&gt;&lt;p&gt;Cache-Control分别能在请求报文和响应报文中使用，来定义缓存有效时间，优先级高于Pragma与Expires。Cache-Control也修正了上述Expires时间差的问题。&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/6941baebgw1eukzzwcvnij20gi089jvb.jpg&quot; alt=&quot;cache-control可设置的值&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Last-Modified&quot;&gt;&lt;a href=&quot;#Last-Modified&quot; class=&quot;headerlink&quot; title=&quot;Last-Modified&quot;&gt;&lt;/a&gt;Last-Modified&lt;/h3&gt;&lt;p&gt;浏览器第一次请求某URL时会返回200，内容是所请求的资源。服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。&lt;/p&gt;
&lt;p&gt;客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查“If-Modified-Since: GMT”，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可，内容为空，节省了传输数据量。&lt;/p&gt;
&lt;h3 id=&quot;ETag&quot;&gt;&lt;a href=&quot;#ETag&quot; class=&quot;headerlink&quot; title=&quot;ETag&quot;&gt;&lt;/a&gt;ETag&lt;/h3&gt;&lt;p&gt;Http1.1中定义了实体首部字段&lt;code&gt;Etag&lt;/code&gt;，即在服务器响应时给请求的URL做标记一个唯一标识符，在响应头中传给客户端。在下一次发请求时，客户端会带上Etag，服务器通过比较服务器上资源的Etag与客户端传过来的Etag来判断资源有没有被修改。若没被修改，则返回304.&lt;/p&gt;
&lt;p&gt;如果Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。&lt;/p&gt;
&lt;h2 id=&quot;缓存策略&quot;&gt;&lt;a href=&quot;#缓存策略&quot; class=&quot;headerlink&quot; title=&quot;缓存策略&quot;&gt;&lt;/a&gt;缓存策略&lt;/h2&gt;&lt;h3 id=&quot;Last-Modified和Etag-→-304&quot;&gt;&lt;a href=&quot;#Last-Modified和Etag-→-304&quot; class=&quot;headerlink&quot; title=&quot;Last-Modified和Etag → 304&quot;&gt;&lt;/a&gt;Last-Modified和Etag → 304&lt;/h3&gt;&lt;p&gt;这两个字段经常在一起配合使用，来判断资源是否已被修改，确定读取本地缓存还是重新请求资源。ETag主要是用来解决Last-Modified无法解决的问题（文件修改频繁，服务器得到的时间不精确等等）。&lt;/p&gt;
&lt;p&gt;这两个字段的特点及应用场景在于，本地已有缓存，但是它们需要向服务器发送请求来确定本地缓存是否是最新的，若服务器认为本地缓存是最新的，可用，则返回304&lt;/p&gt;
&lt;h3 id=&quot;Expires-Cache-Control-→-200&quot;&gt;&lt;a href=&quot;#Expires-Cache-Control-→-200&quot; class=&quot;headerlink&quot; title=&quot;Expires/Cache-Control → 200&quot;&gt;&lt;/a&gt;Expires/Cache-Control → 200&lt;/h3&gt;&lt;p&gt;区别于304状态码，200意味着不向服务器发请求，直接启用本地缓存。即Expires/Cache-Control字段通过绝对时间/相对时间判断出本地缓存是有效的。&lt;/p&gt;
&lt;p&gt;思维导图如下（自己画的感觉很不美观 = =）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%20%281%29.png&quot; alt=&quot;思维导图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;用户行为与缓存&quot;&gt;&lt;a href=&quot;#用户行为与缓存&quot; class=&quot;headerlink&quot; title=&quot;用户行为与缓存&quot;&gt;&lt;/a&gt;用户行为与缓存&lt;/h2&gt;&lt;p&gt;浏览器缓存也与用户行为有关，在地址栏按回车与直接F5是不一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/6941baebgw1eukzzr7rc2j20hg04kjsd.jpg&quot; alt=&quot;用户行为&quot;&gt;&lt;/p&gt;
&lt;p&gt;由图可知，当用户按F5进行刷新，Expires/Cache-Control会失效，浏览器将再次发送请求通过Last-Modified/ETag来判断缓存是否有效。当用户通过Ctrl+F5进行强制刷新时，所有字段都会失效，浏览器将重新请求获取资源。&lt;/p&gt;
&lt;h3 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;w3:HTTP1.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/vajoy/p/5341664.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vajoy:浅谈浏览器http的缓存机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.laruence.com/2010/03/05/1332.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸟哥:浏览器缓存机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/eroswang/article/details/8302191&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;eroswang:浏览器缓存详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。&lt;/p&gt;
&lt;p&gt;浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置&lt;code&gt;meta标签&lt;/code&gt;来实现。&lt;/p&gt;
&lt;h2 id=&quot;与缓存相关的首部字段&quot;&gt;&lt;a href=&quot;#与缓存相关的首部字段&quot; class=&quot;headerlink&quot; title=&quot;与缓存相关的首部字段&quot;&gt;&lt;/a&gt;与缓存相关的首部字段&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/CACHE.png&quot; alt=&quot;http首部字段&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://mechanicianw.github.io/categories/http/"/>
    
    
  </entry>
  
  <entry>
    <title>避免脏pr：使用git rebase避免无谓的merge</title>
    <link href="http://mechanicianw.github.io/2016/06/09/git-rebase-workflow/"/>
    <id>http://mechanicianw.github.io/2016/06/09/git-rebase-workflow/</id>
    <published>2016-06-09T03:51:00.000Z</published>
    <updated>2016-06-16T11:08:42.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;问题复现与解决&quot;&gt;&lt;a href=&quot;#问题复现与解决&quot; class=&quot;headerlink&quot; title=&quot;问题复现与解决&quot;&gt;&lt;/a&gt;问题复现与解决&lt;/h3&gt;&lt;p&gt;在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg&quot; alt=&quot;commit history&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。&lt;/p&gt;
&lt;p&gt;想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git fetch origin master&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# git merge origin/master # 不要这么干&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git rebase origin/master&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# git pull origin master # 不要这么干&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git pull --rebase&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;主要是因为&lt;code&gt;git pull&lt;/code&gt;这一git命令实际执行了&lt;code&gt;git fetch&lt;/code&gt;和&lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;两条指令。因此不要直接使用&lt;code&gt;git pull&lt;/code&gt;来更新代码。&lt;code&gt;git pull --rebase&lt;/code&gt;指令的意思是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把本地repo自从上次pull之后的变更暂存起来&lt;/li&gt;
&lt;li&gt;回到上次pull时的情况&lt;/li&gt;
&lt;li&gt;套用远端的变更&lt;/li&gt;
&lt;li&gt;套用第一步中暂存的本地变更&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;关于git-rebase&quot;&gt;&lt;a href=&quot;#关于git-rebase&quot; class=&quot;headerlink&quot; title=&quot;关于git rebase&quot;&gt;&lt;/a&gt;关于git rebase&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt;和&lt;code&gt;git merge&lt;/code&gt;做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。&lt;br&gt;假设合并前是这样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;D—E master&lt;br&gt;     /&lt;br&gt;A—B—C—F origin/master&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用merge合并后：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;D——–E&lt;br&gt;     /          \&lt;br&gt;A—B—C—F—-G   master, origin/master&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适应rebase合并后：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A—B—C—F—D’—E’   master, origin/master&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。&lt;/p&gt;
&lt;h3 id=&quot;A-rebase-based-workflow&quot;&gt;&lt;a href=&quot;#A-rebase-based-workflow&quot; class=&quot;headerlink&quot; title=&quot;A rebase-based workflow&quot;&gt;&lt;/a&gt;A rebase-based workflow&lt;/h3&gt;&lt;p&gt;1.新建分支&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git checkout master&lt;br&gt;  git pull    #更新master&lt;br&gt;  git checkout master -b test   #从master创建feature分支&lt;br&gt;  git push -u origin test:test&lt;br&gt;  #把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.更新分支&lt;/p&gt;
&lt;p&gt;从master更新&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git pull –rebase origin master #此方法不会更新本地master分支&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从test更新&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git pull –rebase #需先设置追踪分支&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.完成后回到主分支&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git checkout master&lt;br&gt;  git pull     #这里不会导致出现merge commit&lt;br&gt;  git rebase test     #把commits拉取到主分支&lt;br&gt;  git push&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;处理脏pr&quot;&gt;&lt;a href=&quot;#处理脏pr&quot; class=&quot;headerlink&quot; title=&quot;处理脏pr&quot;&gt;&lt;/a&gt;处理脏pr&lt;/h3&gt;&lt;p&gt;这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git fetch origin master:new-feature&lt;br&gt;  git checkout new-feature&lt;br&gt;  git cherry-pick COMMIT_HASH_1&lt;br&gt;  git cherry-pick COMMIT_HASH_2&lt;br&gt;  …&lt;br&gt;  git cherry-pick COMMIT_HASH_N&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。&lt;br&gt;注意cherry-pick的顺序应是commit &lt;strong&gt;从旧到新&lt;/strong&gt; 的顺序，否则会一直出现无数冲突。&lt;/p&gt;
&lt;h3 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://randyfay.com/node/91&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RandyFay:A Rebase Workflow for Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow:When do you use git rebase instead of git merge?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow:git workflow and rebase vs merge questions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git-recipes:代码合并:Merge、Rebase的选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.web-tinker.com/article/21112.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WEB研究所:git 实践之避免 merge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题复现与解决&quot;&gt;&lt;a href=&quot;#问题复现与解决&quot; class=&quot;headerlink&quot; title=&quot;问题复现与解决&quot;&gt;&lt;/a&gt;问题复现与解决&lt;/h3&gt;&lt;p&gt;在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg&quot; alt=&quot;commit history&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。&lt;/p&gt;
&lt;p&gt;想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://mechanicianw.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>How does data binding work in AngularJS</title>
    <link href="http://mechanicianw.github.io/2016/06/05/angular-data-binding/"/>
    <id>http://mechanicianw.github.io/2016/06/05/angular-data-binding/</id>
    <published>2016-06-05T07:28:00.000Z</published>
    <updated>2016-06-17T11:07:48.000Z</updated>
    
    <content type="html">&lt;p&gt;AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$apply()&lt;/code&gt;这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有&lt;code&gt;$digest()&lt;/code&gt;方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。&lt;/p&gt;
&lt;h3 id=&quot;关于-watch&quot;&gt;&lt;a href=&quot;#关于-watch&quot; class=&quot;headerlink&quot; title=&quot;关于$watch&quot;&gt;&lt;/a&gt;关于$watch&lt;/h3&gt;&lt;p&gt;每一次你在UI中绑定什么东西时你就会往&lt;code&gt;$watch&lt;/code&gt;的队列中插入一条&lt;code&gt;$watch&lt;/code&gt;，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;User: &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;user&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Password: &amp;lt;input type=&amp;quot;password&amp;quot; ng-model=&amp;quot;pass&amp;quot; /&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。&lt;/p&gt;
&lt;p&gt;一个watcher包含了三个东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;被触发执行的函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$$watchers = [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        eq: false, // 表明我们是否需要检查对象级别的相等&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fn: function( newValue, oldValue ) &amp;#123;&amp;#125;, // 这是我们提供的监听器函数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        last: &amp;apos;Ryan&amp;apos;, // 变量的最新值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        exp: function()&amp;#123;&amp;#125;, // 我们提供的watchExp函数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        get: function()&amp;#123;&amp;#125; // Angular&amp;apos;s编译后的watchExp函数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义监听器的几种方法：&lt;br&gt;1.把$watch设置为$scope的一种属性:&lt;code&gt;$scope.$watch(&amp;#39;person.username&amp;#39;, validateUnique);&lt;/code&gt;&lt;br&gt;2.插入angular表达式:&lt;code&gt;&amp;lt;p&amp;gt;username: &amp;lt;/p&amp;gt;&lt;/code&gt;&lt;br&gt;3.使用类似于ng-model的指令来定义监听器:&lt;code&gt;&amp;lt;input ng-model=&amp;quot;person.username /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于-digest和-apply&quot;&gt;&lt;a href=&quot;#关于-digest和-apply&quot; class=&quot;headerlink&quot; title=&quot;关于$digest和$apply&quot;&gt;&lt;/a&gt;关于$digest和$apply&lt;/h3&gt;&lt;p&gt;如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。&lt;/p&gt;
&lt;p&gt;当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。&lt;/p&gt;
&lt;p&gt;AngularJS的$apply函数代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$apply: function(expr) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    try &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      beginPhase(&amp;apos;$apply&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      return this.$eval(expr);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; catch (e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      $exceptionHandler(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; finally &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      clearPhase();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      try &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125; catch (e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $exceptionHandler(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        throw e;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由此可见，使用$apply可带参数。&lt;/p&gt;
&lt;p&gt;$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。&lt;/p&gt;
&lt;p&gt;监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。&lt;/p&gt;
&lt;p&gt;$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\$digest仅仅触发当前作用域和子作用域的监控。&lt;/p&gt;
&lt;h3 id=&quot;build-your-own-dirty-checking&quot;&gt;&lt;a href=&quot;#build-your-own-dirty-checking&quot; class=&quot;headerlink&quot; title=&quot;build your own dirty-checking&quot;&gt;&lt;/a&gt;build your own dirty-checking&lt;/h3&gt;&lt;p&gt;了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。&lt;br&gt;首先定义Scope，然后扩展这个函数的原型对象来复制\$digest和\$watch&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var Scope = function( ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.$$watchers = [];   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Scope.prototype.$watch = function( ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Scope.prototype.$digest = function( ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Scope.prototype.$watch = function( watchExp, listener ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.$$watchers.push( &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        watchExp: watchExp,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        listener: listener || function() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果没有传入listener的话我们会把它设置为空函数。&lt;br&gt;$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Scope.prototype.$digest = function( ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    var dirty;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            dirty = false;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            for( var i = 0; i &amp;lt; this.$$watchers.length; i++ ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                var newValue = this.$$watchers[i].watchExp(),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    oldValue = this.$$watchers[i].last;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                if( oldValue !== newValue ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    this.$$watchers[i].listener(newValue, oldValue);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    dirty = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    this.$$watchers[i].last = newValue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; while(dirty);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var $scope = new Scope();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.name = &amp;apos;Ryan&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.$watch(function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return $scope.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, function( newValue, oldValue ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    console.log(newValue, oldValue);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.$digest();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们发现在控制台输出了&lt;code&gt;Ryan undefined&lt;/code&gt;，成功了！&lt;br&gt;最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var Scope = function( ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.$$watchers = [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Scope.prototype.$watch = function( watchExp, listener ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.$$watchers.push( &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        watchExp: watchExp,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        listener: listener || function() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Scope.prototype.$digest = function( ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    var dirty;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            dirty = false;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            for( var i = 0; i &amp;lt; this.$$watchers.length; i++ ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                var newValue = this.$$watchers[i].watchExp(),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    oldValue = this.$$watchers[i].last;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                if( oldValue !== newValue ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    this.$$watchers[i].listener(newValue, oldValue);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    dirty = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    this.$$watchers[i].last = newValue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; while(dirty);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var $scope = new Scope();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.name = &amp;apos;Ryan&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var element = document.querySelectorAll(&amp;apos;input&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;element[0].onkeyup = function() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.name = element[0].value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.$watch(function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return $scope.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, function( newValue, oldValue ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    console.log(&amp;apos;Input value updated - it is now &amp;apos; + newValue);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    element[0].value = $scope.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var updateScopeValue = function updateScopeValue( ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.name = &amp;apos;Bob&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ryanclark.me/how-angularjs-implements-dirty-checking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow:How does data binding work in AngularJS?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xufei/blog/issues/10&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;徐飞:Angular沉思录（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;angular-tips:$watch How the $apply Runs a $digest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IBM developerWorks:AngularJS 作用域与数据绑定机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$apply()&lt;/code&gt;这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有&lt;code&gt;$digest()&lt;/code&gt;方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。&lt;/p&gt;
&lt;h3 id=&quot;关于-watch&quot;&gt;&lt;a href=&quot;#关于-watch&quot; class=&quot;headerlink&quot; title=&quot;关于$watch&quot;&gt;&lt;/a&gt;关于$watch&lt;/h3&gt;&lt;p&gt;每一次你在UI中绑定什么东西时你就会往&lt;code&gt;$watch&lt;/code&gt;的队列中插入一条&lt;code&gt;$watch&lt;/code&gt;，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;User: &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;user&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Password: &amp;lt;input type=&amp;quot;password&amp;quot; ng-model=&amp;quot;pass&amp;quot; /&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="http://mechanicianw.github.io/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Viewport-Percentage (or Viewport-Relative) Lengths</title>
    <link href="http://mechanicianw.github.io/2016/03/17/vieport-percentage/"/>
    <id>http://mechanicianw.github.io/2016/03/17/vieport-percentage/</id>
    <published>2016-03-17T11:16:00.000Z</published>
    <updated>2016-06-16T10:50:14.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;什么是视区百分比长度（viewport-percentage-lengths）？&quot;&gt;&lt;a href=&quot;#什么是视区百分比长度（viewport-percentage-lengths）？&quot; class=&quot;headerlink&quot; title=&quot;什么是视区百分比长度（viewport-percentage lengths）？&quot;&gt;&lt;/a&gt;什么是视区百分比长度（viewport-percentage lengths）？&lt;/h3&gt;&lt;p&gt;先看一下W3C给出的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。&lt;code&gt;initial containing block&lt;/code&gt;意为浏览器内部的可视区域，即&lt;code&gt;window.innerWidth/window.innerHeight&lt;/code&gt;大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;视区单位有&lt;code&gt;vh&lt;/code&gt; (相对于视区高度), &lt;code&gt;vw&lt;/code&gt;(相对于视区宽度), &lt;code&gt;vmin&lt;/code&gt; (相对于视区高度或宽度，取决于哪个更小) and &lt;code&gt;vmax&lt;/code&gt; (类似于vw但取决于哪个更大)。&lt;/p&gt;
&lt;h3 id=&quot;它是如何分配浏览器高度的？&quot;&gt;&lt;a href=&quot;#它是如何分配浏览器高度的？&quot; class=&quot;headerlink&quot; title=&quot;它是如何分配浏览器高度的？&quot;&gt;&lt;/a&gt;它是如何分配浏览器高度的？&lt;/h3&gt;&lt;p&gt;我们可以假借&lt;code&gt;vh&lt;/code&gt;: &lt;code&gt;1vh&lt;/code&gt;相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。&lt;/p&gt;
&lt;h3 id=&quot;浏览器兼容性？&quot;&gt;&lt;a href=&quot;#浏览器兼容性？&quot; class=&quot;headerlink&quot; title=&quot;浏览器兼容性？&quot;&gt;&lt;/a&gt;浏览器兼容性？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png&quot; alt=&quot;caniuse&quot;&gt;&lt;/p&gt;
&lt;p&gt;在css属性可用性查询网站&lt;a href=&quot;http://caniuse.com/#search=viewport%20units&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;caniuse&lt;/a&gt;中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，&lt;strong&gt;Chrome 20+, IE9+ ,FireFox19+以及Safari6&lt;/strong&gt; 都是支持的。&lt;/p&gt;
&lt;h3 id=&quot;100vh与100-的区别？&quot;&gt;&lt;a href=&quot;#100vh与100-的区别？&quot; class=&quot;headerlink&quot; title=&quot;100vh与100%的区别？&quot;&gt;&lt;/a&gt;100vh与100%的区别？&lt;/h3&gt;&lt;p&gt;我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于&lt;code&gt;window.innerWidth/window.innerHeight&lt;/code&gt;的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）&lt;br&gt;就像这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;body style=&amp;quot;height:100%&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;div style=&amp;quot;height:200px&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;lt;p style=&amp;quot;height:100%; display:block;&amp;quot;&amp;gt;Hello, world!&amp;lt;/p&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/body&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px&lt;/p&gt;
&lt;h3 id=&quot;如何用百分比实现同vh一样的效果？&quot;&gt;&lt;a href=&quot;#如何用百分比实现同vh一样的效果？&quot; class=&quot;headerlink&quot; title=&quot;如何用百分比实现同vh一样的效果？&quot;&gt;&lt;/a&gt;如何用百分比实现同vh一样的效果？&lt;/h3&gt;&lt;p&gt;某些情况下，&lt;code&gt;vw&lt;/code&gt;, &lt;code&gt;vh&lt;/code&gt;所产生的效果与百分比&lt;code&gt;%单位&lt;/code&gt;无异，尤其对于&lt;code&gt;absolute/fixed&lt;/code&gt;定位属性的元素。比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    position: fixed;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    top: 100%;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    top: 100vh;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    left: 5%;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    left: 5vw;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    right: 5%;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    right: 5vw;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。&lt;/p&gt;
&lt;h3 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;James Donnelly__stackoverflow&lt;/a&gt;:视区单位布道&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视区相关单位_张鑫旭博客&lt;/a&gt;:更多相关与视区单位应用场景的尝试&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS,Jquery获取各种屏幕的宽度和高度&lt;/a&gt;:复习一下有关屏幕高度的知识&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是视区百分比长度（viewport-percentage-lengths）？&quot;&gt;&lt;a href=&quot;#什么是视区百分比长度（viewport-percentage-lengths）？&quot; class=&quot;headerlink&quot; title=&quot;什么是视区百分比长度（viewport-percentage lengths）？&quot;&gt;&lt;/a&gt;什么是视区百分比长度（viewport-percentage lengths）？&lt;/h3&gt;&lt;p&gt;先看一下W3C给出的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。&lt;code&gt;initial containing block&lt;/code&gt;意为浏览器内部的可视区域，即&lt;code&gt;window.innerWidth/window.innerHeight&lt;/code&gt;大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end css" scheme="http://mechanicianw.github.io/categories/front-end-css/"/>
    
    
  </entry>
  
  <entry>
    <title>[译]JavaScript最佳实践：提高代码质量的技巧和建议</title>
    <link href="http://mechanicianw.github.io/2016/03/13/trans-javascript-code-tips/"/>
    <id>http://mechanicianw.github.io/2016/03/13/trans-javascript-code-tips/</id>
    <published>2016-03-13T08:24:00.000Z</published>
    <updated>2016-11-22T13:06:06.000Z</updated>
    
    <content type="html">&lt;p&gt;原文地址：&lt;a href=&quot;https://www.codementor.io/javascript/tutorial/javascript-best-practices&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.codementor.io/javascript/tutorial/javascript-best-practices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.filepicker.io/api/file/e4jxgEgHRzS1zQU6aJLR&quot; alt=&quot;image&quot;&gt;&lt;br&gt;每天学习新知识可以让我们变成一个更优秀更理性的人。作为一名开发者，持续学习也是我们工作的一部分，无论如何，这些新知识的学习过程都是积极有益的经验积累。&lt;/p&gt;
&lt;p&gt;在这篇教程中，我会提出一些JavaScript的最佳实践，你就不会觉得学习起来很困难了。准备好了就来一起升级你的代码吧！&lt;/p&gt;
&lt;h3 id=&quot;1-避免污染全局作用域&quot;&gt;&lt;a href=&quot;#1-避免污染全局作用域&quot; class=&quot;headerlink&quot; title=&quot;1.避免污染全局作用域&quot;&gt;&lt;/a&gt;1.避免污染全局作用域&lt;/h3&gt;&lt;p&gt;声明变量的过程中有很多有趣的地方。有的时候，你可能在不知情的情况下却声明了一个&lt;code&gt;全局变量&lt;/code&gt;。在现代浏览器中，全局变量会被储存在&lt;code&gt;window&lt;/code&gt;对象中，因此会有很多内容运行在其中，你不知情声明的全局变量可能会覆盖掉一些默认值。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们假设你有一个包含&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签的HTML文件（或者是其中引入了JavaScript文件）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var foo = 42;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(foo);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;很明显，控制台会打印出&lt;code&gt;42&lt;/code&gt;，但是如果这段代码不是执行在函数中的话，这一段执行上下文就会变成全局的。因此，这个变量&lt;code&gt;foo&lt;/code&gt;也会被绑定在&lt;code&gt;window&lt;/code&gt;对象上，意味着&lt;code&gt;window.foo&lt;/code&gt;也是&lt;code&gt;42&lt;/code&gt;。这样是很危险的，你可能覆盖掉了已经存在的全局变量。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function print () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   // do something&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当执行&lt;code&gt;windos.print&lt;/code&gt;（或者&lt;code&gt;print&lt;/code&gt;）时，由于我们已经覆盖了原生的print函数，浏览器就不会弹出打印窗口了。&lt;/p&gt;
&lt;p&gt;解决方法很简单；我们需要一个叫做&lt;code&gt;立即执行函数&lt;/code&gt;的包装函数，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// Declare an anonymous function&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   var foo = 42;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   console.log(window.foo);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   // → undefined&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   console.log(foo);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   // → 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//^ and call it immediately&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;除了这种解决方法，你也可以选择把&lt;code&gt;window&lt;/code&gt;和其它全局对象（如&lt;code&gt;document&lt;/code&gt;）作为参数传递给函数（这样可能会提升性能）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(function (global, doc) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  global.setTimeout(function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     doc.body.innerHTML = &amp;quot;Hello!&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, 1000);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)(window, document);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因此，你要用包裹函数避免创建全局变量。注意一点，我不会在代码段中使用包裹函数，因为我们是要专注于代码本身。&lt;/p&gt;
&lt;p&gt;Tip: &lt;a href=&quot;http://browserify.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模块打包工具browserify&lt;/a&gt;是避免创建全局变量的又一种方法。它以与Node.js同样的方式使用&lt;code&gt;require&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;多说一点，Node.js通过函数来自动包裹你的文件。它们看起来就像这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(function (exports, require, module, __filename, __dirname) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你觉得&lt;code&gt;require&lt;/code&gt;函数也是全局的，然而它并不是。它只不过是一个函数参数。&lt;/p&gt;
&lt;h4 id=&quot;Did-you-know&quot;&gt;&lt;a href=&quot;#Did-you-know&quot; class=&quot;headerlink&quot; title=&quot;Did you know?&quot;&gt;&lt;/a&gt;Did you know?&lt;/h4&gt;&lt;p&gt;尽管&lt;code&gt;window&lt;/code&gt;对象其中包含着全局变量，它本身也是个全局变量，&lt;code&gt;window&lt;/code&gt;内部指向的是它本身：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;window.window.window&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// =&amp;gt; Window&amp;#123;...&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是因为&lt;code&gt;window&lt;/code&gt;是一个循环对象。想要创建一个循环对象的话可以参考：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 创建一个对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var foo = &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//给对象本身赋值一个属性&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo.bar = foo;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// foo就变成了一个循环对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo.bar.bar.bar.bar&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → foo&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所以你可以这样表白你对JavaScripte无限的爱了：&lt;br&gt;&lt;img src=&quot;https://www.filepicker.io/api/file/ZMNjGIiQ52IKsseTjqno&quot; alt=&quot;circle&quot;&gt;&lt;br&gt;你就可以像这样无限扩展这个Object（直到浏览器崩溃）&lt;/p&gt;
&lt;h3 id=&quot;2-使用’use-strict’的好处&quot;&gt;&lt;a href=&quot;#2-使用’use-strict’的好处&quot; class=&quot;headerlink&quot; title=&quot;2.使用’use strict’的好处&quot;&gt;&lt;/a&gt;2.使用’use strict’的好处&lt;/h3&gt;&lt;p&gt;严格使用&lt;code&gt;use strict&lt;/code&gt;！没有什么方法比把这行代码添在JavaScript里可以让你的代码更magic了。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//  糟糕的写法，会让你在不知情的情况下创建了全局变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   a = 42;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   console.log(a);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   // → 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(a);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → 42&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置严格模式，你就会得到报错信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;quot;use strict&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   a = 42;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   // Error: Uncaught ReferenceError: a is not defined&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可能想知道为什么你不能把&lt;code&gt;&amp;quot;use strict&amp;quot;&lt;/code&gt;写在包裹函数外面。事实上，可以写在外面，严格模式就会在全局应用。这么什么不好的，但是要注意如果代码引入了第三方库，或是要打包到一个文件的时候，全局应用可能会造成影响。&lt;/p&gt;
&lt;h3 id=&quot;3-严格等于&quot;&gt;&lt;a href=&quot;#3-严格等于&quot; class=&quot;headerlink&quot; title=&quot;3.严格等于 ===&quot;&gt;&lt;/a&gt;3.严格等于 ===&lt;/h3&gt;&lt;p&gt;如果你想用&lt;code&gt;==&lt;/code&gt;来比较a和b的话，在JavaScript中你可能会发现它的结果有点奇怪：如果你比较的是字符串和数字，它们也会是相等的（&lt;code&gt;==&lt;/code&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;42&amp;quot; == 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// true&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显然，用严格等于（&lt;code&gt;===&lt;/code&gt;）更好&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;42&amp;quot; === 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// false&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-用-amp-amp-和-魔法&quot;&gt;&lt;a href=&quot;#4-用-amp-amp-和-魔法&quot; class=&quot;headerlink&quot; title=&quot;4.用&amp;amp;&amp;amp;和||魔法&quot;&gt;&lt;/a&gt;4.用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;和&lt;code&gt;||&lt;/code&gt;魔法&lt;/h3&gt;&lt;p&gt;在日常工作中，你可以发现用逻辑操作符缩短你的代码&lt;/p&gt;
&lt;p&gt;默认&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;&amp;quot; || &amp;quot;foo&amp;quot;   // → &amp;quot;foo&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;undefined || 42   // → 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//注意一下，如果你想通过这种方式来处理0的话，你要检查它是0还是未赋值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var a = 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a || 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 三元表达式看起来就像是一行结构的if-else语句&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var b = typeof a === &amp;quot;number&amp;quot; ? a : 42;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → 0&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不需要用if表达式来判断布尔值，你可以简单地这样处理：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;expr &amp;amp;&amp;amp; doSomething();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Instead of:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if (expr) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   doSomething();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在上例中如果我们需要&lt;code&gt;doSomething()&lt;/code&gt;来返回结果的话，使用逻辑操作符会看起来更带感：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function doSomething () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return &amp;#123; foo: &amp;quot;bar&amp;quot; &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var expr = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var res = expr &amp;amp;&amp;amp; doSomething();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;res &amp;amp;&amp;amp; console.log(res);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → &amp;#123; foo: &amp;quot;bar&amp;quot; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个问题上你可能会有异议，但使用逻辑操作符确实是更理想的方式。可能你认为用这种方法是“丑化”代码，但那些代码压缩器却真的在这样做。&lt;/p&gt;
&lt;p&gt;尽管代码变短了，它的可读性却依然很好。&lt;/p&gt;
&lt;h3 id=&quot;5-改变变量类型&quot;&gt;&lt;a href=&quot;#5-改变变量类型&quot; class=&quot;headerlink&quot; title=&quot;5.改变变量类型&quot;&gt;&lt;/a&gt;5.改变变量类型&lt;/h3&gt;&lt;p&gt;取决于实际场景，有很多改变变量类型的方法，如下是最常用的方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// anything =》 number&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var foo = &amp;quot;42&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var myNumber = +foo; // shortcut for Number(foo)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → 42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Tip: 可以直接把它变成负数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var negativeFoo = -foo; // or -Number(foo)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → -42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// object =&amp;gt; array&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Tip: `arguments` 是一个对象但通常被用作为数组&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var args = &amp;#123; 0: &amp;quot;foo&amp;quot;, 1: &amp;quot;bar&amp;quot;, length: 2 &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Array.prototype.slice.call(args)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → [ &amp;apos;foo&amp;apos;, &amp;apos;bar&amp;apos; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Anything =》 boolean&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 两次取非可以使它变成布尔值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var t = 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var f = 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!!t&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!!f&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → false&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 一次取非&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!t&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → false&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!f&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Anything =》 string&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var foo = 42;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;&amp;quot; + foo // 转变为字符串的简短方法&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → &amp;quot;42&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo = &amp;#123; hello: &amp;quot;world&amp;quot; &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;JSON.stringify(foo);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// → &amp;apos;&amp;#123; &amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot; &amp;#125;&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;JSON.stringify(foo, null, 4); // 美化代码&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// →&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;apos;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//    &amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;#125;&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 注意一点，不可以 JSON.stringify 环形结构的对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;JSON.stringify(window);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// ⚠ TypeError: JSON.stringify cannot serialize cyclic structures.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-代码风格指南&quot;&gt;&lt;a href=&quot;#6-代码风格指南&quot; class=&quot;headerlink&quot; title=&quot;6.代码风格指南&quot;&gt;&lt;/a&gt;6.代码风格指南&lt;/h3&gt;&lt;p&gt;新项目中在不同文件里应该遵循同样的代码风格，对于老项目，就沿用旧的代码风格，除非你下定决心去整体改掉陈旧代码的风格（要和同事讨论之后再决定）。只要你确定了代码风格，就要一直遵循它。&lt;/p&gt;
&lt;p&gt;这是一些可参考的代码风格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://google.github.io/styleguide/javascriptguide.xml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google JavaScript Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/airbnb/javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;aribnb/javascript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/IonicaBizau/code-style&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;my code-style&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;额外提示&quot;&gt;&lt;a href=&quot;#额外提示&quot; class=&quot;headerlink&quot; title=&quot;额外提示&quot;&gt;&lt;/a&gt;额外提示&lt;/h3&gt;&lt;p&gt;在其它一些JavaScript最佳实践中可以发现有一些有助于编码的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/beautify-web/js-beautify&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;js-beautify&lt;/a&gt;:美化代码&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mishoo/UglifyJS2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UglifyJS(2)&lt;/a&gt;:压缩代码&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jshint/jshint&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jshint&lt;/a&gt;:检测代码中的错误&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jscs.info/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jscs&lt;/a&gt;:可扩展的风格检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一件事，好好&lt;a href=&quot;https://www.codementor.io/learn-programming/what-to-do-when-your-website-is-broken&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;debug&lt;/a&gt;,而不是用&lt;code&gt;console.log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;祝编码愉快！&lt;/p&gt;
&lt;h3 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codementor.io/javascript/tutorial/how-to-learn-javascript-properly&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;初学者指南：学习JavaScript的最佳方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codementor.io/javascript/tutorial/top-ten-things-beginners-must-know-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于JavaScript初学者必知的十件事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codementor.io/learn-programming/javascript-trends-skills-developers-should-learn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在2016年JavaScript开发者需要学习的技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codementor.io/javascript/tutorial/4-easy-ways-to-start-using-es2015&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4种开始使用ES2015的方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最重要的21道面试题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://www.codementor.io/javascript/tutorial/javascript-best-practices&quot;&gt;https://www.codementor.io/javascript/tutorial/javascript-best-practices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.filepicker.io/api/file/e4jxgEgHRzS1zQU6aJLR&quot; alt=&quot;image&quot;&gt;&lt;br&gt;每天学习新知识可以让我们变成一个更优秀更理性的人。作为一名开发者，持续学习也是我们工作的一部分，无论如何，这些新知识的学习过程都是积极有益的经验积累。&lt;/p&gt;
&lt;p&gt;在这篇教程中，我会提出一些JavaScript的最佳实践，你就不会觉得学习起来很困难了。准备好了就来一起升级你的代码吧！&lt;/p&gt;
&lt;h3 id=&quot;1-避免污染全局作用域&quot;&gt;&lt;a href=&quot;#1-避免污染全局作用域&quot; class=&quot;headerlink&quot; title=&quot;1.避免污染全局作用域&quot;&gt;&lt;/a&gt;1.避免污染全局作用域&lt;/h3&gt;&lt;p&gt;声明变量的过程中有很多有趣的地方。有的时候，你可能在不知情的情况下却声明了一个&lt;code&gt;全局变量&lt;/code&gt;。在现代浏览器中，全局变量会被储存在&lt;code&gt;window&lt;/code&gt;对象中，因此会有很多内容运行在其中，你不知情声明的全局变量可能会覆盖掉一些默认值。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://mechanicianw.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Cookie, LocalStorage 与 SessionStorage</title>
    <link href="http://mechanicianw.github.io/2016/03/10/cookie-localstorage-session/"/>
    <id>http://mechanicianw.github.io/2016/03/10/cookie-localstorage-session/</id>
    <published>2016-03-10T07:02:00.000Z</published>
    <updated>2016-06-16T10:50:06.000Z</updated>
    
    <content type="html">&lt;p&gt;有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h3&gt;&lt;p&gt;Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie&lt;/p&gt;
&lt;h3 id=&quot;localStorage&quot;&gt;&lt;a href=&quot;#localStorage&quot; class=&quot;headerlink&quot; title=&quot;localStorage&quot;&gt;&lt;/a&gt;localStorage&lt;/h3&gt;&lt;p&gt;localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;sessionStorage&quot;&gt;&lt;a href=&quot;#sessionStorage&quot; class=&quot;headerlink&quot; title=&quot;sessionStorage&quot;&gt;&lt;/a&gt;sessionStorage&lt;/h3&gt;&lt;p&gt;sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。&lt;/p&gt;
&lt;table&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;th&gt;特性&lt;/th&gt;&lt;br&gt;        &lt;th&gt;Chorme&lt;/th&gt;&lt;br&gt;        &lt;th&gt;Firefox&lt;/th&gt;&lt;br&gt;        &lt;th&gt;IE&lt;/th&gt;&lt;br&gt;        &lt;td&gt;Opera&lt;/td&gt;&lt;br&gt;        &lt;td&gt;Safari&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;localStorage&lt;/td&gt;&lt;br&gt;        &lt;td&gt;4&lt;/td&gt;&lt;br&gt;        &lt;td&gt;3.5&lt;/td&gt;&lt;br&gt;        &lt;td&gt;8&lt;/td&gt;&lt;br&gt;        &lt;td&gt;10.5&lt;/td&gt;&lt;br&gt;        &lt;td&gt;4&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;sessionStorage&lt;/td&gt;&lt;br&gt;        &lt;td&gt;5&lt;/td&gt;&lt;br&gt;        &lt;td&gt;2&lt;/td&gt;&lt;br&gt;        &lt;td&gt;8&lt;/td&gt;&lt;br&gt;        &lt;td&gt;10.5&lt;/td&gt;&lt;br&gt;        &lt;td&gt;4&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;&lt;/table&gt;

&lt;h2 id=&quot;共同点&quot;&gt;&lt;a href=&quot;#共同点&quot; class=&quot;headerlink&quot; title=&quot;共同点&quot;&gt;&lt;/a&gt;共同点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;都是保存在浏览器端，而且同源。 &lt;/li&gt;
&lt;li&gt;三者都是键值对的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据&lt;/li&gt;
&lt;li&gt;如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交&lt;/li&gt;
&lt;li&gt;存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。&lt;/li&gt;
&lt;li&gt;数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。&lt;/li&gt;
&lt;li&gt;安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。&lt;/li&gt;
&lt;li&gt;作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。&lt;/li&gt;
&lt;li&gt;由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h3&gt;&lt;p&gt;Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie&lt;/p&gt;
&lt;h3 id=&quot;localStorage&quot;&gt;&lt;a href=&quot;#localStorage&quot; class=&quot;headerlink&quot; title=&quot;localStorage&quot;&gt;&lt;/a&gt;localStorage&lt;/h3&gt;&lt;p&gt;localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="http://mechanicianw.github.io/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>有关闭包，作用域，this对象</title>
    <link href="http://mechanicianw.github.io/2016/01/02/learning-clouser-scope/"/>
    <id>http://mechanicianw.github.io/2016/01/02/learning-clouser-scope/</id>
    <published>2016-01-02T08:51:00.000Z</published>
    <updated>2016-08-31T15:32:47.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;首先看一下维基百科中，闭包的概念：&quot;&gt;&lt;a href=&quot;#首先看一下维基百科中，闭包的概念：&quot; class=&quot;headerlink&quot; title=&quot;首先看一下维基百科中，闭包的概念：&quot;&gt;&lt;/a&gt;首先看一下维基百科中，闭包的概念：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。&lt;br&gt;闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在创建函数和调用函数时，都发生了什么&quot;&gt;&lt;a href=&quot;#在创建函数和调用函数时，都发生了什么&quot; class=&quot;headerlink&quot; title=&quot;在创建函数和调用函数时，都发生了什么&quot;&gt;&lt;/a&gt;在创建函数和调用函数时，都发生了什么&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;创建函数时&lt;ol&gt;
&lt;li&gt;创建了预先包含全局变量对象的作用域链&lt;/li&gt;
&lt;li&gt;该作用域链保存在内部[[scope]]属性中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;调用函数时&lt;ol&gt;
&lt;li&gt;创建执行环境&lt;/li&gt;
&lt;li&gt;复制函数[[scope]]属性中的对象构建作用域链&lt;/li&gt;
&lt;li&gt;用arguments与其它形参初始化函数的活动对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;要理解这句话：&lt;strong&gt;JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;再用计数器函数来看一个简单的闭包例子&quot;&gt;&lt;a href=&quot;#再用计数器函数来看一个简单的闭包例子&quot; class=&quot;headerlink&quot; title=&quot;再用计数器函数来看一个简单的闭包例子&quot;&gt;&lt;/a&gt;再用计数器函数来看一个简单的闭包例子&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function createCounter() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  var counter = 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  function increment() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    counter = counter + 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    console.log(&amp;quot;Number of events: &amp;quot; + counter);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  return increment;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var counter1 = createCounter();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var counter2 = createCounter();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;counter1(); // Number of events: 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;counter1(); // Number of events: 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;counter2(); // Number of events: 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;counter1(); // Number of events: 3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数实现了分别计数的功能。&lt;br&gt;在createCounter()的最后一句：&lt;code&gt;return increment;&lt;/code&gt;我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。&lt;br&gt;因此，在使用&lt;code&gt;var counter1 = createCounter();&lt;/code&gt;时，实际上，&lt;strong&gt;我们生成了一个新的函数&lt;/strong&gt;。&lt;br&gt;每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。&lt;br&gt;&lt;strong&gt;内部变量 counter 都是独立存在于每个作用域！&lt;/strong&gt;例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。&lt;/p&gt;
&lt;h4 id=&quot;闭包的内存&quot;&gt;&lt;a href=&quot;#闭包的内存&quot; class=&quot;headerlink&quot; title=&quot;闭包的内存&quot;&gt;&lt;/a&gt;闭包的内存&lt;/h4&gt;&lt;p&gt;后台的每个执行环境都有一个表示变量的对象——变量对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局环境的变量对象始终存在&lt;/li&gt;
&lt;li&gt;像 createCounter()函数这样的局部变量，只在函数执行的过程中存在&lt;/li&gt;
&lt;li&gt;作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象&lt;/li&gt;
&lt;li&gt;&lt;em&gt;一般来讲&lt;/em&gt;当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;但闭包的情况有所不同：&lt;/em&gt;&lt;br&gt;内部定义的函数会把外部函数的活动对象添加到它的作用域链中。&lt;br&gt;当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为&lt;strong&gt;匿名函数的作用域链仍然在引用这个活动对象&lt;/strong&gt;。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。&lt;br&gt;一个简单的构造闭包以及释放内存的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function outer () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	var name = &amp;apos;foo&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	return function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		console.log(name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var inner = outer();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;inner();  // foo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;inner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。&lt;br&gt;由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。&lt;/p&gt;
&lt;h4 id=&quot;闭包的陷阱：循环闭包&quot;&gt;&lt;a href=&quot;#闭包的陷阱：循环闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包的陷阱：循环闭包&quot;&gt;&lt;/a&gt;闭包的陷阱：循环闭包&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。&lt;/strong&gt;&lt;br&gt;因此，下面这个例子只会返回同一个值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function foo()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  var result = new Array();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  for(var i=0; i&amp;lt;10; i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    result[i] = function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      return i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  return result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.&lt;br&gt;应改为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function foo()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  var result = new Array();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  for(var i=0; i&amp;lt;10; i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    result[i] = function(num)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      return function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return num&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;(i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  return result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。&lt;br&gt;匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。&lt;/p&gt;
&lt;p&gt;换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。&lt;br&gt;代码简化如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;for (var i = 0; i &amp;lt; 50; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    arr[i] = document.createElement(&amp;apos;i&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    arr[i].index = i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    arr[i].onclick = function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        console.log(this.index);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)(i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;arr[i].index = i;&lt;/code&gt;这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50&lt;/p&gt;
&lt;h4 id=&quot;闭包中的this对象&quot;&gt;&lt;a href=&quot;#闭包中的this对象&quot; class=&quot;headerlink&quot; title=&quot;闭包中的this对象&quot;&gt;&lt;/a&gt;闭包中的this对象&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;匿名函数的执行环境具有全局性，因此其this对象通常指向window&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name = &amp;quot;The Window&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　var object = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　name : &amp;quot;My Object&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　getNameFunc : function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　  return function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　　　 return this.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　　&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(object.getNameFunc()()); // “The Window”&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;内部函数在搜索&lt;code&gt;this&lt;/code&gt;和&lt;code&gt;arguments&lt;/code&gt;这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。&lt;/p&gt;
&lt;h3 id=&quot;关于this关键字&quot;&gt;&lt;a href=&quot;#关于this关键字&quot; class=&quot;headerlink&quot; title=&quot;关于this关键字&quot;&gt;&lt;/a&gt;关于this关键字&lt;/h3&gt;&lt;p&gt;在《JavaScripts语言精粹》中，把this的出现场景分为四种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有对象就指向调用对象&lt;/p&gt;
&lt;p&gt;没调用对象就指向全局对象&lt;/p&gt;
&lt;p&gt;用new构造就指向新对象&lt;/p&gt;
&lt;p&gt;通过 apply 或 call 或 bind 来改变 this 的所指。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-全局的this-window&quot;&gt;&lt;a href=&quot;#1-全局的this-window&quot; class=&quot;headerlink&quot; title=&quot;1.全局的this===window&quot;&gt;&lt;/a&gt;1.全局的this===window&lt;/h4&gt;&lt;h4 id=&quot;2-作为对象方法的函数的this指向这个上级对象&quot;&gt;&lt;a href=&quot;#2-作为对象方法的函数的this指向这个上级对象&quot; class=&quot;headerlink&quot; title=&quot;2.作为对象方法的函数的this指向这个上级对象&quot;&gt;&lt;/a&gt;2.作为对象方法的函数的this指向这个上级对象&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var o =&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  prop:37;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f:function()&amp;#123;return this.prop&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(o.f()); //37&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-构造函数调用，this指向其生成的新对象&quot;&gt;&lt;a href=&quot;#3-构造函数调用，this指向其生成的新对象&quot; class=&quot;headerlink&quot; title=&quot;3.构造函数调用，this指向其生成的新对象&quot;&gt;&lt;/a&gt;3.构造函数调用，this指向其生成的新对象&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;window. x = 2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;function test(m)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　this.x = m;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var o = new test(5);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(x); //5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;4-apply-和-call-调用以及-bind-绑定&quot;&gt;&lt;a href=&quot;#4-apply-和-call-调用以及-bind-绑定&quot; class=&quot;headerlink&quot; title=&quot;4.apply 和 call 调用以及 bind 绑定&quot;&gt;&lt;/a&gt;4.apply 和 call 调用以及 bind 绑定&lt;/h4&gt;&lt;p&gt;全局函数apply和call可以用来改变函数中this的指向，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 定义一个全局函数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   function foo() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       console.log(this.fruit);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; // 定义一个全局变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   var fruit = &amp;quot;apple&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   // 自定义一个对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   var pack = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       fruit: &amp;quot;orange&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 等价于window.foo();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   foo.apply(window);  // &amp;quot;apple&amp;quot;,此时this等于window&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   // 此时foo中的this === pack&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   foo.apply(pack);    // &amp;quot;orange&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先看一下维基百科中，闭包的概念：&quot;&gt;&lt;a href=&quot;#首先看一下维基百科中，闭包的概念：&quot; class=&quot;headerlink&quot; title=&quot;首先看一下维基百科中，闭包的概念：&quot;&gt;&lt;/a&gt;首先看一下维基百科中，闭包的概念：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。&lt;br&gt;闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在创建函数和调用函数时，都发生了什么&quot;&gt;&lt;a href=&quot;#在创建函数和调用函数时，都发生了什么&quot; class=&quot;headerlink&quot; title=&quot;在创建函数和调用函数时，都发生了什么&quot;&gt;&lt;/a&gt;在创建函数和调用函数时，都发生了什么&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;创建函数时&lt;ol&gt;
&lt;li&gt;创建了预先包含全局变量对象的作用域链&lt;/li&gt;
&lt;li&gt;该作用域链保存在内部[[scope]]属性中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;调用函数时&lt;ol&gt;
&lt;li&gt;创建执行环境&lt;/li&gt;
&lt;li&gt;复制函数[[scope]]属性中的对象构建作用域链&lt;/li&gt;
&lt;li&gt;用arguments与其它形参初始化函数的活动对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="http://mechanicianw.github.io/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>tips:编写邮件中的html文件</title>
    <link href="http://mechanicianw.github.io/2015/12/03/html-in-email/"/>
    <id>http://mechanicianw.github.io/2015/12/03/html-in-email/</id>
    <published>2015-12-03T09:31:00.000Z</published>
    <updated>2016-06-16T10:49:18.000Z</updated>
    
    <content type="html">&lt;p&gt;最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。&lt;/p&gt;
&lt;p&gt;如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。&lt;br&gt;目前常见的邮箱客户端有Gmail，Outlook等，&lt;a href=&quot;https://www.campaignmonitor.com/css/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不同邮箱客户端对CSS样式的支持情况&lt;/a&gt;也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。&lt;br&gt;1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为&lt;div&gt;容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。&lt;/div&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div style=&amp;quot;width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    内容区域&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.网页的布局必须使用表格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div style=&amp;quot;text-align:center;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;table width=&amp;quot;600&amp;quot; cellpadding=&amp;quot;0&amp;quot; cellspacing=&amp;quot;0&amp;quot; border=&amp;quot;0&amp;quot; style=&amp;quot;margin:0 auto;&amp;quot;&amp;gt;&amp;lt;tbody&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;lt;div style=&amp;quot;width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;lt;!-- 水平居中的邮件 --&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;lt;/div&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读&lt;/p&gt;
&lt;p&gt;4.如果想测试自己写的html在邮件中效果，可以使用这个网站（&lt;a href=&quot;https://litmus.com/）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://litmus.com/）&lt;/a&gt;&lt;br&gt;这是我测试页面时的截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。&lt;/p&gt;
&lt;p&gt;如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。&lt;br&gt;目前常见的邮箱客户端有Gmail，Outlook等，&lt;a href=&quot;https://www.campaignmonitor.com/css/&quot;&gt;不同邮箱客户端对CSS样式的支持情况&lt;/a&gt;也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。&lt;br&gt;1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为&lt;div&gt;容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end css" scheme="http://mechanicianw.github.io/categories/front-end-css/"/>
    
    
  </entry>
  
  <entry>
    <title>Angular  ui-router</title>
    <link href="http://mechanicianw.github.io/2015/11/23/angular-ui-router/"/>
    <id>http://mechanicianw.github.io/2015/11/23/angular-ui-router/</id>
    <published>2015-11-23T12:17:00.000Z</published>
    <updated>2016-06-16T10:48:06.000Z</updated>
    
    <content type="html">&lt;p&gt;UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。&lt;/p&gt;
&lt;h4 id=&quot;原生ng-route的不足之处：&quot;&gt;&lt;a href=&quot;#原生ng-route的不足之处：&quot; class=&quot;headerlink&quot; title=&quot;原生ng-route的不足之处：&quot;&gt;&lt;/a&gt;原生ng-route的不足之处：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;视图不能嵌套。这意味着$scope会发生不必要的重新载入。&lt;/li&gt;
&lt;li&gt;路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;显而易见，ui-router的优势为：&quot;&gt;&lt;a href=&quot;#显而易见，ui-router的优势为：&quot; class=&quot;headerlink&quot; title=&quot;显而易见，ui-router的优势为：&quot;&gt;&lt;/a&gt;显而易见，ui-router的优势为：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;提出了”$state”的概念，通过改变\$state来进行URL的跳转和路由&lt;/li&gt;
&lt;li&gt;将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于ui-router最重要的参考资料是 &lt;a href=&quot;http://angular-ui.github.io/ui-router/site/#/api/ui.router&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ui-router的官方文档&lt;/a&gt;（&lt;a href=&quot;http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;p&gt;1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;script src=&amp;quot;js/angular.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;lt;!-- Include the ui-router script --&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;lt;script src=&amp;quot;js/angular-ui-router.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.在模块中引入依赖&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var app = angular.module(&amp;apos;routerApp&amp;apos;, [&amp;apos;ui.router&amp;apos;]);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template&lt;br&gt;4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。&lt;br&gt;5.最后我们来新建一个js文件用来配置路由。&lt;/p&gt;
&lt;h4 id=&quot;配置路由&quot;&gt;&lt;a href=&quot;#配置路由&quot; class=&quot;headerlink&quot; title=&quot;配置路由&quot;&gt;&lt;/a&gt;配置路由&lt;/h4&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;app.config(function ($stateProvider, $urlRouterProvider) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  $urlRouterProvider.when(&amp;quot;&amp;quot;, &amp;quot;/page1&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	$stateProvider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .state(&amp;apos;page1&amp;apos;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      url: &amp;apos;/page1&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      templateUrl:&amp;apos;viewpage1.html&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;).state(&amp;apos;page2&amp;apos;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      url: &amp;apos;/page2&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      templateUrl:&amp;apos;view/page2.html&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。&lt;/li&gt;
&lt;li&gt;第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。&lt;br&gt;-第三个参数是用来设置模板，有两种方法。第一种使用”template”，指定一段Html字符串。第二种方法是像示例路由中那样，使用”templateUrl”来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider.state(&amp;apos;contacts&amp;apos;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  templateUrl: function (stateParams)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return &amp;apos;/partials/contacts.&amp;apos; + stateParams + &amp;apos;.html&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;触发激活&quot;&gt;&lt;a href=&quot;#触发激活&quot; class=&quot;headerlink&quot; title=&quot;触发激活&quot;&gt;&lt;/a&gt;触发激活&lt;/h4&gt;&lt;p&gt;路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。&lt;br&gt;比如，用\&lt;a href=&quot;&quot; ui-sref=&quot;page1&quot;&gt;进入page1\&lt;/a&gt;表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）&lt;br&gt;除了上面这种方法，我们还有两种方法来更新视图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$state.go(&amp;apos;page1&amp;apos;);  // 指定状态名&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$state.go(&amp;apos;page1l&amp;apos;, &amp;#123;pageId: 15&amp;#125;);  //含参， 相当于跳转到 /page1/42&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;在浏览器地址栏中直接输入url，这是最直接的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;传递参数&quot;&gt;&lt;a href=&quot;#传递参数&quot; class=&quot;headerlink&quot; title=&quot;传递参数&quot;&gt;&lt;/a&gt;传递参数&lt;/h4&gt;&lt;p&gt;先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。&lt;br&gt;从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html&lt;br&gt;在view/resemeList.html中，我们写入如下一行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;a href=&amp;quot;&amp;quot; ui-sref=&amp;quot;openResume(&amp;#123;resumeId:7&amp;#125;)&amp;quot;&amp;gt;王大锤的简历&amp;lt;/a&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，配置路由是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;state(&amp;apos;openResume&amp;apos;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        url: &amp;apos;/openResume/&amp;#123;resumeId&amp;#125;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        templateUrl:function($stateParams)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            console.log($stateParams);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            return &amp;apos;view/openResume.html&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：&lt;br&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在控制台中我们看到了console出的语句&lt;br&gt;&lt;img src=&quot;http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png&quot; alt=&quot;控制台&quot;&gt;&lt;/p&gt;
&lt;p&gt;说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~&lt;/p&gt;
&lt;h4 id=&quot;嵌套视图&quot;&gt;&lt;a href=&quot;#嵌套视图&quot; class=&quot;headerlink&quot; title=&quot;嵌套视图&quot;&gt;&lt;/a&gt;嵌套视图&lt;/h4&gt;&lt;p&gt;接下来我们来了解一下ui-router区别于ng-router最强大的功能，&lt;strong&gt;嵌套视图&lt;/strong&gt;。&lt;br&gt;在示例路由的基础上，我们新建一个文件page1-main.html&lt;br&gt;现在，在index.html中：\&lt;a href=&quot;&quot; ui-sref=&quot;page1&quot;&gt;进入page1&lt;/a&gt;&lt;br&gt;在page1.html中，：\&lt;a href=&quot;&quot; ui-sref=&quot;page1.main&quot;&gt;进入page1-main&lt;/a&gt;&lt;br&gt;路由变成：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;.state(&amp;apos;page1&amp;apos;,&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  url : &amp;apos;/page1&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  templateUrl : &amp;apos;view/page1.html&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.state(&amp;apos;page1.main&amp;apos;,&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  url : &amp;apos;/main&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  emplateUrl : &amp;apos;view/page1-main.html&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。&lt;/p&gt;
&lt;h4 id=&quot;多个视图&quot;&gt;&lt;a href=&quot;#多个视图&quot; class=&quot;headerlink&quot; title=&quot;多个视图&quot;&gt;&lt;/a&gt;多个视图&lt;/h4&gt;&lt;p&gt;ui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div ui-view&amp;gt;&amp;lt;/div&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div ui-view=&amp;quot;chart&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div ui-view=&amp;quot;data&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;路由：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider.state(&amp;quot;home&amp;quot;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  views: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;&amp;quot;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      template: &amp;quot;&amp;lt;h1&amp;gt;HELLO!&amp;lt;/h1&amp;gt;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;chart&amp;quot;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      template: &amp;quot;&amp;lt;chart_thing/&amp;gt;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;data&amp;quot;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      template: &amp;quot;&amp;lt;data_thing/&amp;gt;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。&lt;/p&gt;
&lt;h4 id=&quot;原生ng-route的不足之处：&quot;&gt;&lt;a href=&quot;#原生ng-route的不足之处：&quot; class=&quot;headerlink&quot; title=&quot;原生ng-route的不足之处：&quot;&gt;&lt;/a&gt;原生ng-route的不足之处：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;视图不能嵌套。这意味着$scope会发生不必要的重新载入。&lt;/li&gt;
&lt;li&gt;路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;显而易见，ui-router的优势为：&quot;&gt;&lt;a href=&quot;#显而易见，ui-router的优势为：&quot; class=&quot;headerlink&quot; title=&quot;显而易见，ui-router的优势为：&quot;&gt;&lt;/a&gt;显而易见，ui-router的优势为：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;提出了”$state”的概念，通过改变\$state来进行URL的跳转和路由&lt;/li&gt;
&lt;li&gt;将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于ui-router最重要的参考资料是 &lt;a href=&quot;http://angular-ui.github.io/ui-router/site/#/api/ui.router&quot;&gt;ui-router的官方文档&lt;/a&gt;（&lt;a href=&quot;http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。&quot;&gt;http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;p&gt;1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js&lt;/p&gt;
    
    </summary>
    
      <category term="front-end javascript" scheme="http://mechanicianw.github.io/categories/front-end-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>150824去哪儿网面试总结</title>
    <link href="http://mechanicianw.github.io/2015/08/24/intern-qunar-interview/"/>
    <id>http://mechanicianw.github.io/2015/08/24/intern-qunar-interview/</id>
    <published>2015-08-24T14:20:24.000Z</published>
    <updated>2016-06-16T10:45:30.000Z</updated>
    
    <content type="html">&lt;p&gt;1.get()与post()的区别&lt;/p&gt;
&lt;p&gt;Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。&lt;/p&gt;
&lt;p&gt;根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。&lt;/p&gt;
&lt;p&gt;根据HTTP规范，POST表示可能修改变服务器上的资源的请求。&lt;/p&gt;
&lt;p&gt;GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。&lt;/p&gt;
&lt;p&gt;POST的安全性要比GET的安全性高：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。&lt;/p&gt;
&lt;p&gt;2.CSS优先级   &lt;a href=&quot;http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考内容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（外部样式）External style sheet &amp;lt;（内部样式）Internal style sheet &amp;lt;（内联样式）Inline style&lt;/p&gt;
&lt;p&gt;选择器优先权（权重）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内联样式表的权值最高 1000；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ID 选择器的权值为 100&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Class 类选择器的权值为 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTML 标签选择器的权值为 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://www.nowamagic.net/csszone/images/priority_rules_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSS &lt;strong&gt;优先级法则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A  选择器都有一个权值，权值越大越优先；&lt;/p&gt;
&lt;p&gt;B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；&lt;/p&gt;
&lt;p&gt;C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；&lt;/p&gt;
&lt;p&gt;D  继承的CSS 样式不如后来指定的CSS 样式；&lt;/p&gt;
&lt;p&gt;E  在同一组属性设置中标有“!important”规则的优先级最大&lt;/p&gt;
&lt;p&gt;3.一次请求的完整流程&lt;/p&gt;
&lt;p&gt;① 建立TCP连接&lt;/p&gt;
&lt;p&gt;在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。&lt;/p&gt;
&lt;p&gt;② Web浏览器向Web服务器发送请求命令&lt;/p&gt;
&lt;p&gt;一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。&lt;/p&gt;
&lt;p&gt;③ Web浏览器发送请求头信息&lt;/p&gt;
&lt;p&gt;浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。&lt;/p&gt;
&lt;p&gt;④ Web服务器应答&lt;/p&gt;
&lt;p&gt;客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。&lt;/p&gt;
&lt;p&gt;⑤ Web服务器发送应答头信息&lt;/p&gt;
&lt;p&gt;正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。&lt;/p&gt;
&lt;p&gt;⑥ Web服务器向浏览器发送数据&lt;/p&gt;
&lt;p&gt;Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。&lt;/p&gt;
&lt;p&gt;⑦ Web服务器关闭TCP连接&lt;/p&gt;
&lt;p&gt;一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：&lt;/p&gt;
&lt;p&gt;Connection:keep-alive&lt;/p&gt;
&lt;p&gt;TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。&lt;/p&gt;
&lt;p&gt;4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN&lt;/p&gt;
&lt;p&gt;“8”*11=88&lt;/p&gt;
&lt;p&gt;“8a”*11=NaN&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1.get()与post()的区别&lt;/p&gt;
&lt;p&gt;Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。&lt;/p&gt;
&lt;p&gt;根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。&lt;/p&gt;
&lt;p&gt;根据HTTP规范，POST表示可能修改变服务器上的资源的请求。&lt;/p&gt;
&lt;p&gt;GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。&lt;/p&gt;
&lt;p&gt;POST的安全性要比GET的安全性高：&lt;/p&gt;
    
    </summary>
    
      <category term="front-end interview" scheme="http://mechanicianw.github.io/categories/front-end-interview/"/>
    
    
  </entry>
  
  <entry>
    <title>BFC学习笔记</title>
    <link href="http://mechanicianw.github.io/2015/08/20/learning-note-bfc/"/>
    <id>http://mechanicianw.github.io/2015/08/20/learning-note-bfc/</id>
    <published>2015-08-20T02:54:24.000Z</published>
    <updated>2016-06-16T10:45:56.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一.概念&quot;&gt;&lt;/a&gt;一.概念&lt;/h3&gt;&lt;p&gt;在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。&lt;/p&gt;
&lt;h3 id=&quot;二-产生BFC条件：&quot;&gt;&lt;a href=&quot;#二-产生BFC条件：&quot; class=&quot;headerlink&quot; title=&quot;二.产生BFC条件：&quot;&gt;&lt;/a&gt;二.产生BFC条件：&lt;/h3&gt;&lt;p&gt;当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;float的值不为none。&lt;/li&gt;
&lt;li&gt;overflow的值不为visible。&lt;/li&gt;
&lt;li&gt;display的值为table-cell, table-caption, inline-block中的任何一个。&lt;/li&gt;
&lt;li&gt;position的值不为relative和static。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;三-应用&quot;&gt;&lt;a href=&quot;#三-应用&quot; class=&quot;headerlink&quot; title=&quot;三.应用&quot;&gt;&lt;/a&gt;三.应用&lt;/h3&gt;&lt;p&gt;1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。&lt;/p&gt;
&lt;p&gt;2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖&lt;/p&gt;
&lt;p&gt;3）解决上下相邻两个元素重叠&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4）清除元素内部浮动&lt;/p&gt;
&lt;p&gt;只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一.概念&quot;&gt;&lt;/a&gt;一.概念&lt;/h3&gt;&lt;p&gt;在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。&lt;/p&gt;
&lt;h3 id=&quot;二-产生BFC条件：&quot;&gt;&lt;a href=&quot;#二-产生BFC条件：&quot; class=&quot;headerlink&quot; title=&quot;二.产生BFC条件：&quot;&gt;&lt;/a&gt;二.产生BFC条件：&lt;/h3&gt;&lt;p&gt;当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;float的值不为none。&lt;/li&gt;
&lt;li&gt;overflow的值不为visible。&lt;/li&gt;
&lt;li&gt;display的值为table-cell, table-caption, inline-block中的任何一个。&lt;/li&gt;
&lt;li&gt;position的值不为relative和static。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="css" scheme="http://mechanicianw.github.io/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript面向对象的程序设计</title>
    <link href="http://mechanicianw.github.io/2015/08/20/note-learning-javascript-oop/"/>
    <id>http://mechanicianw.github.io/2015/08/20/note-learning-javascript-oop/</id>
    <published>2015-08-19T23:43:50.000Z</published>
    <updated>2016-06-16T10:46:14.000Z</updated>
    
    <content type="html">&lt;p&gt;参考《JavaScript高级程序设计》第三版&lt;/p&gt;
&lt;p&gt;阮一峰&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Javascript 面向对象编程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-创建对象&quot;&gt;&lt;a href=&quot;#一-创建对象&quot; class=&quot;headerlink&quot; title=&quot;一.创建对象&quot;&gt;&lt;/a&gt;一.创建对象&lt;/h2&gt;&lt;h4 id=&quot;1-字面量&quot;&gt;&lt;a href=&quot;#1-字面量&quot; class=&quot;headerlink&quot; title=&quot;1.字面量&quot;&gt;&lt;/a&gt;1.字面量&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var cat1 = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat1.name = &amp;quot;kitty&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat1.color = &amp;quot;white&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat2 = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat2.name = &amp;quot;greg&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat2.color = &amp;quot;black&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;2-工厂模式&quot;&gt;&lt;a href=&quot;#2-工厂模式&quot; class=&quot;headerlink&quot; title=&quot;2.工厂模式&quot;&gt;&lt;/a&gt;2.工厂模式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function creatCat(name,color)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var o = new Object();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;0.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;0.color = color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;return 0 ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat1 = createCat(&amp;quot;kitty&amp;quot;,white);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat2 = createCat(&amp;quot;greg&amp;quot;,black);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决了多个相似对象的问题，但没有解决对象类型识别的问题。&lt;/p&gt;
&lt;h4 id=&quot;3-构造函数模式&quot;&gt;&lt;a href=&quot;#3-构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;3.构造函数模式&quot;&gt;&lt;/a&gt;3.构造函数模式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Cat(name,color)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;this.name=name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;this.color=color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat1 = new  Cat(&amp;quot;kitty&amp;quot;,&amp;quot;white&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat2 = new  Cat(&amp;quot;greg&amp;quot;,&amp;quot;black&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1.name); // kitty&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1.color); // white&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即没有return调用，将属性，方法赋给了&lt;em&gt;this&lt;/em&gt;对象，函数名始终以大写字母开头&lt;/p&gt;
&lt;p&gt;任何函数只要通过new调用，就可以作为构造函数&lt;/p&gt;
&lt;p&gt;这时cat1和cat2会自动含有一个&lt;em&gt;constructor&lt;/em&gt;属性，指向它们的构造函数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1.constructor == Cat); //true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(cat2.constructor == Cat); //true&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1 instanceof Cat); //true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(cat2 instanceof Cat); //true&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;构造函数模式的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造函数方法很好用，但是存在一个浪费内存的问题。&lt;/p&gt;
&lt;p&gt;请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Cat(name,color)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  this.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  this.color = color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  this.type = &amp;quot;猫科动物&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  this.eat = function()&amp;#123;alert(&amp;quot;吃老鼠&amp;quot;);&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还是采用同样的方法，生成实例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var cat1 = new Cat(&amp;quot;kitty&amp;quot;,&amp;quot;white&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat2 = new Cat (&amp;quot;greg&amp;quot;,&amp;quot;black&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1.type); // 猫科动物&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat1.eat(); // 吃老鼠&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。&lt;br&gt; &lt;code&gt;alert(cat1.eat == cat2.eat); //false&lt;/code&gt;&lt;br&gt;能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。&lt;/p&gt;
&lt;h4 id=&quot;3-原型模式（Prototype模式）&quot;&gt;&lt;a href=&quot;#3-原型模式（Prototype模式）&quot; class=&quot;headerlink&quot; title=&quot;3.原型模式（Prototype模式）&quot;&gt;&lt;/a&gt;3.原型模式（Prototype模式）&lt;/h4&gt;&lt;p&gt;每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。&lt;/p&gt;
&lt;p&gt;原型对象可以让所有对象实例共享它所包含的属性和方法。&lt;/p&gt;
&lt;p&gt;我们可以把那些不变的属性和方法，直接定义在prototype对象上。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Cat(name,color)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;this.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;this.color = color;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Cat.prototype.type = &amp;quot;猫科动物&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Cat.prototype.eat = function()&amp;#123;alert(&amp;quot;吃老鼠&amp;quot;)&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，生成实例。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var cat1 = new Cat(&amp;quot;kitty&amp;quot;,&amp;quot;white&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat2 = new Cat(&amp;quot;greg&amp;quot;,&amp;quot;black&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1.type); // 猫科动物&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat1.eat(); // 吃老鼠&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。&lt;br&gt;&lt;code&gt;alert(cat1.eat == cat2.eat); //true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、 Prototype模式的验证方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 isPrototypeOf()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法用来判断，某个proptotype对象和某个实例之间的关系。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;alert(Cat.prototype.isPrototypeOf(cat1)); //true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(Cat.prototype.isPrototypeOf(cat2)); //true&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2 hasOwnProperty()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1.hasOwnProperty(&amp;quot;name&amp;quot;)); // true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(cat1.hasOwnProperty(&amp;quot;type&amp;quot;)); // false&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;3 in运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;alert(&amp;quot;name&amp;quot; in cat1); // true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(&amp;quot;type&amp;quot; in cat1); // true&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;in运算符还可以用来遍历某个对象的所有属性。&lt;br&gt;&lt;code&gt;for(var prop in cat1) { alert(&amp;quot;cat1[&amp;quot;+prop+&amp;quot;]=&amp;quot;+cat1[prop]); }&lt;/code&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;参考《JavaScript高级程序设计》第三版&lt;/p&gt;
&lt;p&gt;阮一峰&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html&quot;&gt;Javascript 面向对象编程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-创建对象&quot;&gt;&lt;a href=&quot;#一-创建对象&quot; class=&quot;headerlink&quot; title=&quot;一.创建对象&quot;&gt;&lt;/a&gt;一.创建对象&lt;/h2&gt;&lt;h4 id=&quot;1-字面量&quot;&gt;&lt;a href=&quot;#1-字面量&quot; class=&quot;headerlink&quot; title=&quot;1.字面量&quot;&gt;&lt;/a&gt;1.字面量&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var cat1 = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat1.name = &amp;quot;kitty&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat1.color = &amp;quot;white&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var cat2 = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat2.name = &amp;quot;greg&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat2.color = &amp;quot;black&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://mechanicianw.github.io/categories/javascript/"/>
    
    
  </entry>
  
</feed>
