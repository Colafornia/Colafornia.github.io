<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> How does data binding work in AngularJS · Minibase</title><meta name="description" content="How does data binding work in AngularJS - Colafornia"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.colafornia.me/atom.xml" title="Minibase"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Colafornia" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">How does data binding work in AngularJS</h1><div class="post-info">Jun 5, 2016</div><div class="post-content"><p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>
<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>
<h3 id="关于-watch"><a href="#关于-watch" class="headerlink" title="关于$watch"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</span><br><span class="line">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p>
<a id="more"></a>
<p>每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。</p>
<p>一个watcher包含了三个东西：</p>
<ul>
<li><p>它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西</p>
</li>
<li><p>这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty</p>
</li>
<li><p>被触发执行的函数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$watchers = [</span><br><span class="line">    &#123;</span><br><span class="line">        eq: false, // 表明我们是否需要检查对象级别的相等</span><br><span class="line">        fn: function( newValue, oldValue ) &#123;&#125;, // 这是我们提供的监听器函数</span><br><span class="line">        last: &apos;Ryan&apos;, // 变量的最新值</span><br><span class="line">        exp: function()&#123;&#125;, // 我们提供的watchExp函数</span><br><span class="line">        get: function()&#123;&#125; // Angular&apos;s编译后的watchExp函数</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>定义监听器的几种方法：<br>1.把$watch设置为$scope的一种属性:<code>$scope.$watch(&#39;person.username&#39;, validateUnique);</code><br>2.插入angular表达式:<code>&lt;p&gt;username: &lt;/p&gt;</code><br>3.使用类似于ng-model的指令来定义监听器:<code>&lt;input ng-model=&quot;person.username /&gt;</code></p>
<h3 id="关于-digest和-apply"><a href="#关于-digest和-apply" class="headerlink" title="关于$digest和$apply"></a>关于$digest和$apply</h3><p>如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。</p>
<p>当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。</p>
<p>AngularJS的$apply函数代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$apply: function(expr) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      beginPhase(&apos;$apply&apos;);</span><br><span class="line">      return this.$eval(expr);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      $exceptionHandler(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      clearPhase();</span><br><span class="line">      try &#123;</span><br><span class="line">        $rootScope.$digest();</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        $exceptionHandler(e);</span><br><span class="line">        throw e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，使用$apply可带参数。</p>
<p>$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。</p>
<p>监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。</p>
<p>$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\$digest仅仅触发当前作用域和子作用域的监控。</p>
<h3 id="build-your-own-dirty-checking"><a href="#build-your-own-dirty-checking" class="headerlink" title="build your own dirty-checking"></a>build your own dirty-checking</h3><p>了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。<br>首先定义Scope，然后扩展这个函数的原型对象来复制\$digest和\$watch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Scope = function( ) &#123;</span><br><span class="line">    this.$$watchers = [];   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$watch = function( ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$digest = function( ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设置\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function( watchExp, listener ) &#123;</span><br><span class="line">    this.$$watchers.push( &#123;</span><br><span class="line">        watchExp: watchExp,</span><br><span class="line">        listener: listener || function() &#123;&#125;</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果没有传入listener的话我们会把它设置为空函数。<br>$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$digest = function( ) &#123;</span><br><span class="line">    var dirty;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">            dirty = false;</span><br><span class="line"></span><br><span class="line">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</span><br><span class="line">                var newValue = this.$$watchers[i].watchExp(),</span><br><span class="line">                    oldValue = this.$$watchers[i].last;</span><br><span class="line"></span><br><span class="line">                if( oldValue !== newValue ) &#123;</span><br><span class="line">                    this.$$watchers[i].listener(newValue, oldValue);</span><br><span class="line"></span><br><span class="line">                    dirty = true;</span><br><span class="line"></span><br><span class="line">                    this.$$watchers[i].last = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; while(dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var $scope = new Scope();</span><br><span class="line"></span><br><span class="line">$scope.name = &apos;Ryan&apos;;</span><br><span class="line"></span><br><span class="line">$scope.$watch(function()&#123;</span><br><span class="line">    return $scope.name;</span><br><span class="line">&#125;, function( newValue, oldValue ) &#123;</span><br><span class="line">    console.log(newValue, oldValue);</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">$scope.$digest();</span><br></pre></td></tr></table></figure>
<p>我们发现在控制台输出了<code>Ryan undefined</code>，成功了！<br>最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">var Scope = function( ) &#123;</span><br><span class="line">    this.$$watchers = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$watch = function( watchExp, listener ) &#123;</span><br><span class="line">    this.$$watchers.push( &#123;</span><br><span class="line">        watchExp: watchExp,</span><br><span class="line">        listener: listener || function() &#123;&#125;</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$digest = function( ) &#123;</span><br><span class="line">    var dirty;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">            dirty = false;</span><br><span class="line"></span><br><span class="line">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</span><br><span class="line">                var newValue = this.$$watchers[i].watchExp(),</span><br><span class="line">                    oldValue = this.$$watchers[i].last;</span><br><span class="line"></span><br><span class="line">                if( oldValue !== newValue ) &#123;</span><br><span class="line">                    this.$$watchers[i].listener(newValue, oldValue);</span><br><span class="line"></span><br><span class="line">                    dirty = true;</span><br><span class="line"></span><br><span class="line">                    this.$$watchers[i].last = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; while(dirty);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var $scope = new Scope();</span><br><span class="line"></span><br><span class="line">$scope.name = &apos;Ryan&apos;;</span><br><span class="line"></span><br><span class="line">var element = document.querySelectorAll(&apos;input&apos;);</span><br><span class="line"></span><br><span class="line">element[0].onkeyup = function() &#123;</span><br><span class="line">    $scope.name = element[0].value;</span><br><span class="line"></span><br><span class="line">    $scope.$digest();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$scope.$watch(function()&#123;</span><br><span class="line">    return $scope.name;</span><br><span class="line">&#125;, function( newValue, oldValue ) &#123;</span><br><span class="line">    console.log(&apos;Input value updated - it is now &apos; + newValue);</span><br><span class="line"></span><br><span class="line">    element[0].value = $scope.name;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">var updateScopeValue = function updateScopeValue( ) &#123;</span><br><span class="line">    $scope.name = &apos;Bob&apos;;</span><br><span class="line">    $scope.$digest();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ul>
<li><a href="https://ryanclark.me/how-angularjs-implements-dirty-checking" target="_blank" rel="noopener">RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves</a></li>
<li><a href="http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs" target="_blank" rel="noopener">stackoverflow:How does data binding work in AngularJS?</a></li>
<li><a href="https://github.com/xufei/blog/issues/10" target="_blank" rel="noopener">徐飞:Angular沉思录（一）</a></li>
<li><a href="http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/" target="_blank" rel="noopener">angular-tips:$watch How the $apply Runs a $digest</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/" target="_blank" rel="noopener">IBM developerWorks:AngularJS 作用域与数据绑定机制</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/post/2016/git-rebase-workflow/" class="prev">上一篇</a><a href="/post/2016/vieport-percentage/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://blog.colafornia.me">Colafornia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-84469017-1",'auto');ga('send','pageview');</script></body></html>