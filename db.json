{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/favicon.jpg","path":"favicon.jpg","modified":0,"renderable":1},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"0cd02038047d0ff74da67f63ee308174bd8d68a0","modified":1468572330000},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1468567413000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1468567413000},{"_id":"themes/apollo/.DS_Store","hash":"24990b74e65a84a1926894112cea8257927354d9","modified":1468573828000},{"_id":"themes/apollo/README.md","hash":"a3e70662d82b7f7dcc76bd57e95389ba67dd52a4","modified":1468567413000},{"_id":"themes/apollo/package.json","hash":"4d13f5f859db7d008f49251543a8f610b2ecabd5","modified":1468567413000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1468567413000},{"_id":"themes/apollo/_config.yml","hash":"aa43e6ffe1f277db80fce64bfccca802e302d39a","modified":1468574017000},{"_id":"source/_posts/.DS_Store","hash":"289c9e2e4c54827d5509e99c2e5f6ae2f4b0372e","modified":1468571847000},{"_id":"source/_posts/2015-08-20-bfc-note.markdown","hash":"f3327f52bc77f6e882efdeba15fa7baada5b509f","modified":1466073956000},{"_id":"source/_posts/2015-08-20-javascript-oop.md","hash":"d1c7755cb277a4c9550453fdcf075a5280e476b9","modified":1466073974000},{"_id":"source/_posts/2015-08-24-qunar-interview.markdown","hash":"6a61a99c29dca1f61b9d37df117a4088148f1380","modified":1466073931000},{"_id":"source/_posts/2015-11-23-angular-uirouter.md","hash":"23c122912323100c1d3b821b7dc808c155834ea0","modified":1466074086000},{"_id":"source/_posts/2015-12-03-html-in-email.md","hash":"6c38a451aaa542df03b9c072ecc706068afc4933","modified":1466074158000},{"_id":"source/_posts/2016-01-02-clouser-scope.md","hash":"39419259185b53ec74e6d46041faed8601d41c5a","modified":1466074200000},{"_id":"source/_posts/2016-03-17-vieport-percentage.md","hash":"d5e1ee205f60c90272e25720a735b8ed38e28b82","modified":1466074215000},{"_id":"source/_posts/2016-03-10-cookie-localstorage-session.md","hash":"4480a7c1a202700b93614566a87416302a4d2530","modified":1466074206000},{"_id":"source/about/index.md","hash":"97fca50532aff31db2d7c3d8a74dc9d1482a02c1","modified":1466954135000},{"_id":"source/about/.DS_Store","hash":"8208a60b8feacf7ffb9395ac09bc39029f5b3898","modified":1468572330000},{"_id":"source/_posts/2016-06-09-rebase-workflow.md","hash":"7288fa6e5a7a93c33ceea4290c33b915857ca120","modified":1466075322000},{"_id":"source/_posts/2016-06-05-angular-data-binding.markdown","hash":"1915d3be5fb6cab0cfd37f2701dae54c2bfb7ca8","modified":1466161669000},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1468567413000},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1468567403000},{"_id":"themes/apollo/.git/index","hash":"e83c2b3e165268bc6c92c42f10b3b79352ec8f86","modified":1468567413000},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1468567413000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1468567413000},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1468567413000},{"_id":"themes/apollo/source/.DS_Store","hash":"b234e087bc9d4ea8a0e2fe90038977d6e5c97af6","modified":1468574121000},{"_id":"themes/apollo/.git/packed-refs","hash":"8de9fd125b7e377e0bc28c0d6c03e6e4d2eec3ca","modified":1468567413000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1468567413000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1468567413000},{"_id":"themes/apollo/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1468567413000},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1468567413000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1468567413000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1468567413000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1468567403000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1468567403000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"cb33a29ae068752a9aeb77791c717249d2b26634","modified":1468567413000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1468567403000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"a3153dfedbaff08c20930b2bde95f2db49f6d518","modified":1468567413000},{"_id":"themes/apollo/source/css/apollo.css","hash":"12e04066b66d5096c513b238870f70284617108c","modified":1468567413000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1468567413000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1468567413000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"1ac04b9dbcff6cc5c1ac8304d5ec86ffeed12183","modified":1468567413000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"c35d3061da4b053b73150d9741c542d660798270","modified":1468567413000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"cf3339de8979b5f75a3011f0f6b5451091b77dc8","modified":1468567413000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"eb15573ff66bdbb110ac77cf360b740170cee738","modified":1468567413000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1468567413000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"d44e17b26873c49fccd72bb1e9f7ffa1c04a850f","modified":1468567413000},{"_id":"themes/apollo/.git/objects/pack/pack-5ea86fc15e2c0310d7dbab9f8c03402f249bc773.idx","hash":"c94e2cfcd524d0bdfcc02b5e5792aa961d2be7c6","modified":1468567413000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"f11c8b2d21f6bf2f1587f105627f2058507958bb","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"f7e3e6f06bb81321673a546d51973a052c6d99b4","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1468567413000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"ae780828148f79e5069b480e3576f1fea1246866","modified":1468567413000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"cb33a29ae068752a9aeb77791c717249d2b26634","modified":1468567413000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1468567413000},{"_id":"themes/apollo/.git/objects/pack/pack-5ea86fc15e2c0310d7dbab9f8c03402f249bc773.pack","hash":"af8f09cb29862ea4638800555d2c5d5bf6d3130c","modified":1468567413000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"cb33a29ae068752a9aeb77791c717249d2b26634","modified":1468567413000},{"_id":"themes/apollo/source/faviconold.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1468567413000},{"_id":"themes/apollo/source/favicon.jpg","hash":"e1d18eb032e8995a28e41d7974e04551d386f3aa","modified":1462788458000}],"Category":[{"name":"css","_id":"ciqni2jzw00029m613vit0qf7"},{"name":"javascript","_id":"ciqni2k1p00059m6105slo5u0"},{"name":"front-end interview","_id":"ciqni2k1s00079m61syv1h6c0"},{"name":"front-end javascript","_id":"ciqni2k1u00099m61zobxn24i"},{"name":"front-end css","_id":"ciqni2k3a000f9m61mjuahtxv"},{"name":"git","_id":"ciqni2k3p000n9m61g9h0720v"}],"Data":[],"Page":[{"title":"about","date":"2015-12-29T10:03:57.000Z","comments":0,"_content":"\n## About me\nweb developer,junior programmer\n\nLat/Long 39.9\"N,116. 3\"E\n\nNow studying EE/Power in BJTU\n\nInterested in Full-Stack,Meachine Learing\n\nHaving a wonderful and firm relationship with closuer\n\n## Contact\n\n- Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t\n- Github: [MechanicianW](https://github.com/MechanicianW)","source":"about/index.md","raw":"---\ntitle: about\ndate: 2015-12-29 18:03:57\ncomments: false\n---\n\n## About me\nweb developer,junior programmer\n\nLat/Long 39.9\"N,116. 3\"E\n\nNow studying EE/Power in BJTU\n\nInterested in Full-Stack,Meachine Learing\n\nHaving a wonderful and firm relationship with closuer\n\n## Contact\n\n- Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t\n- Github: [MechanicianW](https://github.com/MechanicianW)","updated":"2016-06-26T15:15:35.000Z","path":"about/index.html","layout":"page","_id":"ciqni2k2s000d9m61mb4c1hcw","content":"<h2 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h2><p>web developer,junior programmer</p>\n<p>Lat/Long 39.9”N,116. 3”E</p>\n<p>Now studying EE/Power in BJTU</p>\n<p>Interested in Full-Stack,Meachine Learing</p>\n<p>Having a wonderful and firm relationship with closuer</p>\n<h2 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h2><ul>\n<li>Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t</li>\n<li>Github: <a href=\"https://github.com/MechanicianW\" target=\"_blank\" rel=\"external\">MechanicianW</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h2><p>web developer,junior programmer</p>\n<p>Lat/Long 39.9”N,116. 3”E</p>\n<p>Now studying EE/Power in BJTU</p>\n<p>Interested in Full-Stack,Meachine Learing</p>\n<p>Having a wonderful and firm relationship with closuer</p>\n<h2 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h2><ul>\n<li>Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t</li>\n<li>Github: <a href=\"https://github.com/MechanicianW\">MechanicianW</a></li>\n</ul>\n"}],"Post":[{"layout":"post","title":"BFC学习笔记","date":"2015-08-20T02:54:24.000Z","_content":"### 一.概念\n\n在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。\n\n### 二.产生BFC条件：\n\n当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：\n\n*   float的值不为none。\n*   overflow的值不为visible。\n*   display的值为table-cell, table-caption, inline-block中的任何一个。\n*   position的值不为relative和static。\n\n<!--more-->\n\n### 三.应用\n\n1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。\n\n2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖\n\n3）解决上下相邻两个元素重叠\n> 外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。\n\n4）清除元素内部浮动\n\n只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。","source":"_posts/2015-08-20-bfc-note.markdown","raw":"---\nlayout: post\ntitle:  \"BFC学习笔记\"\ndate:   2015-08-20 10:54:24\ncategories: css\n---\n### 一.概念\n\n在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。\n\n### 二.产生BFC条件：\n\n当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：\n\n*   float的值不为none。\n*   overflow的值不为visible。\n*   display的值为table-cell, table-caption, inline-block中的任何一个。\n*   position的值不为relative和static。\n\n<!--more-->\n\n### 三.应用\n\n1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。\n\n2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖\n\n3）解决上下相邻两个元素重叠\n> 外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。\n\n4）清除元素内部浮动\n\n只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。","slug":"2015-08-20-bfc-note","published":1,"updated":"2016-06-16T10:45:56.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2jz200009m61kx1yjznh","content":"<h3 id=\"一-概念\"><a href=\"#一-概念\" class=\"headerlink\" title=\"一.概念\"></a>一.概念</h3><p>在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。</p>\n<h3 id=\"二-产生BFC条件：\"><a href=\"#二-产生BFC条件：\" class=\"headerlink\" title=\"二.产生BFC条件：\"></a>二.产生BFC条件：</h3><p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：</p>\n<ul>\n<li>float的值不为none。</li>\n<li>overflow的值不为visible。</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个。</li>\n<li>position的值不为relative和static。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"三-应用\"><a href=\"#三-应用\" class=\"headerlink\" title=\"三.应用\"></a>三.应用</h3><p>1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。</p>\n<p>2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖</p>\n<p>3）解决上下相邻两个元素重叠</p>\n<blockquote>\n<p>外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。</p>\n</blockquote>\n<p>4）清除元素内部浮动</p>\n<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。</p>\n","excerpt":"<h3 id=\"一-概念\"><a href=\"#一-概念\" class=\"headerlink\" title=\"一.概念\"></a>一.概念</h3><p>在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。</p>\n<h3 id=\"二-产生BFC条件：\"><a href=\"#二-产生BFC条件：\" class=\"headerlink\" title=\"二.产生BFC条件：\"></a>二.产生BFC条件：</h3><p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：</p>\n<ul>\n<li>float的值不为none。</li>\n<li>overflow的值不为visible。</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个。</li>\n<li>position的值不为relative和static。</li>\n</ul>","more":"<h3 id=\"三-应用\"><a href=\"#三-应用\" class=\"headerlink\" title=\"三.应用\"></a>三.应用</h3><p>1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。</p>\n<p>2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖</p>\n<p>3）解决上下相邻两个元素重叠</p>\n<blockquote>\n<p>外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。</p>\n</blockquote>\n<p>4）清除元素内部浮动</p>\n<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。</p>"},{"layout":"post","title":"javascript面向对象的程序设计","date":"2015-08-19T23:43:50.000Z","_content":"参考《JavaScript高级程序设计》第三版\n\n阮一峰[Javascript 面向对象编程](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)\n\n## 一.创建对象\n\n#### 1.字面量\n\n```\nvar cat1 = {\n\ncat1.name = \"kitty\";\n\ncat1.color = \"white\";\n\n};\n\nvar cat2 = {\n\ncat2.name = \"greg\";\n\ncat2.color = \"black\";\n\n};\n```\n\n有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。\n\n<!--more-->\n\n#### 2.工厂模式\n\n```\nfunction creatCat(name,color){\n\nvar o = new Object();\n\n0.name = name;\n\n0.color = color;\n\nreturn 0 ;\n\n}\n\nvar cat1 = createCat(\"kitty\",white);\n\nvar cat2 = createCat(\"greg\",black);\n```\n\n\n解决了多个相似对象的问题，但没有解决对象类型识别的问题。\n\n#### 3.构造函数模式\n\n```\nfunction Cat(name,color){\n\nthis.name=name;\n\nthis.color=color;\n\n}\n\nvar cat1 = new  Cat(\"kitty\",\"white\");\n\nvar cat2 = new  Cat(\"greg\",\"black\");\n\nalert(cat1.name); // kitty\n\nalert(cat1.color); // white\n```\n\n即没有return调用，将属性，方法赋给了_this_对象，函数名始终以大写字母开头\n\n任何函数只要通过new调用，就可以作为构造函数\n\n这时cat1和cat2会自动含有一个_constructor_属性，指向它们的构造函数。\n\n```\nalert(cat1.constructor == Cat); //true\nalert(cat2.constructor == Cat); //true\n```\n\nJavascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。\n\n```\nalert(cat1 instanceof Cat); //true\nalert(cat2 instanceof Cat); //true\n```\n\n**构造函数模式的问题：**\n\n构造函数方法很好用，但是存在一个浪费内存的问题。\n\n请看，我们现在为Cat对象添加一个不变的属性\"type\"（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：\n\n```\n function Cat(name,color){\n   this.name = name;\n   this.color = color;\n   this.type = \"猫科动物\";\n   this.eat = function(){alert(\"吃老鼠\");};\n }\n ```\n\n还是采用同样的方法，生成实例：\n\n```\n var cat1 = new Cat(\"kitty\",\"white\");\n var cat2 = new Cat (\"greg\",\"black\");\n alert(cat1.type); // 猫科动物\n cat1.eat(); // 吃老鼠\n```\n\n表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。\n `alert(cat1.eat == cat2.eat); //false`\n能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。\n\n#### 3.原型模式（Prototype模式）\n\n每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。\n\n原型对象可以让所有对象实例共享它所包含的属性和方法。\n\n我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n\n```\nfunction Cat(name,color){\n\nthis.name = name;\n\nthis.color = color;\n\n}\n\nCat.prototype.type = \"猫科动物\";\n\nCat.prototype.eat = function(){alert(\"吃老鼠\")};\n```\n\n然后，生成实例。\n\n```\nvar cat1 = new Cat(\"kitty\",\"white\");\nvar cat2 = new Cat(\"greg\",\"black\");\nalert(cat1.type); // 猫科动物\ncat1.eat(); // 吃老鼠\n```\n\n这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\n`alert(cat1.eat == cat2.eat); //true`\n\n**二、 Prototype模式的验证方法**\n\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n\n**1 isPrototypeOf()**\n\n这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n\n```\nalert(Cat.prototype.isPrototypeOf(cat1)); //true\nalert(Cat.prototype.isPrototypeOf(cat2)); //true\n```\n\n**2 hasOwnProperty()**\n\n每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false\n\n```\nalert(cat1.hasOwnProperty(\"name\")); // true\nalert(cat1.hasOwnProperty(\"type\")); // false\n```\n\n**3 in运算符**\n\nin运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。\n\n```\nalert(\"name\" in cat1); // true\nalert(\"type\" in cat1); // true\n```\n\nin运算符还可以用来遍历某个对象的所有属性。\n`for(var prop in cat1) { alert(\"cat1[\"+prop+\"]=\"+cat1[prop]); }`","source":"_posts/2015-08-20-javascript-oop.md","raw":"---\nlayout: post\ntitle:  \"javascript面向对象的程序设计\"\ndate:   2015-08-20 7:43:50\ncategories: javascript\n---\n参考《JavaScript高级程序设计》第三版\n\n阮一峰[Javascript 面向对象编程](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)\n\n## 一.创建对象\n\n#### 1.字面量\n\n```\nvar cat1 = {\n\ncat1.name = \"kitty\";\n\ncat1.color = \"white\";\n\n};\n\nvar cat2 = {\n\ncat2.name = \"greg\";\n\ncat2.color = \"black\";\n\n};\n```\n\n有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。\n\n<!--more-->\n\n#### 2.工厂模式\n\n```\nfunction creatCat(name,color){\n\nvar o = new Object();\n\n0.name = name;\n\n0.color = color;\n\nreturn 0 ;\n\n}\n\nvar cat1 = createCat(\"kitty\",white);\n\nvar cat2 = createCat(\"greg\",black);\n```\n\n\n解决了多个相似对象的问题，但没有解决对象类型识别的问题。\n\n#### 3.构造函数模式\n\n```\nfunction Cat(name,color){\n\nthis.name=name;\n\nthis.color=color;\n\n}\n\nvar cat1 = new  Cat(\"kitty\",\"white\");\n\nvar cat2 = new  Cat(\"greg\",\"black\");\n\nalert(cat1.name); // kitty\n\nalert(cat1.color); // white\n```\n\n即没有return调用，将属性，方法赋给了_this_对象，函数名始终以大写字母开头\n\n任何函数只要通过new调用，就可以作为构造函数\n\n这时cat1和cat2会自动含有一个_constructor_属性，指向它们的构造函数。\n\n```\nalert(cat1.constructor == Cat); //true\nalert(cat2.constructor == Cat); //true\n```\n\nJavascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。\n\n```\nalert(cat1 instanceof Cat); //true\nalert(cat2 instanceof Cat); //true\n```\n\n**构造函数模式的问题：**\n\n构造函数方法很好用，但是存在一个浪费内存的问题。\n\n请看，我们现在为Cat对象添加一个不变的属性\"type\"（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：\n\n```\n function Cat(name,color){\n   this.name = name;\n   this.color = color;\n   this.type = \"猫科动物\";\n   this.eat = function(){alert(\"吃老鼠\");};\n }\n ```\n\n还是采用同样的方法，生成实例：\n\n```\n var cat1 = new Cat(\"kitty\",\"white\");\n var cat2 = new Cat (\"greg\",\"black\");\n alert(cat1.type); // 猫科动物\n cat1.eat(); // 吃老鼠\n```\n\n表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。\n `alert(cat1.eat == cat2.eat); //false`\n能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。\n\n#### 3.原型模式（Prototype模式）\n\n每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。\n\n原型对象可以让所有对象实例共享它所包含的属性和方法。\n\n我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n\n```\nfunction Cat(name,color){\n\nthis.name = name;\n\nthis.color = color;\n\n}\n\nCat.prototype.type = \"猫科动物\";\n\nCat.prototype.eat = function(){alert(\"吃老鼠\")};\n```\n\n然后，生成实例。\n\n```\nvar cat1 = new Cat(\"kitty\",\"white\");\nvar cat2 = new Cat(\"greg\",\"black\");\nalert(cat1.type); // 猫科动物\ncat1.eat(); // 吃老鼠\n```\n\n这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\n`alert(cat1.eat == cat2.eat); //true`\n\n**二、 Prototype模式的验证方法**\n\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n\n**1 isPrototypeOf()**\n\n这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n\n```\nalert(Cat.prototype.isPrototypeOf(cat1)); //true\nalert(Cat.prototype.isPrototypeOf(cat2)); //true\n```\n\n**2 hasOwnProperty()**\n\n每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false\n\n```\nalert(cat1.hasOwnProperty(\"name\")); // true\nalert(cat1.hasOwnProperty(\"type\")); // false\n```\n\n**3 in运算符**\n\nin运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。\n\n```\nalert(\"name\" in cat1); // true\nalert(\"type\" in cat1); // true\n```\n\nin运算符还可以用来遍历某个对象的所有属性。\n`for(var prop in cat1) { alert(\"cat1[\"+prop+\"]=\"+cat1[prop]); }`","slug":"2015-08-20-javascript-oop","published":1,"updated":"2016-06-16T10:46:14.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2jzi00019m61wkwba3uu","content":"<p>参考《JavaScript高级程序设计》第三版</p>\n<p>阮一峰<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\" target=\"_blank\" rel=\"external\">Javascript 面向对象编程</a></p>\n<h2 id=\"一-创建对象\"><a href=\"#一-创建对象\" class=\"headerlink\" title=\"一.创建对象\"></a>一.创建对象</h2><h4 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1.字面量\"></a>1.字面量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat1.name = &quot;kitty&quot;;</div><div class=\"line\"></div><div class=\"line\">cat1.color = &quot;white&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var cat2 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat2.name = &quot;greg&quot;;</div><div class=\"line\"></div><div class=\"line\">cat2.color = &quot;black&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>\n<a id=\"more\"></a>\n<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2.工厂模式\"></a>2.工厂模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function creatCat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">var o = new Object();</div><div class=\"line\"></div><div class=\"line\">0.name = name;</div><div class=\"line\"></div><div class=\"line\">0.color = color;</div><div class=\"line\"></div><div class=\"line\">return 0 ;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = createCat(&quot;kitty&quot;,white);</div><div class=\"line\"></div><div class=\"line\">var cat2 = createCat(&quot;greg&quot;,black);</div></pre></td></tr></table></figure>\n<p>解决了多个相似对象的问题，但没有解决对象类型识别的问题。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3.构造函数模式\"></a>3.构造函数模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name=name;</div><div class=\"line\"></div><div class=\"line\">this.color=color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = new  Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\"></div><div class=\"line\">var cat2 = new  Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\"></div><div class=\"line\">alert(cat1.name); // kitty</div><div class=\"line\"></div><div class=\"line\">alert(cat1.color); // white</div></pre></td></tr></table></figure>\n<p>即没有return调用，将属性，方法赋给了<em>this</em>对象，函数名始终以大写字母开头</p>\n<p>任何函数只要通过new调用，就可以作为构造函数</p>\n<p>这时cat1和cat2会自动含有一个<em>constructor</em>属性，指向它们的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.constructor == Cat); //true</div><div class=\"line\">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure>\n<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1 instanceof Cat); //true</div><div class=\"line\">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure>\n<p><strong>构造函数模式的问题：</strong></p>\n<p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>\n<p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.color = color;</div><div class=\"line\">  this.type = &quot;猫科动物&quot;;</div><div class=\"line\">  this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是采用同样的方法，生成实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat (&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。<br> <code>alert(cat1.eat == cat2.eat); //false</code><br>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>\n<h4 id=\"3-原型模式（Prototype模式）\"><a href=\"#3-原型模式（Prototype模式）\" class=\"headerlink\" title=\"3.原型模式（Prototype模式）\"></a>3.原型模式（Prototype模式）</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>\n<p>原型对象可以让所有对象实例共享它所包含的属性和方法。</p>\n<p>我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name = name;</div><div class=\"line\"></div><div class=\"line\">this.color = color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.type = &quot;猫科动物&quot;;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure>\n<p>然后，生成实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。<br><code>alert(cat1.eat == cat2.eat); //true</code></p>\n<p><strong>二、 Prototype模式的验证方法</strong></p>\n<p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>\n<p><strong>1 isPrototypeOf()</strong></p>\n<p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure>\n<p><strong>2 hasOwnProperty()</strong></p>\n<p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class=\"line\">alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</div></pre></td></tr></table></figure>\n<p><strong>3 in运算符</strong></p>\n<p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(&quot;name&quot; in cat1); // true</div><div class=\"line\">alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure>\n<p>in运算符还可以用来遍历某个对象的所有属性。<br><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }</code></p>\n","excerpt":"<p>参考《JavaScript高级程序设计》第三版</p>\n<p>阮一峰<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\">Javascript 面向对象编程</a></p>\n<h2 id=\"一-创建对象\"><a href=\"#一-创建对象\" class=\"headerlink\" title=\"一.创建对象\"></a>一.创建对象</h2><h4 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1.字面量\"></a>1.字面量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat1.name = &quot;kitty&quot;;</div><div class=\"line\"></div><div class=\"line\">cat1.color = &quot;white&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var cat2 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat2.name = &quot;greg&quot;;</div><div class=\"line\"></div><div class=\"line\">cat2.color = &quot;black&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>","more":"<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2.工厂模式\"></a>2.工厂模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function creatCat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">var o = new Object();</div><div class=\"line\"></div><div class=\"line\">0.name = name;</div><div class=\"line\"></div><div class=\"line\">0.color = color;</div><div class=\"line\"></div><div class=\"line\">return 0 ;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = createCat(&quot;kitty&quot;,white);</div><div class=\"line\"></div><div class=\"line\">var cat2 = createCat(&quot;greg&quot;,black);</div></pre></td></tr></table></figure>\n<p>解决了多个相似对象的问题，但没有解决对象类型识别的问题。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3.构造函数模式\"></a>3.构造函数模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name=name;</div><div class=\"line\"></div><div class=\"line\">this.color=color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = new  Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\"></div><div class=\"line\">var cat2 = new  Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\"></div><div class=\"line\">alert(cat1.name); // kitty</div><div class=\"line\"></div><div class=\"line\">alert(cat1.color); // white</div></pre></td></tr></table></figure>\n<p>即没有return调用，将属性，方法赋给了<em>this</em>对象，函数名始终以大写字母开头</p>\n<p>任何函数只要通过new调用，就可以作为构造函数</p>\n<p>这时cat1和cat2会自动含有一个<em>constructor</em>属性，指向它们的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.constructor == Cat); //true</div><div class=\"line\">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure>\n<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1 instanceof Cat); //true</div><div class=\"line\">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure>\n<p><strong>构造函数模式的问题：</strong></p>\n<p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>\n<p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.color = color;</div><div class=\"line\">  this.type = &quot;猫科动物&quot;;</div><div class=\"line\">  this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是采用同样的方法，生成实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat (&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。<br> <code>alert(cat1.eat == cat2.eat); //false</code><br>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>\n<h4 id=\"3-原型模式（Prototype模式）\"><a href=\"#3-原型模式（Prototype模式）\" class=\"headerlink\" title=\"3.原型模式（Prototype模式）\"></a>3.原型模式（Prototype模式）</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>\n<p>原型对象可以让所有对象实例共享它所包含的属性和方法。</p>\n<p>我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name = name;</div><div class=\"line\"></div><div class=\"line\">this.color = color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.type = &quot;猫科动物&quot;;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure>\n<p>然后，生成实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。<br><code>alert(cat1.eat == cat2.eat); //true</code></p>\n<p><strong>二、 Prototype模式的验证方法</strong></p>\n<p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>\n<p><strong>1 isPrototypeOf()</strong></p>\n<p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure>\n<p><strong>2 hasOwnProperty()</strong></p>\n<p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class=\"line\">alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</div></pre></td></tr></table></figure>\n<p><strong>3 in运算符</strong></p>\n<p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(&quot;name&quot; in cat1); // true</div><div class=\"line\">alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure>\n<p>in运算符还可以用来遍历某个对象的所有属性。<br><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }</code></p>"},{"layout":"post","title":"150824去哪儿网面试总结","date":"2015-08-24T14:20:24.000Z","_content":"1.get()与post()的区别\n\nHttp定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。\n\n根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。\n\n根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\nGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。\n\nPOST的安全性要比GET的安全性高：\n\n<!--more-->\n\n通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n2.CSS优先级   [参考内容](http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html)\n\n（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style\n\n选择器优先权（权重）：\n\n1.  内联样式表的权值最高 1000；\n\n2.  ID 选择器的权值为 100\n\n3.  Class 类选择器的权值为 10\n\n4.  HTML 标签选择器的权值为 1\n\n![](http://www.nowamagic.net/csszone/images/priority_rules_1.jpg)\n\nCSS **优先级法则：**\n\nA  选择器都有一个权值，权值越大越优先；\n\nB  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；\n\nC  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；\n\nD  继承的CSS 样式不如后来指定的CSS 样式；\n\nE  在同一组属性设置中标有“!important”规则的优先级最大\n\n3.一次请求的完整流程\n\n① 建立TCP连接\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n② Web浏览器向Web服务器发送请求命令\n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n③ Web浏览器发送请求头信息\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n④ Web服务器应答\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n⑤ Web服务器发送应答头信息\n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n⑥ Web服务器向浏览器发送数据\n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n⑦ Web服务器关闭TCP连接\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN\n\n“8”*11=88\n\n“8a”*11=NaN","source":"_posts/2015-08-24-qunar-interview.markdown","raw":"---\nlayout: post\ntitle:  \"150824去哪儿网面试总结\"\ndate:   2015-08-24 22:20:24\ncategories: front-end interview\n---\n1.get()与post()的区别\n\nHttp定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。\n\n根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。\n\n根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\nGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。\n\nPOST的安全性要比GET的安全性高：\n\n<!--more-->\n\n通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n2.CSS优先级   [参考内容](http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html)\n\n（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style\n\n选择器优先权（权重）：\n\n1.  内联样式表的权值最高 1000；\n\n2.  ID 选择器的权值为 100\n\n3.  Class 类选择器的权值为 10\n\n4.  HTML 标签选择器的权值为 1\n\n![](http://www.nowamagic.net/csszone/images/priority_rules_1.jpg)\n\nCSS **优先级法则：**\n\nA  选择器都有一个权值，权值越大越优先；\n\nB  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；\n\nC  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；\n\nD  继承的CSS 样式不如后来指定的CSS 样式；\n\nE  在同一组属性设置中标有“!important”规则的优先级最大\n\n3.一次请求的完整流程\n\n① 建立TCP连接\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n② Web浏览器向Web服务器发送请求命令\n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n③ Web浏览器发送请求头信息\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n④ Web服务器应答\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n⑤ Web服务器发送应答头信息\n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n⑥ Web服务器向浏览器发送数据\n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n⑦ Web服务器关闭TCP连接\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN\n\n“8”*11=88\n\n“8a”*11=NaN","slug":"2015-08-24-qunar-interview","published":1,"updated":"2016-06-16T10:45:31.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k0700039m61l1l0f8fi","content":"<p>1.get()与post()的区别</p>\n<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>\n<p>根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。</p>\n<p>根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。</p>\n<p>POST的安全性要比GET的安全性高：</p>\n<a id=\"more\"></a>\n<p>通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n<p>2.CSS优先级   <a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\" target=\"_blank\" rel=\"external\">参考内容</a></p>\n<p>（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style</p>\n<p>选择器优先权（权重）：</p>\n<ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<p><img src=\"http://www.nowamagic.net/csszone/images/priority_rules_1.jpg\" alt=\"\"></p>\n<p>CSS <strong>优先级法则：</strong></p>\n<p>A  选择器都有一个权值，权值越大越优先；</p>\n<p>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p>\n<p>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p>\n<p>D  继承的CSS 样式不如后来指定的CSS 样式；</p>\n<p>E  在同一组属性设置中标有“!important”规则的优先级最大</p>\n<p>3.一次请求的完整流程</p>\n<p>① 建立TCP连接</p>\n<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p>② Web浏览器向Web服务器发送请求命令</p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p>③ Web浏览器发送请求头信息</p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>④ Web服务器应答</p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p>⑤ Web服务器发送应答头信息</p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<p>⑥ Web服务器向浏览器发送数据</p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p>⑦ Web服务器关闭TCP连接</p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p>4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN</p>\n<p>“8”*11=88</p>\n<p>“8a”*11=NaN</p>\n","excerpt":"<p>1.get()与post()的区别</p>\n<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>\n<p>根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。</p>\n<p>根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。</p>\n<p>POST的安全性要比GET的安全性高：</p>","more":"<p>通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n<p>2.CSS优先级   <a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\">参考内容</a></p>\n<p>（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style</p>\n<p>选择器优先权（权重）：</p>\n<ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<p><img src=\"http://www.nowamagic.net/csszone/images/priority_rules_1.jpg\" alt=\"\"></p>\n<p>CSS <strong>优先级法则：</strong></p>\n<p>A  选择器都有一个权值，权值越大越优先；</p>\n<p>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p>\n<p>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p>\n<p>D  继承的CSS 样式不如后来指定的CSS 样式；</p>\n<p>E  在同一组属性设置中标有“!important”规则的优先级最大</p>\n<p>3.一次请求的完整流程</p>\n<p>① 建立TCP连接</p>\n<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p>② Web浏览器向Web服务器发送请求命令</p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p>③ Web浏览器发送请求头信息</p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>④ Web服务器应答</p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p>⑤ Web服务器发送应答头信息</p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<p>⑥ Web服务器向浏览器发送数据</p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p>⑦ Web服务器关闭TCP连接</p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p>4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN</p>\n<p>“8”*11=88</p>\n<p>“8a”*11=NaN</p>"},{"layout":"post","title":"Angular  ui-router","date":"2015-11-23T12:17:00.000Z","_content":"UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。\n\n#### 原生ng-route的不足之处：\n\n- 视图不能嵌套。这意味着$scope会发生不必要的重新载入。\n- 路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。\n\n#### 显而易见，ui-router的优势为：\n\n- 提出了\"$state\"的概念，通过改变\\$state来进行URL的跳转和路由\n- 将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置\n\n> 关于ui-router最重要的参考资料是 [ui-router的官方文档](http://angular-ui.github.io/ui-router/site/#/api/ui.router)（http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\n\n#### 代码实现\n\n1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js\n\n<!--more-->\n\n```\n <script src=\"js/angular.js\"></script>\n  <!-- Include the ui-router script -->\n  <script src=\"js/angular-ui-router.min.js\"></script>\n```\n\n2.在模块中引入依赖\n\n```\n  var app = angular.module('routerApp', ['ui.router']);\n```\n\n3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template\n4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。\n5.最后我们来新建一个js文件用来配置路由。\n\n#### 配置路由\n\n示例：\n\n```\napp.config(function ($stateProvider, $urlRouterProvider) {\n  $urlRouterProvider.when(\"\", \"/page1\");\n\t$stateProvider\n    .state('page1', {\n      url: '/page1',\n      templateUrl:'viewpage1.html',\n    }).state('page2', {\n      url: '/page2',\n      templateUrl:'view/page2.html',\n      })\n})\n```\n\n在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。\n\n- state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。\n- 第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。\n-第三个参数是用来设置模板，有两种方法。第一种使用\"template\"，指定一段Html字符串。第二种方法是像示例路由中那样，使用\"templateUrl\"来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）\n\n```\n$stateProvider.state('contacts', {\n  templateUrl: function (stateParams){\n    return '/partials/contacts.' + stateParams + '.html';\n  }\n})\n```\n\n#### 触发激活\n\n路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。\n比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）\n除了上面这种方法，我们还有两种方法来更新视图。\n\n- 调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。\n\n```\n$state.go('page1');  // 指定状态名\n$state.go('page1l', {pageId: 15});  //含参， 相当于跳转到 /page1/42\n```\n\n- 在浏览器地址栏中直接输入url，这是最直接的方法。\n\n#### 传递参数\n\n先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。\n从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html\n在view/resemeList.html中，我们写入如下一行：\n\n```\n<a href=\"\" ui-sref=\"openResume({resumeId:7})\">王大锤的简历</a>\n```\n\n然后，配置路由是这样的：\n\n```\nstate('openResume', {\n        url: '/openResume/{resumeId}',\n        templateUrl:function($stateParams){\n            console.log($stateParams);\n            return 'view/openResume.html'\n        }\n    })\n```\n我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：\n![](http://o7ts2uaks.bkt.clouddn.com/001.png)\n\n在控制台中我们看到了console出的语句\n![控制台](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png)\n\n说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~\n\n#### 嵌套视图\n\n接下来我们来了解一下ui-router区别于ng-router最强大的功能，**嵌套视图**。\n在示例路由的基础上，我们新建一个文件page1-main.html\n现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a>\n在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a>\n路由变成：\n\n```\n.state('page1',{\n  url : '/page1',\n  templateUrl : 'view/page1.html'\n})\n.state('page1.main',{\n  url : '/main',\n  emplateUrl : 'view/page1-main.html'\n})\n```\n\n这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。\n\n#### 多个视图\n\nui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。\n\n```\n<div ui-view></div>\n<div ui-view=\"chart\"></div> \n<div ui-view=\"data\"></div>\n```\n\n路由：\n\n```\n$stateProvider.state(\"home\", {\n  views: {\n    \"\": {\n      template: \"<h1>HELLO!</h1>\"\n    },\n    \"chart\": {\n      template: \"<chart_thing/>\"\n    },\n    \"data\": {\n      template: \"<data_thing/>\"\n    }\n  }\n})\n```","source":"_posts/2015-11-23-angular-uirouter.md","raw":"---\nlayout: post\ntitle:  \"Angular  ui-router\"\ndate:   2015-11-23 20:17\ncategories: front-end javascript\n---\nUI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。\n\n#### 原生ng-route的不足之处：\n\n- 视图不能嵌套。这意味着$scope会发生不必要的重新载入。\n- 路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。\n\n#### 显而易见，ui-router的优势为：\n\n- 提出了\"$state\"的概念，通过改变\\$state来进行URL的跳转和路由\n- 将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置\n\n> 关于ui-router最重要的参考资料是 [ui-router的官方文档](http://angular-ui.github.io/ui-router/site/#/api/ui.router)（http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\n\n#### 代码实现\n\n1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js\n\n<!--more-->\n\n```\n <script src=\"js/angular.js\"></script>\n  <!-- Include the ui-router script -->\n  <script src=\"js/angular-ui-router.min.js\"></script>\n```\n\n2.在模块中引入依赖\n\n```\n  var app = angular.module('routerApp', ['ui.router']);\n```\n\n3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template\n4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。\n5.最后我们来新建一个js文件用来配置路由。\n\n#### 配置路由\n\n示例：\n\n```\napp.config(function ($stateProvider, $urlRouterProvider) {\n  $urlRouterProvider.when(\"\", \"/page1\");\n\t$stateProvider\n    .state('page1', {\n      url: '/page1',\n      templateUrl:'viewpage1.html',\n    }).state('page2', {\n      url: '/page2',\n      templateUrl:'view/page2.html',\n      })\n})\n```\n\n在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。\n\n- state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。\n- 第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。\n-第三个参数是用来设置模板，有两种方法。第一种使用\"template\"，指定一段Html字符串。第二种方法是像示例路由中那样，使用\"templateUrl\"来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）\n\n```\n$stateProvider.state('contacts', {\n  templateUrl: function (stateParams){\n    return '/partials/contacts.' + stateParams + '.html';\n  }\n})\n```\n\n#### 触发激活\n\n路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。\n比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）\n除了上面这种方法，我们还有两种方法来更新视图。\n\n- 调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。\n\n```\n$state.go('page1');  // 指定状态名\n$state.go('page1l', {pageId: 15});  //含参， 相当于跳转到 /page1/42\n```\n\n- 在浏览器地址栏中直接输入url，这是最直接的方法。\n\n#### 传递参数\n\n先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。\n从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html\n在view/resemeList.html中，我们写入如下一行：\n\n```\n<a href=\"\" ui-sref=\"openResume({resumeId:7})\">王大锤的简历</a>\n```\n\n然后，配置路由是这样的：\n\n```\nstate('openResume', {\n        url: '/openResume/{resumeId}',\n        templateUrl:function($stateParams){\n            console.log($stateParams);\n            return 'view/openResume.html'\n        }\n    })\n```\n我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：\n![](http://o7ts2uaks.bkt.clouddn.com/001.png)\n\n在控制台中我们看到了console出的语句\n![控制台](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png)\n\n说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~\n\n#### 嵌套视图\n\n接下来我们来了解一下ui-router区别于ng-router最强大的功能，**嵌套视图**。\n在示例路由的基础上，我们新建一个文件page1-main.html\n现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a>\n在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a>\n路由变成：\n\n```\n.state('page1',{\n  url : '/page1',\n  templateUrl : 'view/page1.html'\n})\n.state('page1.main',{\n  url : '/main',\n  emplateUrl : 'view/page1-main.html'\n})\n```\n\n这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。\n\n#### 多个视图\n\nui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。\n\n```\n<div ui-view></div>\n<div ui-view=\"chart\"></div> \n<div ui-view=\"data\"></div>\n```\n\n路由：\n\n```\n$stateProvider.state(\"home\", {\n  views: {\n    \"\": {\n      template: \"<h1>HELLO!</h1>\"\n    },\n    \"chart\": {\n      template: \"<chart_thing/>\"\n    },\n    \"data\": {\n      template: \"<data_thing/>\"\n    }\n  }\n})\n```","slug":"2015-11-23-angular-uirouter","published":1,"updated":"2016-06-16T10:48:06.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k1800049m61y9p884wj","content":"<p>UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。</p>\n<h4 id=\"原生ng-route的不足之处：\"><a href=\"#原生ng-route的不足之处：\" class=\"headerlink\" title=\"原生ng-route的不足之处：\"></a>原生ng-route的不足之处：</h4><ul>\n<li>视图不能嵌套。这意味着$scope会发生不必要的重新载入。</li>\n<li>路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。</li>\n</ul>\n<h4 id=\"显而易见，ui-router的优势为：\"><a href=\"#显而易见，ui-router的优势为：\" class=\"headerlink\" title=\"显而易见，ui-router的优势为：\"></a>显而易见，ui-router的优势为：</h4><ul>\n<li>提出了”$state”的概念，通过改变\\$state来进行URL的跳转和路由</li>\n<li>将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置</li>\n</ul>\n<blockquote>\n<p>关于ui-router最重要的参考资料是 <a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router\" target=\"_blank\" rel=\"external\">ui-router的官方文档</a>（<a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\" target=\"_blank\" rel=\"external\">http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。</a></p>\n</blockquote>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"> &lt;!-- Include the ui-router script --&gt;</div><div class=\"line\"> &lt;script src=&quot;js/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>2.在模块中引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;routerApp&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure>\n<p>3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template<br>4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。<br>5.最后我们来新建一个js文件用来配置路由。</p>\n<h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config(function ($stateProvider, $urlRouterProvider) &#123;</div><div class=\"line\">  $urlRouterProvider.when(&quot;&quot;, &quot;/page1&quot;);</div><div class=\"line\">\t$stateProvider</div><div class=\"line\">    .state(&apos;page1&apos;, &#123;</div><div class=\"line\">      url: &apos;/page1&apos;,</div><div class=\"line\">      templateUrl:&apos;viewpage1.html&apos;,</div><div class=\"line\">    &#125;).state(&apos;page2&apos;, &#123;</div><div class=\"line\">      url: &apos;/page2&apos;,</div><div class=\"line\">      templateUrl:&apos;view/page2.html&apos;,</div><div class=\"line\">      &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。</p>\n<ul>\n<li>state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。</li>\n<li>第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。<br>-第三个参数是用来设置模板，有两种方法。第一种使用”template”，指定一段Html字符串。第二种方法是像示例路由中那样，使用”templateUrl”来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;</div><div class=\"line\">  templateUrl: function (stateParams)&#123;</div><div class=\"line\">    return &apos;/partials/contacts.&apos; + stateParams + &apos;.html&apos;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"触发激活\"><a href=\"#触发激活\" class=\"headerlink\" title=\"触发激活\"></a>触发激活</h4><p>路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。<br>比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）<br>除了上面这种方法，我们还有两种方法来更新视图。</p>\n<ul>\n<li>调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$state.go(&apos;page1&apos;);  // 指定状态名</div><div class=\"line\">$state.go(&apos;page1l&apos;, &#123;pageId: 15&#125;);  //含参， 相当于跳转到 /page1/42</div></pre></td></tr></table></figure>\n<ul>\n<li>在浏览器地址栏中直接输入url，这是最直接的方法。</li>\n</ul>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。<br>从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html<br>在view/resemeList.html中，我们写入如下一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;&quot; ui-sref=&quot;openResume(&#123;resumeId:7&#125;)&quot;&gt;王大锤的简历&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>然后，配置路由是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">state(&apos;openResume&apos;, &#123;</div><div class=\"line\">        url: &apos;/openResume/&#123;resumeId&#125;&apos;,</div><div class=\"line\">        templateUrl:function($stateParams)&#123;</div><div class=\"line\">            console.log($stateParams);</div><div class=\"line\">            return &apos;view/openResume.html&apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/001.png\" alt=\"\"></p>\n<p>在控制台中我们看到了console出的语句<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png\" alt=\"控制台\"></p>\n<p>说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p>接下来我们来了解一下ui-router区别于ng-router最强大的功能，<strong>嵌套视图</strong>。<br>在示例路由的基础上，我们新建一个文件page1-main.html<br>现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a><br>在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a><br>路由变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.state(&apos;page1&apos;,&#123;</div><div class=\"line\">  url : &apos;/page1&apos;,</div><div class=\"line\">  templateUrl : &apos;view/page1.html&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">.state(&apos;page1.main&apos;,&#123;</div><div class=\"line\">  url : &apos;/main&apos;,</div><div class=\"line\">  emplateUrl : &apos;view/page1-main.html&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。</p>\n<h4 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h4><p>ui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ui-view&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div ui-view=&quot;chart&quot;&gt;&lt;/div&gt; </div><div class=\"line\">&lt;div ui-view=&quot;data&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&quot;home&quot;, &#123;</div><div class=\"line\">  views: &#123;</div><div class=\"line\">    &quot;&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;h1&gt;HELLO!&lt;/h1&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;chart&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;chart_thing/&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;data&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;data_thing/&gt;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>","excerpt":"<p>UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。</p>\n<h4 id=\"原生ng-route的不足之处：\"><a href=\"#原生ng-route的不足之处：\" class=\"headerlink\" title=\"原生ng-route的不足之处：\"></a>原生ng-route的不足之处：</h4><ul>\n<li>视图不能嵌套。这意味着$scope会发生不必要的重新载入。</li>\n<li>路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。</li>\n</ul>\n<h4 id=\"显而易见，ui-router的优势为：\"><a href=\"#显而易见，ui-router的优势为：\" class=\"headerlink\" title=\"显而易见，ui-router的优势为：\"></a>显而易见，ui-router的优势为：</h4><ul>\n<li>提出了”$state”的概念，通过改变\\$state来进行URL的跳转和路由</li>\n<li>将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置</li>\n</ul>\n<blockquote>\n<p>关于ui-router最重要的参考资料是 <a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router\">ui-router的官方文档</a>（<a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\">http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。</a></p>\n</blockquote>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"> &lt;!-- Include the ui-router script --&gt;</div><div class=\"line\"> &lt;script src=&quot;js/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>2.在模块中引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;routerApp&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure>\n<p>3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template<br>4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。<br>5.最后我们来新建一个js文件用来配置路由。</p>\n<h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config(function ($stateProvider, $urlRouterProvider) &#123;</div><div class=\"line\">  $urlRouterProvider.when(&quot;&quot;, &quot;/page1&quot;);</div><div class=\"line\">\t$stateProvider</div><div class=\"line\">    .state(&apos;page1&apos;, &#123;</div><div class=\"line\">      url: &apos;/page1&apos;,</div><div class=\"line\">      templateUrl:&apos;viewpage1.html&apos;,</div><div class=\"line\">    &#125;).state(&apos;page2&apos;, &#123;</div><div class=\"line\">      url: &apos;/page2&apos;,</div><div class=\"line\">      templateUrl:&apos;view/page2.html&apos;,</div><div class=\"line\">      &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。</p>\n<ul>\n<li>state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。</li>\n<li>第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。<br>-第三个参数是用来设置模板，有两种方法。第一种使用”template”，指定一段Html字符串。第二种方法是像示例路由中那样，使用”templateUrl”来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;</div><div class=\"line\">  templateUrl: function (stateParams)&#123;</div><div class=\"line\">    return &apos;/partials/contacts.&apos; + stateParams + &apos;.html&apos;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"触发激活\"><a href=\"#触发激活\" class=\"headerlink\" title=\"触发激活\"></a>触发激活</h4><p>路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。<br>比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）<br>除了上面这种方法，我们还有两种方法来更新视图。</p>\n<ul>\n<li>调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$state.go(&apos;page1&apos;);  // 指定状态名</div><div class=\"line\">$state.go(&apos;page1l&apos;, &#123;pageId: 15&#125;);  //含参， 相当于跳转到 /page1/42</div></pre></td></tr></table></figure>\n<ul>\n<li>在浏览器地址栏中直接输入url，这是最直接的方法。</li>\n</ul>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。<br>从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html<br>在view/resemeList.html中，我们写入如下一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;&quot; ui-sref=&quot;openResume(&#123;resumeId:7&#125;)&quot;&gt;王大锤的简历&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>然后，配置路由是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">state(&apos;openResume&apos;, &#123;</div><div class=\"line\">        url: &apos;/openResume/&#123;resumeId&#125;&apos;,</div><div class=\"line\">        templateUrl:function($stateParams)&#123;</div><div class=\"line\">            console.log($stateParams);</div><div class=\"line\">            return &apos;view/openResume.html&apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/001.png\" alt=\"\"></p>\n<p>在控制台中我们看到了console出的语句<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png\" alt=\"控制台\"></p>\n<p>说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p>接下来我们来了解一下ui-router区别于ng-router最强大的功能，<strong>嵌套视图</strong>。<br>在示例路由的基础上，我们新建一个文件page1-main.html<br>现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a><br>在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a><br>路由变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.state(&apos;page1&apos;,&#123;</div><div class=\"line\">  url : &apos;/page1&apos;,</div><div class=\"line\">  templateUrl : &apos;view/page1.html&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">.state(&apos;page1.main&apos;,&#123;</div><div class=\"line\">  url : &apos;/main&apos;,</div><div class=\"line\">  emplateUrl : &apos;view/page1-main.html&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。</p>\n<h4 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h4><p>ui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ui-view&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div ui-view=&quot;chart&quot;&gt;&lt;/div&gt; </div><div class=\"line\">&lt;div ui-view=&quot;data&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&quot;home&quot;, &#123;</div><div class=\"line\">  views: &#123;</div><div class=\"line\">    &quot;&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;h1&gt;HELLO!&lt;/h1&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;chart&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;chart_thing/&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;data&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;data_thing/&gt;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>"},{"layout":"post","title":"tips:编写邮件中的html文件","date":"2015-12-03T09:31:00.000Z","_content":"\n最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。\n\n如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。\n目前常见的邮箱客户端有Gmail，Outlook等，[不同邮箱客户端对CSS样式的支持情况](https://www.campaignmonitor.com/css/)也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。\n1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。\n\n<!--more-->\n\n```\n<div style=\"width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;\">\n    内容区域\n</div>\n```\n\n2.网页的布局必须使用表格\n\n```\n<div style=\"text-align:center;\">\n    <table width=\"600\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"margin:0 auto;\"><tbody><tr><td>\n        <div style=\"width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;\">\n\n            <!-- 水平居中的邮件 -->\n\n        </div>\n    </td></tr></tbody></table>\n</div>\n```\n\n3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读\n\n4.如果想测试自己写的html在邮件中效果，可以使用这个网站（https://litmus.com/）\n这是我测试页面时的截图：\n\n![](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png)","source":"_posts/2015-12-03-html-in-email.md","raw":"---\nlayout: post\ntitle:  \"tips:编写邮件中的html文件\"\ndate:   2015-12-03 17:31\ncategories: front-end css\n---\n\n最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。\n\n如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。\n目前常见的邮箱客户端有Gmail，Outlook等，[不同邮箱客户端对CSS样式的支持情况](https://www.campaignmonitor.com/css/)也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。\n1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。\n\n<!--more-->\n\n```\n<div style=\"width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;\">\n    内容区域\n</div>\n```\n\n2.网页的布局必须使用表格\n\n```\n<div style=\"text-align:center;\">\n    <table width=\"600\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"margin:0 auto;\"><tbody><tr><td>\n        <div style=\"width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;\">\n\n            <!-- 水平居中的邮件 -->\n\n        </div>\n    </td></tr></tbody></table>\n</div>\n```\n\n3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读\n\n4.如果想测试自己写的html在邮件中效果，可以使用这个网站（https://litmus.com/）\n这是我测试页面时的截图：\n\n![](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png)","slug":"2015-12-03-html-in-email","published":1,"updated":"2016-06-16T10:49:18.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k2q000c9m61t9m444jh","content":"<p>最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。</p>\n<p>如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。<br>目前常见的邮箱客户端有Gmail，Outlook等，<a href=\"https://www.campaignmonitor.com/css/\" target=\"_blank\" rel=\"external\">不同邮箱客户端对CSS样式的支持情况</a>也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。<br>1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。</div></p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;&quot;&gt;</div><div class=\"line\">    内容区域</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>2.网页的布局必须使用表格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;text-align:center;&quot;&gt;</div><div class=\"line\">    &lt;table width=&quot;600&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;margin:0 auto;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;</div><div class=\"line\">        &lt;div style=&quot;width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">            &lt;!-- 水平居中的邮件 --&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读</p>\n<p>4.如果想测试自己写的html在邮件中效果，可以使用这个网站（<a href=\"https://litmus.com/）\" target=\"_blank\" rel=\"external\">https://litmus.com/）</a><br>这是我测试页面时的截图：</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png\" alt=\"\"></p>\n","excerpt":"<p>最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。</p>\n<p>如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。<br>目前常见的邮箱客户端有Gmail，Outlook等，<a href=\"https://www.campaignmonitor.com/css/\">不同邮箱客户端对CSS样式的支持情况</a>也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。<br>1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;&quot;&gt;</div><div class=\"line\">    内容区域</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>2.网页的布局必须使用表格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;text-align:center;&quot;&gt;</div><div class=\"line\">    &lt;table width=&quot;600&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;margin:0 auto;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;</div><div class=\"line\">        &lt;div style=&quot;width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">            &lt;!-- 水平居中的邮件 --&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读</p>\n<p>4.如果想测试自己写的html在邮件中效果，可以使用这个网站（<a href=\"https://litmus.com/）\">https://litmus.com/）</a><br>这是我测试页面时的截图：</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png\" alt=\"\"></p>"},{"layout":"post","title":"有关闭包，作用域，this对象","date":"2016-01-02T08:51:00.000Z","_content":"\n### 首先看一下维基百科中，闭包的概念：\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n\n#### 在创建函数和调用函数时，都发生了什么\n\n- 创建函数时\n 1. 创建了预先包含全局变量对象的作用域链\n 2. 该作用域链保存在内部[[scope]]属性中\n- 调用函数时\n 1. 创建执行环境\n 2. 复制函数[[scope]]属性中的对象构建作用域链\n 3. 用arguments与其它形参初始化函数的活动对象\n\n<!--more-->\n\n要理解这句话：**JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。**\n\n#### 再用计数器函数来看一个简单的闭包例子\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\ncounter2(); // Number of events: 1\ncounter1(); // Number of events: 3\n```\n\n这个函数实现了分别计数的功能。\n在createCounter()的最后一句：`return increment;`我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。\n因此，在使用`var counter1 = createCounter();`时，实际上，**我们生成了一个新的函数**。\n每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。\n**内部变量 counter 都是独立存在于每个作用域！**例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。\n\n#### 闭包的内存\n\n后台的每个执行环境都有一个表示变量的对象——变量对象。\n\n- 全局环境的变量对象始终存在\n- 像 createCounter()函数这样的局部变量，只在函数执行的过程中存在\n- 作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象\n- *一般来讲*当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。\n\n*但闭包的情况有所不同：*\n内部定义的函数会把外部函数的活动对象添加到它的作用域链中。\n当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为**匿名函数的作用域链仍然在引用这个活动对象**。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。\n一个简单的构造闭包以及释放内存的例子：\n\n```\nfunction outer () {\n\tvar name = 'foo';\n\treturn function () {\n\t\tconsole.log(name);\n\t}\n}\nvar inner = outer();\ninner();  // foo\ninner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存\n```\n\n并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。\n由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。\n\n#### 闭包的陷阱：循环闭包\n\n**请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。**\n因此，下面这个例子只会返回同一个值。\n\n```\nfunction foo(){\n    var result = new Array();\n    for(var i=0; i<10; i++){\n    result[i] = function(){\n    return i;\n    }\n    }\n    return result;\n}\n```\n\n表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.\n应改为：\n\n```\nfunction foo(){\nvar result = new Array();\nfor(var i=0; i<10; i++){\n    result[i] = function(num){\n    return function(){\n    return num\n    }\n    }(i);\n}\nreturn result;\n}\n```\n\n在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。\n匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。\n\n换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。\n代码简化如下：\n\n```\nvar arr = new Array();\nfor (var i = 0; i < 50; i++) {\n    (function () {\n        arr[i] = document.createElement('i');\n        arr[i].index = i;\n        arr[i].onclick = function () {\n            console.log(this.index);\n        };\n    })(i);\n};\n```\n\n`arr[i].index = i;`这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50\n\n#### 闭包中的this对象\n\n**匿名函数的执行环境具有全局性，因此其this对象通常指向window**\n```\nvar name = \"The Window\";\n　　var object = {\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()()); // “The Window”\n```\n内部函数在搜索`this`和`arguments`这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。\n\n### 关于this关键字\n\n在《JavaScripts语言精粹》中，把this的出现场景分为四种：\n\n> 有对象就指向调用对象\n\n> 没调用对象就指向全局对象\n\n> 用new构造就指向新对象\n\n> 通过 apply 或 call 或 bind 来改变 this 的所指。\n\n#### 1.全局的this===window\n\n#### 2.作为对象方法的函数的this指向这个上级对象\n\n```\nvar o ={\n    prop:37;\n    f:function(){return this.prop}\n    }\nconsole.log(o.f()); //37\n```\n\n#### 3.构造函数调用，this指向其生成的新对象\n\n```\nwindow. x = 2;\n　　function test(m){\n　　　　this.x = m;\n　　}\n　　var o = new test(5);\n　　alert(x); //5\n```\n\n#### 4.apply 和 call 调用以及 bind 绑定\n\n全局函数apply和call可以用来改变函数中this的指向，如下：\n\n```\n// 定义一个全局函数\n   function foo() {\n       console.log(this.fruit);\n   }\n // 定义一个全局变量\n   var fruit = \"apple\";\n   // 自定义一个对象\n   var pack = {\n       fruit: \"orange\"\n   };\n    // 等价于window.foo();\n   foo.apply(window);  // \"apple\",此时this等于window\n   // 此时foo中的this === pack\n   foo.apply(pack);    // \"orange\"\n```","source":"_posts/2016-01-02-clouser-scope.md","raw":"---\nlayout: post\ntitle:  \"有关闭包，作用域，this对象\"\ndate:   2016-01-02 16:51\ncategories: front-end javascript\n---\n\n### 首先看一下维基百科中，闭包的概念：\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n\n#### 在创建函数和调用函数时，都发生了什么\n\n- 创建函数时\n 1. 创建了预先包含全局变量对象的作用域链\n 2. 该作用域链保存在内部[[scope]]属性中\n- 调用函数时\n 1. 创建执行环境\n 2. 复制函数[[scope]]属性中的对象构建作用域链\n 3. 用arguments与其它形参初始化函数的活动对象\n\n<!--more-->\n\n要理解这句话：**JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。**\n\n#### 再用计数器函数来看一个简单的闭包例子\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\ncounter2(); // Number of events: 1\ncounter1(); // Number of events: 3\n```\n\n这个函数实现了分别计数的功能。\n在createCounter()的最后一句：`return increment;`我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。\n因此，在使用`var counter1 = createCounter();`时，实际上，**我们生成了一个新的函数**。\n每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。\n**内部变量 counter 都是独立存在于每个作用域！**例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。\n\n#### 闭包的内存\n\n后台的每个执行环境都有一个表示变量的对象——变量对象。\n\n- 全局环境的变量对象始终存在\n- 像 createCounter()函数这样的局部变量，只在函数执行的过程中存在\n- 作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象\n- *一般来讲*当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。\n\n*但闭包的情况有所不同：*\n内部定义的函数会把外部函数的活动对象添加到它的作用域链中。\n当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为**匿名函数的作用域链仍然在引用这个活动对象**。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。\n一个简单的构造闭包以及释放内存的例子：\n\n```\nfunction outer () {\n\tvar name = 'foo';\n\treturn function () {\n\t\tconsole.log(name);\n\t}\n}\nvar inner = outer();\ninner();  // foo\ninner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存\n```\n\n并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。\n由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。\n\n#### 闭包的陷阱：循环闭包\n\n**请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。**\n因此，下面这个例子只会返回同一个值。\n\n```\nfunction foo(){\n    var result = new Array();\n    for(var i=0; i<10; i++){\n    result[i] = function(){\n    return i;\n    }\n    }\n    return result;\n}\n```\n\n表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.\n应改为：\n\n```\nfunction foo(){\nvar result = new Array();\nfor(var i=0; i<10; i++){\n    result[i] = function(num){\n    return function(){\n    return num\n    }\n    }(i);\n}\nreturn result;\n}\n```\n\n在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。\n匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。\n\n换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。\n代码简化如下：\n\n```\nvar arr = new Array();\nfor (var i = 0; i < 50; i++) {\n    (function () {\n        arr[i] = document.createElement('i');\n        arr[i].index = i;\n        arr[i].onclick = function () {\n            console.log(this.index);\n        };\n    })(i);\n};\n```\n\n`arr[i].index = i;`这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50\n\n#### 闭包中的this对象\n\n**匿名函数的执行环境具有全局性，因此其this对象通常指向window**\n```\nvar name = \"The Window\";\n　　var object = {\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()()); // “The Window”\n```\n内部函数在搜索`this`和`arguments`这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。\n\n### 关于this关键字\n\n在《JavaScripts语言精粹》中，把this的出现场景分为四种：\n\n> 有对象就指向调用对象\n\n> 没调用对象就指向全局对象\n\n> 用new构造就指向新对象\n\n> 通过 apply 或 call 或 bind 来改变 this 的所指。\n\n#### 1.全局的this===window\n\n#### 2.作为对象方法的函数的this指向这个上级对象\n\n```\nvar o ={\n    prop:37;\n    f:function(){return this.prop}\n    }\nconsole.log(o.f()); //37\n```\n\n#### 3.构造函数调用，this指向其生成的新对象\n\n```\nwindow. x = 2;\n　　function test(m){\n　　　　this.x = m;\n　　}\n　　var o = new test(5);\n　　alert(x); //5\n```\n\n#### 4.apply 和 call 调用以及 bind 绑定\n\n全局函数apply和call可以用来改变函数中this的指向，如下：\n\n```\n// 定义一个全局函数\n   function foo() {\n       console.log(this.fruit);\n   }\n // 定义一个全局变量\n   var fruit = \"apple\";\n   // 自定义一个对象\n   var pack = {\n       fruit: \"orange\"\n   };\n    // 等价于window.foo();\n   foo.apply(window);  // \"apple\",此时this等于window\n   // 此时foo中的this === pack\n   foo.apply(pack);    // \"orange\"\n```","slug":"2016-01-02-clouser-scope","published":1,"updated":"2016-06-16T10:50:00.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k2v000e9m61flnkkvk5","content":"<h3 id=\"首先看一下维基百科中，闭包的概念：\"><a href=\"#首先看一下维基百科中，闭包的概念：\" class=\"headerlink\" title=\"首先看一下维基百科中，闭包的概念：\"></a>首先看一下维基百科中，闭包的概念：</h3><blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。<br>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n</blockquote>\n<h4 id=\"在创建函数和调用函数时，都发生了什么\"><a href=\"#在创建函数和调用函数时，都发生了什么\" class=\"headerlink\" title=\"在创建函数和调用函数时，都发生了什么\"></a>在创建函数和调用函数时，都发生了什么</h4><ul>\n<li>创建函数时<ol>\n<li>创建了预先包含全局变量对象的作用域链</li>\n<li>该作用域链保存在内部[[scope]]属性中</li>\n</ol>\n</li>\n<li>调用函数时<ol>\n<li>创建执行环境</li>\n<li>复制函数[[scope]]属性中的对象构建作用域链</li>\n<li>用arguments与其它形参初始化函数的活动对象</li>\n</ol>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>要理解这句话：<strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong></p>\n<h4 id=\"再用计数器函数来看一个简单的闭包例子\"><a href=\"#再用计数器函数来看一个简单的闭包例子\" class=\"headerlink\" title=\"再用计数器函数来看一个简单的闭包例子\"></a>再用计数器函数来看一个简单的闭包例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createCounter() &#123;</div><div class=\"line\">  var counter = 0;</div><div class=\"line\">  function increment() &#123;</div><div class=\"line\">    counter = counter + 1;</div><div class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return increment;</div><div class=\"line\">&#125;</div><div class=\"line\">var counter1 = createCounter();</div><div class=\"line\">var counter2 = createCounter();</div><div class=\"line\"></div><div class=\"line\">counter1(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 2</div><div class=\"line\">counter2(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 3</div></pre></td></tr></table></figure>\n<p>这个函数实现了分别计数的功能。<br>在createCounter()的最后一句：<code>return increment;</code>我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。<br>因此，在使用<code>var counter1 = createCounter();</code>时，实际上，<strong>我们生成了一个新的函数</strong>。<br>每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。<br><strong>内部变量 counter 都是独立存在于每个作用域！</strong>例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。</p>\n<h4 id=\"闭包的内存\"><a href=\"#闭包的内存\" class=\"headerlink\" title=\"闭包的内存\"></a>闭包的内存</h4><p>后台的每个执行环境都有一个表示变量的对象——变量对象。</p>\n<ul>\n<li>全局环境的变量对象始终存在</li>\n<li>像 createCounter()函数这样的局部变量，只在函数执行的过程中存在</li>\n<li>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象</li>\n<li><em>一般来讲</em>当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。</li>\n</ul>\n<p><em>但闭包的情况有所不同：</em><br>内部定义的函数会把外部函数的活动对象添加到它的作用域链中。<br>当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为<strong>匿名函数的作用域链仍然在引用这个活动对象</strong>。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。<br>一个简单的构造闭包以及释放内存的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outer () &#123;</div><div class=\"line\">\tvar name = &apos;foo&apos;;</div><div class=\"line\">\treturn function () &#123;</div><div class=\"line\">\t\tconsole.log(name);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var inner = outer();</div><div class=\"line\">inner();  // foo</div><div class=\"line\">inner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存</div></pre></td></tr></table></figure>\n<p>并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。<br>由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。</p>\n<h4 id=\"闭包的陷阱：循环闭包\"><a href=\"#闭包的陷阱：循环闭包\" class=\"headerlink\" title=\"闭包的陷阱：循环闭包\"></a>闭包的陷阱：循环闭包</h4><p><strong>请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。</strong><br>因此，下面这个例子只会返回同一个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">    var result = new Array();</div><div class=\"line\">    for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function()&#123;</div><div class=\"line\">    return i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.<br>应改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">var result = new Array();</div><div class=\"line\">for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function(num)&#123;</div><div class=\"line\">    return function()&#123;</div><div class=\"line\">    return num</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;(i);</div><div class=\"line\">&#125;</div><div class=\"line\">return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。<br>匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。</p>\n<p>换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。<br>代码简化如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = new Array();</div><div class=\"line\">for (var i = 0; i &lt; 50; i++) &#123;</div><div class=\"line\">    (function () &#123;</div><div class=\"line\">        arr[i] = document.createElement(&apos;i&apos;);</div><div class=\"line\">        arr[i].index = i;</div><div class=\"line\">        arr[i].onclick = function () &#123;</div><div class=\"line\">            console.log(this.index);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;)(i);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>arr[i].index = i;</code>这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50</p>\n<h4 id=\"闭包中的this对象\"><a href=\"#闭包中的this对象\" class=\"headerlink\" title=\"闭包中的this对象\"></a>闭包中的this对象</h4><p><strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\">　　var object = &#123;</div><div class=\"line\">　　　　name : &quot;My Object&quot;,</div><div class=\"line\">　　　　getNameFunc : function()&#123;</div><div class=\"line\">　　　　　　return function()&#123;</div><div class=\"line\">　　　　　　　　return this.name;</div><div class=\"line\">　　　　　　&#125;;</div><div class=\"line\">　　　　&#125;</div><div class=\"line\">　　&#125;;</div><div class=\"line\">　　alert(object.getNameFunc()()); // “The Window”</div></pre></td></tr></table></figure></p>\n<p>内部函数在搜索<code>this</code>和<code>arguments</code>这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。</p>\n<h3 id=\"关于this关键字\"><a href=\"#关于this关键字\" class=\"headerlink\" title=\"关于this关键字\"></a>关于this关键字</h3><p>在《JavaScripts语言精粹》中，把this的出现场景分为四种：</p>\n<blockquote>\n<p>有对象就指向调用对象</p>\n<p>没调用对象就指向全局对象</p>\n<p>用new构造就指向新对象</p>\n<p>通过 apply 或 call 或 bind 来改变 this 的所指。</p>\n</blockquote>\n<h4 id=\"1-全局的this-window\"><a href=\"#1-全局的this-window\" class=\"headerlink\" title=\"1.全局的this===window\"></a>1.全局的this===window</h4><h4 id=\"2-作为对象方法的函数的this指向这个上级对象\"><a href=\"#2-作为对象方法的函数的this指向这个上级对象\" class=\"headerlink\" title=\"2.作为对象方法的函数的this指向这个上级对象\"></a>2.作为对象方法的函数的this指向这个上级对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o =&#123;</div><div class=\"line\">    prop:37;</div><div class=\"line\">    f:function()&#123;return this.prop&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">console.log(o.f()); //37</div></pre></td></tr></table></figure>\n<h4 id=\"3-构造函数调用，this指向其生成的新对象\"><a href=\"#3-构造函数调用，this指向其生成的新对象\" class=\"headerlink\" title=\"3.构造函数调用，this指向其生成的新对象\"></a>3.构造函数调用，this指向其生成的新对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">window. x = 2;</div><div class=\"line\">　　function test(m)&#123;</div><div class=\"line\">　　　　this.x = m;</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　var o = new test(5);</div><div class=\"line\">　　alert(x); //5</div></pre></td></tr></table></figure>\n<h4 id=\"4-apply-和-call-调用以及-bind-绑定\"><a href=\"#4-apply-和-call-调用以及-bind-绑定\" class=\"headerlink\" title=\"4.apply 和 call 调用以及 bind 绑定\"></a>4.apply 和 call 调用以及 bind 绑定</h4><p>全局函数apply和call可以用来改变函数中this的指向，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 定义一个全局函数</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">       console.log(this.fruit);</div><div class=\"line\">   &#125;</div><div class=\"line\"> // 定义一个全局变量</div><div class=\"line\">   var fruit = &quot;apple&quot;;</div><div class=\"line\">   // 自定义一个对象</div><div class=\"line\">   var pack = &#123;</div><div class=\"line\">       fruit: &quot;orange&quot;</div><div class=\"line\">   &#125;;</div><div class=\"line\">    // 等价于window.foo();</div><div class=\"line\">   foo.apply(window);  // &quot;apple&quot;,此时this等于window</div><div class=\"line\">   // 此时foo中的this === pack</div><div class=\"line\">   foo.apply(pack);    // &quot;orange&quot;</div></pre></td></tr></table></figure>","excerpt":"<h3 id=\"首先看一下维基百科中，闭包的概念：\"><a href=\"#首先看一下维基百科中，闭包的概念：\" class=\"headerlink\" title=\"首先看一下维基百科中，闭包的概念：\"></a>首先看一下维基百科中，闭包的概念：</h3><blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。<br>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n</blockquote>\n<h4 id=\"在创建函数和调用函数时，都发生了什么\"><a href=\"#在创建函数和调用函数时，都发生了什么\" class=\"headerlink\" title=\"在创建函数和调用函数时，都发生了什么\"></a>在创建函数和调用函数时，都发生了什么</h4><ul>\n<li>创建函数时<ol>\n<li>创建了预先包含全局变量对象的作用域链</li>\n<li>该作用域链保存在内部[[scope]]属性中</li>\n</ol>\n</li>\n<li>调用函数时<ol>\n<li>创建执行环境</li>\n<li>复制函数[[scope]]属性中的对象构建作用域链</li>\n<li>用arguments与其它形参初始化函数的活动对象</li>\n</ol>\n</li>\n</ul>","more":"<p>要理解这句话：<strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong></p>\n<h4 id=\"再用计数器函数来看一个简单的闭包例子\"><a href=\"#再用计数器函数来看一个简单的闭包例子\" class=\"headerlink\" title=\"再用计数器函数来看一个简单的闭包例子\"></a>再用计数器函数来看一个简单的闭包例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createCounter() &#123;</div><div class=\"line\">  var counter = 0;</div><div class=\"line\">  function increment() &#123;</div><div class=\"line\">    counter = counter + 1;</div><div class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return increment;</div><div class=\"line\">&#125;</div><div class=\"line\">var counter1 = createCounter();</div><div class=\"line\">var counter2 = createCounter();</div><div class=\"line\"></div><div class=\"line\">counter1(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 2</div><div class=\"line\">counter2(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 3</div></pre></td></tr></table></figure>\n<p>这个函数实现了分别计数的功能。<br>在createCounter()的最后一句：<code>return increment;</code>我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。<br>因此，在使用<code>var counter1 = createCounter();</code>时，实际上，<strong>我们生成了一个新的函数</strong>。<br>每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。<br><strong>内部变量 counter 都是独立存在于每个作用域！</strong>例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。</p>\n<h4 id=\"闭包的内存\"><a href=\"#闭包的内存\" class=\"headerlink\" title=\"闭包的内存\"></a>闭包的内存</h4><p>后台的每个执行环境都有一个表示变量的对象——变量对象。</p>\n<ul>\n<li>全局环境的变量对象始终存在</li>\n<li>像 createCounter()函数这样的局部变量，只在函数执行的过程中存在</li>\n<li>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象</li>\n<li><em>一般来讲</em>当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。</li>\n</ul>\n<p><em>但闭包的情况有所不同：</em><br>内部定义的函数会把外部函数的活动对象添加到它的作用域链中。<br>当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为<strong>匿名函数的作用域链仍然在引用这个活动对象</strong>。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。<br>一个简单的构造闭包以及释放内存的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outer () &#123;</div><div class=\"line\">\tvar name = &apos;foo&apos;;</div><div class=\"line\">\treturn function () &#123;</div><div class=\"line\">\t\tconsole.log(name);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var inner = outer();</div><div class=\"line\">inner();  // foo</div><div class=\"line\">inner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存</div></pre></td></tr></table></figure>\n<p>并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。<br>由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。</p>\n<h4 id=\"闭包的陷阱：循环闭包\"><a href=\"#闭包的陷阱：循环闭包\" class=\"headerlink\" title=\"闭包的陷阱：循环闭包\"></a>闭包的陷阱：循环闭包</h4><p><strong>请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。</strong><br>因此，下面这个例子只会返回同一个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">    var result = new Array();</div><div class=\"line\">    for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function()&#123;</div><div class=\"line\">    return i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.<br>应改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">var result = new Array();</div><div class=\"line\">for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function(num)&#123;</div><div class=\"line\">    return function()&#123;</div><div class=\"line\">    return num</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;(i);</div><div class=\"line\">&#125;</div><div class=\"line\">return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。<br>匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。</p>\n<p>换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。<br>代码简化如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = new Array();</div><div class=\"line\">for (var i = 0; i &lt; 50; i++) &#123;</div><div class=\"line\">    (function () &#123;</div><div class=\"line\">        arr[i] = document.createElement(&apos;i&apos;);</div><div class=\"line\">        arr[i].index = i;</div><div class=\"line\">        arr[i].onclick = function () &#123;</div><div class=\"line\">            console.log(this.index);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;)(i);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>arr[i].index = i;</code>这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50</p>\n<h4 id=\"闭包中的this对象\"><a href=\"#闭包中的this对象\" class=\"headerlink\" title=\"闭包中的this对象\"></a>闭包中的this对象</h4><p><strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\">　　var object = &#123;</div><div class=\"line\">　　　　name : &quot;My Object&quot;,</div><div class=\"line\">　　　　getNameFunc : function()&#123;</div><div class=\"line\">　　　　　　return function()&#123;</div><div class=\"line\">　　　　　　　　return this.name;</div><div class=\"line\">　　　　　　&#125;;</div><div class=\"line\">　　　　&#125;</div><div class=\"line\">　　&#125;;</div><div class=\"line\">　　alert(object.getNameFunc()()); // “The Window”</div></pre></td></tr></table></figure></p>\n<p>内部函数在搜索<code>this</code>和<code>arguments</code>这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。</p>\n<h3 id=\"关于this关键字\"><a href=\"#关于this关键字\" class=\"headerlink\" title=\"关于this关键字\"></a>关于this关键字</h3><p>在《JavaScripts语言精粹》中，把this的出现场景分为四种：</p>\n<blockquote>\n<p>有对象就指向调用对象</p>\n<p>没调用对象就指向全局对象</p>\n<p>用new构造就指向新对象</p>\n<p>通过 apply 或 call 或 bind 来改变 this 的所指。</p>\n</blockquote>\n<h4 id=\"1-全局的this-window\"><a href=\"#1-全局的this-window\" class=\"headerlink\" title=\"1.全局的this===window\"></a>1.全局的this===window</h4><h4 id=\"2-作为对象方法的函数的this指向这个上级对象\"><a href=\"#2-作为对象方法的函数的this指向这个上级对象\" class=\"headerlink\" title=\"2.作为对象方法的函数的this指向这个上级对象\"></a>2.作为对象方法的函数的this指向这个上级对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o =&#123;</div><div class=\"line\">    prop:37;</div><div class=\"line\">    f:function()&#123;return this.prop&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">console.log(o.f()); //37</div></pre></td></tr></table></figure>\n<h4 id=\"3-构造函数调用，this指向其生成的新对象\"><a href=\"#3-构造函数调用，this指向其生成的新对象\" class=\"headerlink\" title=\"3.构造函数调用，this指向其生成的新对象\"></a>3.构造函数调用，this指向其生成的新对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">window. x = 2;</div><div class=\"line\">　　function test(m)&#123;</div><div class=\"line\">　　　　this.x = m;</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　var o = new test(5);</div><div class=\"line\">　　alert(x); //5</div></pre></td></tr></table></figure>\n<h4 id=\"4-apply-和-call-调用以及-bind-绑定\"><a href=\"#4-apply-和-call-调用以及-bind-绑定\" class=\"headerlink\" title=\"4.apply 和 call 调用以及 bind 绑定\"></a>4.apply 和 call 调用以及 bind 绑定</h4><p>全局函数apply和call可以用来改变函数中this的指向，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 定义一个全局函数</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">       console.log(this.fruit);</div><div class=\"line\">   &#125;</div><div class=\"line\"> // 定义一个全局变量</div><div class=\"line\">   var fruit = &quot;apple&quot;;</div><div class=\"line\">   // 自定义一个对象</div><div class=\"line\">   var pack = &#123;</div><div class=\"line\">       fruit: &quot;orange&quot;</div><div class=\"line\">   &#125;;</div><div class=\"line\">    // 等价于window.foo();</div><div class=\"line\">   foo.apply(window);  // &quot;apple&quot;,此时this等于window</div><div class=\"line\">   // 此时foo中的this === pack</div><div class=\"line\">   foo.apply(pack);    // &quot;orange&quot;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Viewport-Percentage (or Viewport-Relative) Lengths","date":"2016-03-17T11:16:00.000Z","_content":"\n### 什么是视区百分比长度（viewport-percentage lengths）？\n\n先看一下W3C给出的定义：\n\n >The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.\n\n意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。`initial containing block`意为浏览器内部的可视区域，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n\n<!--more-->\n\n视区单位有`vh` (相对于视区高度), `vw`(相对于视区宽度), `vmin` (相对于视区高度或宽度，取决于哪个更小) and `vmax` (类似于vw但取决于哪个更大)。\n\n### 它是如何分配浏览器高度的？\n\n我们可以假借`vh`: `1vh`相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。\n\n### 浏览器兼容性？\n\n![caniuse](http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png)\n\n在css属性可用性查询网站[caniuse](http://caniuse.com/#search=viewport%20units)中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，**Chrome 20+, IE9+ ,FireFox19+以及Safari6** 都是支持的。\n\n### 100vh与100%的区别？\n\n我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于`window.innerWidth/window.innerHeight`的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）\n就像这个例子：\n\n```\n<body style=\"height:100%\">\n    <div style=\"height:200px\">\n        <p style=\"height:100%; display:block;\">Hello, world!</p>\n    </div>\n</body>\n```\n\n虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px\n\n### 如何用百分比实现同vh一样的效果？\n\n某些情况下，`vw`, `vh`所产生的效果与百分比`%单位`无异，尤其对于`absolute/fixed`定位属性的元素。比如：\n```\n{\n    position: fixed;\n    top: 100%;\n    top: 100vh;\n    left: 5%;\n    left: 5vw;\n    right: 5%;\n    right: 5vw;\n}\n```\n支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。\n\n### 参考内容\n\n* [James Donnelly__stackoverflow](http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window):视区单位布道\n* [视区相关单位_张鑫旭博客](http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/):更多相关与视区单位应用场景的尝试\n* [JS,Jquery获取各种屏幕的宽度和高度](http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html):复习一下有关屏幕高度的知识","source":"_posts/2016-03-17-vieport-percentage.md","raw":"---\nlayout: post\ntitle:  \"Viewport-Percentage (or Viewport-Relative) Lengths\"\ndate:   2016-03-17 19:16\ncategories: front-end css\n---\n\n### 什么是视区百分比长度（viewport-percentage lengths）？\n\n先看一下W3C给出的定义：\n\n >The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.\n\n意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。`initial containing block`意为浏览器内部的可视区域，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n\n<!--more-->\n\n视区单位有`vh` (相对于视区高度), `vw`(相对于视区宽度), `vmin` (相对于视区高度或宽度，取决于哪个更小) and `vmax` (类似于vw但取决于哪个更大)。\n\n### 它是如何分配浏览器高度的？\n\n我们可以假借`vh`: `1vh`相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。\n\n### 浏览器兼容性？\n\n![caniuse](http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png)\n\n在css属性可用性查询网站[caniuse](http://caniuse.com/#search=viewport%20units)中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，**Chrome 20+, IE9+ ,FireFox19+以及Safari6** 都是支持的。\n\n### 100vh与100%的区别？\n\n我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于`window.innerWidth/window.innerHeight`的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）\n就像这个例子：\n\n```\n<body style=\"height:100%\">\n    <div style=\"height:200px\">\n        <p style=\"height:100%; display:block;\">Hello, world!</p>\n    </div>\n</body>\n```\n\n虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px\n\n### 如何用百分比实现同vh一样的效果？\n\n某些情况下，`vw`, `vh`所产生的效果与百分比`%单位`无异，尤其对于`absolute/fixed`定位属性的元素。比如：\n```\n{\n    position: fixed;\n    top: 100%;\n    top: 100vh;\n    left: 5%;\n    left: 5vw;\n    right: 5%;\n    right: 5vw;\n}\n```\n支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。\n\n### 参考内容\n\n* [James Donnelly__stackoverflow](http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window):视区单位布道\n* [视区相关单位_张鑫旭博客](http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/):更多相关与视区单位应用场景的尝试\n* [JS,Jquery获取各种屏幕的宽度和高度](http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html):复习一下有关屏幕高度的知识","slug":"2016-03-17-vieport-percentage","published":1,"updated":"2016-06-16T10:50:15.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k3b000g9m61pmf1n8h2","content":"<h3 id=\"什么是视区百分比长度（viewport-percentage-lengths）？\"><a href=\"#什么是视区百分比长度（viewport-percentage-lengths）？\" class=\"headerlink\" title=\"什么是视区百分比长度（viewport-percentage lengths）？\"></a>什么是视区百分比长度（viewport-percentage lengths）？</h3><p>先看一下W3C给出的定义：</p>\n<blockquote>\n<p>The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>\n</blockquote>\n<p>意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。<code>initial containing block</code>意为浏览器内部的可视区域，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>\n<a id=\"more\"></a>\n<p>视区单位有<code>vh</code> (相对于视区高度), <code>vw</code>(相对于视区宽度), <code>vmin</code> (相对于视区高度或宽度，取决于哪个更小) and <code>vmax</code> (类似于vw但取决于哪个更大)。</p>\n<h3 id=\"它是如何分配浏览器高度的？\"><a href=\"#它是如何分配浏览器高度的？\" class=\"headerlink\" title=\"它是如何分配浏览器高度的？\"></a>它是如何分配浏览器高度的？</h3><p>我们可以假借<code>vh</code>: <code>1vh</code>相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。</p>\n<h3 id=\"浏览器兼容性？\"><a href=\"#浏览器兼容性？\" class=\"headerlink\" title=\"浏览器兼容性？\"></a>浏览器兼容性？</h3><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png\" alt=\"caniuse\"></p>\n<p>在css属性可用性查询网站<a href=\"http://caniuse.com/#search=viewport%20units\" target=\"_blank\" rel=\"external\">caniuse</a>中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，<strong>Chrome 20+, IE9+ ,FireFox19+以及Safari6</strong> 都是支持的。</p>\n<h3 id=\"100vh与100-的区别？\"><a href=\"#100vh与100-的区别？\" class=\"headerlink\" title=\"100vh与100%的区别？\"></a>100vh与100%的区别？</h3><p>我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于<code>window.innerWidth/window.innerHeight</code>的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）<br>就像这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body style=&quot;height:100%&quot;&gt;</div><div class=\"line\">    &lt;div style=&quot;height:200px&quot;&gt;</div><div class=\"line\">        &lt;p style=&quot;height:100%; display:block;&quot;&gt;Hello, world!&lt;/p&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px</p>\n<h3 id=\"如何用百分比实现同vh一样的效果？\"><a href=\"#如何用百分比实现同vh一样的效果？\" class=\"headerlink\" title=\"如何用百分比实现同vh一样的效果？\"></a>如何用百分比实现同vh一样的效果？</h3><p>某些情况下，<code>vw</code>, <code>vh</code>所产生的效果与百分比<code>%单位</code>无异，尤其对于<code>absolute/fixed</code>定位属性的元素。比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    position: fixed;</div><div class=\"line\">    top: 100%;</div><div class=\"line\">    top: 100vh;</div><div class=\"line\">    left: 5%;</div><div class=\"line\">    left: 5vw;</div><div class=\"line\">    right: 5%;</div><div class=\"line\">    right: 5vw;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window\" target=\"_blank\" rel=\"external\">James Donnelly__stackoverflow</a>:视区单位布道</li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/\" target=\"_blank\" rel=\"external\">视区相关单位_张鑫旭博客</a>:更多相关与视区单位应用场景的尝试</li>\n<li><a href=\"http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html\" target=\"_blank\" rel=\"external\">JS,Jquery获取各种屏幕的宽度和高度</a>:复习一下有关屏幕高度的知识</li>\n</ul>\n","excerpt":"<h3 id=\"什么是视区百分比长度（viewport-percentage-lengths）？\"><a href=\"#什么是视区百分比长度（viewport-percentage-lengths）？\" class=\"headerlink\" title=\"什么是视区百分比长度（viewport-percentage lengths）？\"></a>什么是视区百分比长度（viewport-percentage lengths）？</h3><p>先看一下W3C给出的定义：</p>\n<blockquote>\n<p>The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>\n</blockquote>\n<p>意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。<code>initial containing block</code>意为浏览器内部的可视区域，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>","more":"<p>视区单位有<code>vh</code> (相对于视区高度), <code>vw</code>(相对于视区宽度), <code>vmin</code> (相对于视区高度或宽度，取决于哪个更小) and <code>vmax</code> (类似于vw但取决于哪个更大)。</p>\n<h3 id=\"它是如何分配浏览器高度的？\"><a href=\"#它是如何分配浏览器高度的？\" class=\"headerlink\" title=\"它是如何分配浏览器高度的？\"></a>它是如何分配浏览器高度的？</h3><p>我们可以假借<code>vh</code>: <code>1vh</code>相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。</p>\n<h3 id=\"浏览器兼容性？\"><a href=\"#浏览器兼容性？\" class=\"headerlink\" title=\"浏览器兼容性？\"></a>浏览器兼容性？</h3><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png\" alt=\"caniuse\"></p>\n<p>在css属性可用性查询网站<a href=\"http://caniuse.com/#search=viewport%20units\">caniuse</a>中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，<strong>Chrome 20+, IE9+ ,FireFox19+以及Safari6</strong> 都是支持的。</p>\n<h3 id=\"100vh与100-的区别？\"><a href=\"#100vh与100-的区别？\" class=\"headerlink\" title=\"100vh与100%的区别？\"></a>100vh与100%的区别？</h3><p>我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于<code>window.innerWidth/window.innerHeight</code>的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）<br>就像这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body style=&quot;height:100%&quot;&gt;</div><div class=\"line\">    &lt;div style=&quot;height:200px&quot;&gt;</div><div class=\"line\">        &lt;p style=&quot;height:100%; display:block;&quot;&gt;Hello, world!&lt;/p&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px</p>\n<h3 id=\"如何用百分比实现同vh一样的效果？\"><a href=\"#如何用百分比实现同vh一样的效果？\" class=\"headerlink\" title=\"如何用百分比实现同vh一样的效果？\"></a>如何用百分比实现同vh一样的效果？</h3><p>某些情况下，<code>vw</code>, <code>vh</code>所产生的效果与百分比<code>%单位</code>无异，尤其对于<code>absolute/fixed</code>定位属性的元素。比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    position: fixed;</div><div class=\"line\">    top: 100%;</div><div class=\"line\">    top: 100vh;</div><div class=\"line\">    left: 5%;</div><div class=\"line\">    left: 5vw;</div><div class=\"line\">    right: 5%;</div><div class=\"line\">    right: 5vw;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window\">James Donnelly__stackoverflow</a>:视区单位布道</li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/\">视区相关单位_张鑫旭博客</a>:更多相关与视区单位应用场景的尝试</li>\n<li><a href=\"http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html\">JS,Jquery获取各种屏幕的宽度和高度</a>:复习一下有关屏幕高度的知识</li>\n</ul>"},{"layout":"post","title":"Cookie, LocalStorage 与 SessionStorage","date":"2016-03-10T07:02:00.000Z","_content":"有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。\n\n## 基本概念\n\n### Cookie\n\nCookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie\n\n### localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。\n\n<!--more-->\n\n### sessionStorage\n\nsessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。\n<table>\n    <tr>\n        <th>特性</th>\n        <th>Chorme</th>\n        <th>Firefox</th>\n        <th>IE</th>\n        <td>Opera</td>\n        <td>Safari</td>\n    </tr>\n    <tr>\n        <td>localStorage</td>\n        <td>4</td>\n        <td>3.5</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>sessionStorage</td>\n        <td>5</td>\n        <td>2</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n</table>\n\n## 共同点\n\n- 都是保存在浏览器端，而且同源。 \n- 三者都是键值对的集合。\n\n## 区别\n\n- cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据\n- 如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交\n- 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n- 数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。\n- 安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。\n- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。\n\n## 应用场景\n\n- 每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。\n- 由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。","source":"_posts/2016-03-10-cookie-localstorage-session.md","raw":"---\nlayout: post\ntitle:  \"Cookie, LocalStorage 与 SessionStorage\"\ndate:   2016-03-10 15:02\ncategories: front-end javascript\n---\n有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。\n\n## 基本概念\n\n### Cookie\n\nCookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie\n\n### localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。\n\n<!--more-->\n\n### sessionStorage\n\nsessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。\n<table>\n    <tr>\n        <th>特性</th>\n        <th>Chorme</th>\n        <th>Firefox</th>\n        <th>IE</th>\n        <td>Opera</td>\n        <td>Safari</td>\n    </tr>\n    <tr>\n        <td>localStorage</td>\n        <td>4</td>\n        <td>3.5</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>sessionStorage</td>\n        <td>5</td>\n        <td>2</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n</table>\n\n## 共同点\n\n- 都是保存在浏览器端，而且同源。 \n- 三者都是键值对的集合。\n\n## 区别\n\n- cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据\n- 如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交\n- 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n- 数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。\n- 安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。\n- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。\n\n## 应用场景\n\n- 每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。\n- 由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。","slug":"2016-03-10-cookie-localstorage-session","published":1,"updated":"2016-06-16T10:50:06.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k3e000h9m611u1z2c3x","content":"<p>有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p>\n<a id=\"more\"></a>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<table><br>    <tr><br>        <th>特性</th><br>        <th>Chorme</th><br>        <th>Firefox</th><br>        <th>IE</th><br>        <td>Opera</td><br>        <td>Safari</td><br>    </tr><br>    <tr><br>        <td>localStorage</td><br>        <td>4</td><br>        <td>3.5</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br>    <tr><br>        <td>sessionStorage</td><br>        <td>5</td><br>        <td>2</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br></table>\n\n<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li>都是保存在浏览器端，而且同源。 </li>\n<li>三者都是键值对的集合。</li>\n</ul>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据</li>\n<li>如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交</li>\n<li>存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。</li>\n<li>安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。</li>\n<li>由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。</li>\n</ul>\n","excerpt":"<p>有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p>","more":"<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<table><br>    <tr><br>        <th>特性</th><br>        <th>Chorme</th><br>        <th>Firefox</th><br>        <th>IE</th><br>        <td>Opera</td><br>        <td>Safari</td><br>    </tr><br>    <tr><br>        <td>localStorage</td><br>        <td>4</td><br>        <td>3.5</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br>    <tr><br>        <td>sessionStorage</td><br>        <td>5</td><br>        <td>2</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br></table>\n\n<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li>都是保存在浏览器端，而且同源。 </li>\n<li>三者都是键值对的集合。</li>\n</ul>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据</li>\n<li>如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交</li>\n<li>存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。</li>\n<li>安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。</li>\n<li>由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。</li>\n</ul>"},{"layout":"post","title":"避免脏pr：使用git rebase避免无谓的merge","date":"2016-06-09T03:51:00.000Z","_content":"\n### 问题复现与解决\n\n在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:\n\n![commit history](http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg)\n\n事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。\n\n想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。\n\n<!--more-->\n\n```\ngit fetch origin master\n# git merge origin/master # 不要这么干\ngit rebase origin/master\n```\n\n```\n# git pull origin master # 不要这么干\ngit pull --rebase\n```\n\n主要是因为`git pull`这一git命令实际执行了`git fetch`和`git merge FETCH_HEAD`两条指令。因此不要直接使用`git pull`来更新代码。`git pull --rebase `指令的意思是：\n\n1. 把本地repo自从上次pull之后的变更暂存起来\n2. 回到上次pull时的情况\n3. 套用远端的变更\n4. 套用第一步中暂存的本地变更\n\n### 关于git rebase\n`git rebase`和`git merge`做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。\n假设合并前是这样：\n\n>D---E master\n     /\nA---B---C---F origin/master\n\n使用merge合并后：\n\n>D--------E  \n     /          \\\nA---B---C---F----G   master, origin/master\n\n适应rebase合并后：\n\n>A---B---C---F---D'---E'   master, origin/master\n\n由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。\n\n### A rebase-based workflow\n1.新建分支\n\n> git checkout master\n  git pull    #更新master\n  git checkout master -b test   #从master创建feature分支\n  git push -u origin test:test\n  \\#把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支\n\n2.更新分支\n\n从master更新\n\n> git pull --rebase origin master #此方法不会更新本地master分支\n\n从test更新\n\n> git pull --rebase #需先设置追踪分支\n\n3.完成后回到主分支\n\n> git checkout master\n  git pull     #这里不会导致出现merge commit\n  git rebase test     #把commits拉取到主分支\n  git push\n\n### 处理脏pr\n这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。\n\n> git fetch origin master:new-feature\n  git checkout new-feature\n  git cherry-pick COMMIT_HASH_1\n  git cherry-pick COMMIT_HASH_2\n  ...\n  git cherry-pick COMMIT_HASH_N\n  \ncherry-pick命令\"复制\"一个提交节点并在当前分支做一次完全一样的新提交。\n注意cherry-pick的顺序应是commit **从旧到新** 的顺序，否则会一直出现无数冲突。\n\n### 参考内容\n* [RandyFay:A Rebase Workflow for Git](https://randyfay.com/node/91)\n* [stackoverflow:When do you use git rebase instead of git merge?](http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge)\n* [stackoverflow:git workflow and rebase vs merge questions](http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions)\n* [git-recipes:代码合并:Merge、Rebase的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n* [WEB研究所:git 实践之避免 merge](https://www.web-tinker.com/article/21112.html)\n\n\n\n\n\n\n\n","source":"_posts/2016-06-09-rebase-workflow.md","raw":"---\nlayout: post\ntitle:  \"避免脏pr：使用git rebase避免无谓的merge\"\ndate:   2016-06-09 11:51\ncategories: git\n---\n\n### 问题复现与解决\n\n在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:\n\n![commit history](http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg)\n\n事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。\n\n想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。\n\n<!--more-->\n\n```\ngit fetch origin master\n# git merge origin/master # 不要这么干\ngit rebase origin/master\n```\n\n```\n# git pull origin master # 不要这么干\ngit pull --rebase\n```\n\n主要是因为`git pull`这一git命令实际执行了`git fetch`和`git merge FETCH_HEAD`两条指令。因此不要直接使用`git pull`来更新代码。`git pull --rebase `指令的意思是：\n\n1. 把本地repo自从上次pull之后的变更暂存起来\n2. 回到上次pull时的情况\n3. 套用远端的变更\n4. 套用第一步中暂存的本地变更\n\n### 关于git rebase\n`git rebase`和`git merge`做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。\n假设合并前是这样：\n\n>D---E master\n     /\nA---B---C---F origin/master\n\n使用merge合并后：\n\n>D--------E  \n     /          \\\nA---B---C---F----G   master, origin/master\n\n适应rebase合并后：\n\n>A---B---C---F---D'---E'   master, origin/master\n\n由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。\n\n### A rebase-based workflow\n1.新建分支\n\n> git checkout master\n  git pull    #更新master\n  git checkout master -b test   #从master创建feature分支\n  git push -u origin test:test\n  \\#把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支\n\n2.更新分支\n\n从master更新\n\n> git pull --rebase origin master #此方法不会更新本地master分支\n\n从test更新\n\n> git pull --rebase #需先设置追踪分支\n\n3.完成后回到主分支\n\n> git checkout master\n  git pull     #这里不会导致出现merge commit\n  git rebase test     #把commits拉取到主分支\n  git push\n\n### 处理脏pr\n这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。\n\n> git fetch origin master:new-feature\n  git checkout new-feature\n  git cherry-pick COMMIT_HASH_1\n  git cherry-pick COMMIT_HASH_2\n  ...\n  git cherry-pick COMMIT_HASH_N\n  \ncherry-pick命令\"复制\"一个提交节点并在当前分支做一次完全一样的新提交。\n注意cherry-pick的顺序应是commit **从旧到新** 的顺序，否则会一直出现无数冲突。\n\n### 参考内容\n* [RandyFay:A Rebase Workflow for Git](https://randyfay.com/node/91)\n* [stackoverflow:When do you use git rebase instead of git merge?](http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge)\n* [stackoverflow:git workflow and rebase vs merge questions](http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions)\n* [git-recipes:代码合并:Merge、Rebase的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n* [WEB研究所:git 实践之避免 merge](https://www.web-tinker.com/article/21112.html)\n\n\n\n\n\n\n\n","slug":"2016-06-09-rebase-workflow","published":1,"updated":"2016-06-16T11:08:42.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k3h000j9m61x1l6hulf","content":"<h3 id=\"问题复现与解决\"><a href=\"#问题复现与解决\" class=\"headerlink\" title=\"问题复现与解决\"></a>问题复现与解决</h3><p>在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg\" alt=\"commit history\"></p>\n<p>事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。</p>\n<p>想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git fetch origin master</div><div class=\"line\"># git merge origin/master # 不要这么干</div><div class=\"line\">git rebase origin/master</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># git pull origin master # 不要这么干</div><div class=\"line\">git pull --rebase</div></pre></td></tr></table></figure>\n<p>主要是因为<code>git pull</code>这一git命令实际执行了<code>git fetch</code>和<code>git merge FETCH_HEAD</code>两条指令。因此不要直接使用<code>git pull</code>来更新代码。<code>git pull --rebase</code>指令的意思是：</p>\n<ol>\n<li>把本地repo自从上次pull之后的变更暂存起来</li>\n<li>回到上次pull时的情况</li>\n<li>套用远端的变更</li>\n<li>套用第一步中暂存的本地变更</li>\n</ol>\n<h3 id=\"关于git-rebase\"><a href=\"#关于git-rebase\" class=\"headerlink\" title=\"关于git rebase\"></a>关于git rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。<br>假设合并前是这样：</p>\n<blockquote>\n<p>D—E master<br>     /<br>A—B—C—F origin/master</p>\n</blockquote>\n<p>使用merge合并后：</p>\n<blockquote>\n<p>D——–E<br>     /          \\<br>A—B—C—F—-G   master, origin/master</p>\n</blockquote>\n<p>适应rebase合并后：</p>\n<blockquote>\n<p>A—B—C—F—D’—E’   master, origin/master</p>\n</blockquote>\n<p>由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。</p>\n<h3 id=\"A-rebase-based-workflow\"><a href=\"#A-rebase-based-workflow\" class=\"headerlink\" title=\"A rebase-based workflow\"></a>A rebase-based workflow</h3><p>1.新建分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull    #更新master<br>  git checkout master -b test   #从master创建feature分支<br>  git push -u origin test:test<br>  #把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支</p>\n</blockquote>\n<p>2.更新分支</p>\n<p>从master更新</p>\n<blockquote>\n<p>git pull –rebase origin master #此方法不会更新本地master分支</p>\n</blockquote>\n<p>从test更新</p>\n<blockquote>\n<p>git pull –rebase #需先设置追踪分支</p>\n</blockquote>\n<p>3.完成后回到主分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull     #这里不会导致出现merge commit<br>  git rebase test     #把commits拉取到主分支<br>  git push</p>\n</blockquote>\n<h3 id=\"处理脏pr\"><a href=\"#处理脏pr\" class=\"headerlink\" title=\"处理脏pr\"></a>处理脏pr</h3><p>这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。</p>\n<blockquote>\n<p>git fetch origin master:new-feature<br>  git checkout new-feature<br>  git cherry-pick COMMIT_HASH_1<br>  git cherry-pick COMMIT_HASH_2<br>  …<br>  git cherry-pick COMMIT_HASH_N</p>\n</blockquote>\n<p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br>注意cherry-pick的顺序应是commit <strong>从旧到新</strong> 的顺序，否则会一直出现无数冲突。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://randyfay.com/node/91\" target=\"_blank\" rel=\"external\">RandyFay:A Rebase Workflow for Git</a></li>\n<li><a href=\"http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge\" target=\"_blank\" rel=\"external\">stackoverflow:When do you use git rebase instead of git merge?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions\" target=\"_blank\" rel=\"external\">stackoverflow:git workflow and rebase vs merge questions</a></li>\n<li><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\" target=\"_blank\" rel=\"external\">git-recipes:代码合并:Merge、Rebase的选择</a></li>\n<li><a href=\"https://www.web-tinker.com/article/21112.html\" target=\"_blank\" rel=\"external\">WEB研究所:git 实践之避免 merge</a></li>\n</ul>\n","excerpt":"<h3 id=\"问题复现与解决\"><a href=\"#问题复现与解决\" class=\"headerlink\" title=\"问题复现与解决\"></a>问题复现与解决</h3><p>在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg\" alt=\"commit history\"></p>\n<p>事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。</p>\n<p>想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git fetch origin master</div><div class=\"line\"># git merge origin/master # 不要这么干</div><div class=\"line\">git rebase origin/master</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># git pull origin master # 不要这么干</div><div class=\"line\">git pull --rebase</div></pre></td></tr></table></figure>\n<p>主要是因为<code>git pull</code>这一git命令实际执行了<code>git fetch</code>和<code>git merge FETCH_HEAD</code>两条指令。因此不要直接使用<code>git pull</code>来更新代码。<code>git pull --rebase</code>指令的意思是：</p>\n<ol>\n<li>把本地repo自从上次pull之后的变更暂存起来</li>\n<li>回到上次pull时的情况</li>\n<li>套用远端的变更</li>\n<li>套用第一步中暂存的本地变更</li>\n</ol>\n<h3 id=\"关于git-rebase\"><a href=\"#关于git-rebase\" class=\"headerlink\" title=\"关于git rebase\"></a>关于git rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。<br>假设合并前是这样：</p>\n<blockquote>\n<p>D—E master<br>     /<br>A—B—C—F origin/master</p>\n</blockquote>\n<p>使用merge合并后：</p>\n<blockquote>\n<p>D——–E<br>     /          \\<br>A—B—C—F—-G   master, origin/master</p>\n</blockquote>\n<p>适应rebase合并后：</p>\n<blockquote>\n<p>A—B—C—F—D’—E’   master, origin/master</p>\n</blockquote>\n<p>由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。</p>\n<h3 id=\"A-rebase-based-workflow\"><a href=\"#A-rebase-based-workflow\" class=\"headerlink\" title=\"A rebase-based workflow\"></a>A rebase-based workflow</h3><p>1.新建分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull    #更新master<br>  git checkout master -b test   #从master创建feature分支<br>  git push -u origin test:test<br>  #把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支</p>\n</blockquote>\n<p>2.更新分支</p>\n<p>从master更新</p>\n<blockquote>\n<p>git pull –rebase origin master #此方法不会更新本地master分支</p>\n</blockquote>\n<p>从test更新</p>\n<blockquote>\n<p>git pull –rebase #需先设置追踪分支</p>\n</blockquote>\n<p>3.完成后回到主分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull     #这里不会导致出现merge commit<br>  git rebase test     #把commits拉取到主分支<br>  git push</p>\n</blockquote>\n<h3 id=\"处理脏pr\"><a href=\"#处理脏pr\" class=\"headerlink\" title=\"处理脏pr\"></a>处理脏pr</h3><p>这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。</p>\n<blockquote>\n<p>git fetch origin master:new-feature<br>  git checkout new-feature<br>  git cherry-pick COMMIT_HASH_1<br>  git cherry-pick COMMIT_HASH_2<br>  …<br>  git cherry-pick COMMIT_HASH_N</p>\n</blockquote>\n<p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br>注意cherry-pick的顺序应是commit <strong>从旧到新</strong> 的顺序，否则会一直出现无数冲突。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://randyfay.com/node/91\">RandyFay:A Rebase Workflow for Git</a></li>\n<li><a href=\"http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge\">stackoverflow:When do you use git rebase instead of git merge?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions\">stackoverflow:git workflow and rebase vs merge questions</a></li>\n<li><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\">git-recipes:代码合并:Merge、Rebase的选择</a></li>\n<li><a href=\"https://www.web-tinker.com/article/21112.html\">WEB研究所:git 实践之避免 merge</a></li>\n</ul>"},{"layout":"post","title":"How does data binding work in AngularJS","date":"2016-06-05T07:28:00.000Z","_content":"\nAngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。\n\n`$apply()`这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有`$digest()`方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。\n\n### 关于$watch\n\n每一次你在UI中绑定什么东西时你就会往`$watch`的队列中插入一条`$watch`，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：\n\n```\nUser: <input type=\"text\" ng-model=\"user\" />\nPassword: <input type=\"password\" ng-model=\"pass\" />\n```\n\n在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。\n\n<!--more-->\n\n每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。\n\n一个watcher包含了三个东西：\n\n- 它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西\n\n- 这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty\n\n- 被触发执行的函数\n\n```\n$$watchers = [\n    {\n        eq: false, // 表明我们是否需要检查对象级别的相等\n        fn: function( newValue, oldValue ) {}, // 这是我们提供的监听器函数\n        last: 'Ryan', // 变量的最新值\n        exp: function(){}, // 我们提供的watchExp函数\n        get: function(){} // Angular's编译后的watchExp函数\n    }\n];\n```\n\n定义监听器的几种方法：\n1.把$watch设置为$scope的一种属性:`$scope.$watch('person.username', validateUnique);`\n2.插入angular表达式:`<p>username: {{person.username}}</p>`\n3.使用类似于ng-model的指令来定义监听器:`<input ng-model=\"person.username />`\n\n\n\n\n### 关于$digest和$apply\n如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。\n\n当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。\n\nAngularJS的$apply函数代码如下所示：\n\n```\n$apply: function(expr) {\n    try {\n      beginPhase('$apply');\n      return this.$eval(expr);\n    } catch (e) {\n      $exceptionHandler(e);\n    } finally {\n      clearPhase();\n      try {\n        $rootScope.$digest();\n      } catch (e) {\n        $exceptionHandler(e);\n        throw e;\n      }\n    }\n}\n```\n由此可见，使用$apply可带参数。\n\n$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。\n\n监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。\n\n$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。\n\n### build your own dirty-checking\n了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。\n首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];   \n};\n\nScope.prototype.$watch = function( ) {\n\n};\n\nScope.prototype.$digest = function( ) {\n\n};\n```\n\n设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：\n\n```\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n```\n\n如果没有传入listener的话我们会把它设置为空函数。\n$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。\n\n```\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n```\n\n下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest\n\n```\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log(newValue, oldValue);\n} );\n\n$scope.$digest();\n```\n\n我们发现在控制台输出了`Ryan undefined`，成功了！\n最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];\n};\n\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n\n\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\nvar element = document.querySelectorAll('input');\n\nelement[0].onkeyup = function() {\n    $scope.name = element[0].value;\n\n    $scope.$digest();\n};\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log('Input value updated - it is now ' + newValue);\n\n    element[0].value = $scope.name;\n} );\n\nvar updateScopeValue = function updateScopeValue( ) {\n    $scope.name = 'Bob';\n    $scope.$digest();\n};\n```\n\n### 参考内容\n\n* [RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves](https://ryanclark.me/how-angularjs-implements-dirty-checking)\n* [stackoverflow:How does data binding work in AngularJS?](http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs)\n* [徐飞:Angular沉思录（一）](https://github.com/xufei/blog/issues/10)\n* [angular-tips:$watch How the $apply Runs a $digest](http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/)\n* [IBM developerWorks:AngularJS 作用域与数据绑定机制](https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/)\n\n\n\n\n\n","source":"_posts/2016-06-05-angular-data-binding.markdown","raw":"---\nlayout: post\ntitle:  \"How does data binding work in AngularJS\"\ndate:   2016-06-05 15:28\ncategories: front-end javascript\n---\n\nAngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。\n\n`$apply()`这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有`$digest()`方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。\n\n### 关于$watch\n\n每一次你在UI中绑定什么东西时你就会往`$watch`的队列中插入一条`$watch`，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：\n\n```\nUser: <input type=\"text\" ng-model=\"user\" />\nPassword: <input type=\"password\" ng-model=\"pass\" />\n```\n\n在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。\n\n<!--more-->\n\n每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。\n\n一个watcher包含了三个东西：\n\n- 它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西\n\n- 这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty\n\n- 被触发执行的函数\n\n```\n$$watchers = [\n    {\n        eq: false, // 表明我们是否需要检查对象级别的相等\n        fn: function( newValue, oldValue ) {}, // 这是我们提供的监听器函数\n        last: 'Ryan', // 变量的最新值\n        exp: function(){}, // 我们提供的watchExp函数\n        get: function(){} // Angular's编译后的watchExp函数\n    }\n];\n```\n\n定义监听器的几种方法：\n1.把$watch设置为$scope的一种属性:`$scope.$watch('person.username', validateUnique);`\n2.插入angular表达式:`<p>username: {{person.username}}</p>`\n3.使用类似于ng-model的指令来定义监听器:`<input ng-model=\"person.username />`\n\n\n\n\n### 关于$digest和$apply\n如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。\n\n当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。\n\nAngularJS的$apply函数代码如下所示：\n\n```\n$apply: function(expr) {\n    try {\n      beginPhase('$apply');\n      return this.$eval(expr);\n    } catch (e) {\n      $exceptionHandler(e);\n    } finally {\n      clearPhase();\n      try {\n        $rootScope.$digest();\n      } catch (e) {\n        $exceptionHandler(e);\n        throw e;\n      }\n    }\n}\n```\n由此可见，使用$apply可带参数。\n\n$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。\n\n监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。\n\n$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。\n\n### build your own dirty-checking\n了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。\n首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];   \n};\n\nScope.prototype.$watch = function( ) {\n\n};\n\nScope.prototype.$digest = function( ) {\n\n};\n```\n\n设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：\n\n```\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n```\n\n如果没有传入listener的话我们会把它设置为空函数。\n$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。\n\n```\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n```\n\n下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest\n\n```\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log(newValue, oldValue);\n} );\n\n$scope.$digest();\n```\n\n我们发现在控制台输出了`Ryan undefined`，成功了！\n最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];\n};\n\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n\n\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\nvar element = document.querySelectorAll('input');\n\nelement[0].onkeyup = function() {\n    $scope.name = element[0].value;\n\n    $scope.$digest();\n};\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log('Input value updated - it is now ' + newValue);\n\n    element[0].value = $scope.name;\n} );\n\nvar updateScopeValue = function updateScopeValue( ) {\n    $scope.name = 'Bob';\n    $scope.$digest();\n};\n```\n\n### 参考内容\n\n* [RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves](https://ryanclark.me/how-angularjs-implements-dirty-checking)\n* [stackoverflow:How does data binding work in AngularJS?](http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs)\n* [徐飞:Angular沉思录（一）](https://github.com/xufei/blog/issues/10)\n* [angular-tips:$watch How the $apply Runs a $digest](http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/)\n* [IBM developerWorks:AngularJS 作用域与数据绑定机制](https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/)\n\n\n\n\n\n","slug":"2016-06-05-angular-data-binding","published":1,"updated":"2016-06-17T11:07:49.000Z","comments":1,"photos":[],"link":"","_id":"ciqni2k3l000l9m61w8aj1vmd","content":"<p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>\n<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>\n<h3 id=\"关于-watch\"><a href=\"#关于-watch\" class=\"headerlink\" title=\"关于$watch\"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</div><div class=\"line\">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p>\n<a id=\"more\"></a>\n<p>每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。</p>\n<p>一个watcher包含了三个东西：</p>\n<ul>\n<li><p>它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西</p>\n</li>\n<li><p>这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty</p>\n</li>\n<li><p>被触发执行的函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$$watchers = [</div><div class=\"line\">    &#123;</div><div class=\"line\">        eq: false, // 表明我们是否需要检查对象级别的相等</div><div class=\"line\">        fn: function( newValue, oldValue ) &#123;&#125;, // 这是我们提供的监听器函数</div><div class=\"line\">        last: &apos;Ryan&apos;, // 变量的最新值</div><div class=\"line\">        exp: function()&#123;&#125;, // 我们提供的watchExp函数</div><div class=\"line\">        get: function()&#123;&#125; // Angular&apos;s编译后的watchExp函数</div><div class=\"line\">    &#125;</div><div class=\"line\">];</div></pre></td></tr></table></figure>\n<p>定义监听器的几种方法：<br>1.把$watch设置为$scope的一种属性:<code>$scope.$watch(&#39;person.username&#39;, validateUnique);</code><br>2.插入angular表达式:<code>&lt;p&gt;username: &lt;/p&gt;</code><br>3.使用类似于ng-model的指令来定义监听器:<code>&lt;input ng-model=&quot;person.username /&gt;</code></p>\n<h3 id=\"关于-digest和-apply\"><a href=\"#关于-digest和-apply\" class=\"headerlink\" title=\"关于$digest和$apply\"></a>关于$digest和$apply</h3><p>如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。</p>\n<p>当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。</p>\n<p>AngularJS的$apply函数代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$apply: function(expr) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">      beginPhase(&apos;$apply&apos;);</div><div class=\"line\">      return this.$eval(expr);</div><div class=\"line\">    &#125; catch (e) &#123;</div><div class=\"line\">      $exceptionHandler(e);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">      clearPhase();</div><div class=\"line\">      try &#123;</div><div class=\"line\">        $rootScope.$digest();</div><div class=\"line\">      &#125; catch (e) &#123;</div><div class=\"line\">        $exceptionHandler(e);</div><div class=\"line\">        throw e;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由此可见，使用$apply可带参数。</p>\n<p>$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。</p>\n<p>监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。</p>\n<p>$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。</p>\n<h3 id=\"build-your-own-dirty-checking\"><a href=\"#build-your-own-dirty-checking\" class=\"headerlink\" title=\"build your own dirty-checking\"></a>build your own dirty-checking</h3><p>了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。<br>首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];   </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果没有传入listener的话我们会把它设置为空函数。<br>$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(newValue, oldValue);</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">$scope.$digest();</div></pre></td></tr></table></figure>\n<p>我们发现在控制台输出了<code>Ryan undefined</code>，成功了！<br>最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">var element = document.querySelectorAll(&apos;input&apos;);</div><div class=\"line\"></div><div class=\"line\">element[0].onkeyup = function() &#123;</div><div class=\"line\">    $scope.name = element[0].value;</div><div class=\"line\"></div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(&apos;Input value updated - it is now &apos; + newValue);</div><div class=\"line\"></div><div class=\"line\">    element[0].value = $scope.name;</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">var updateScopeValue = function updateScopeValue( ) &#123;</div><div class=\"line\">    $scope.name = &apos;Bob&apos;;</div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://ryanclark.me/how-angularjs-implements-dirty-checking\" target=\"_blank\" rel=\"external\">RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs\" target=\"_blank\" rel=\"external\">stackoverflow:How does data binding work in AngularJS?</a></li>\n<li><a href=\"https://github.com/xufei/blog/issues/10\" target=\"_blank\" rel=\"external\">徐飞:Angular沉思录（一）</a></li>\n<li><a href=\"http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/\" target=\"_blank\" rel=\"external\">angular-tips:$watch How the $apply Runs a $digest</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/\" target=\"_blank\" rel=\"external\">IBM developerWorks:AngularJS 作用域与数据绑定机制</a></li>\n</ul>\n","excerpt":"<p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>\n<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>\n<h3 id=\"关于-watch\"><a href=\"#关于-watch\" class=\"headerlink\" title=\"关于$watch\"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</div><div class=\"line\">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p>","more":"<p>每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。</p>\n<p>一个watcher包含了三个东西：</p>\n<ul>\n<li><p>它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西</p>\n</li>\n<li><p>这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty</p>\n</li>\n<li><p>被触发执行的函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$$watchers = [</div><div class=\"line\">    &#123;</div><div class=\"line\">        eq: false, // 表明我们是否需要检查对象级别的相等</div><div class=\"line\">        fn: function( newValue, oldValue ) &#123;&#125;, // 这是我们提供的监听器函数</div><div class=\"line\">        last: &apos;Ryan&apos;, // 变量的最新值</div><div class=\"line\">        exp: function()&#123;&#125;, // 我们提供的watchExp函数</div><div class=\"line\">        get: function()&#123;&#125; // Angular&apos;s编译后的watchExp函数</div><div class=\"line\">    &#125;</div><div class=\"line\">];</div></pre></td></tr></table></figure>\n<p>定义监听器的几种方法：<br>1.把$watch设置为$scope的一种属性:<code>$scope.$watch(&#39;person.username&#39;, validateUnique);</code><br>2.插入angular表达式:<code>&lt;p&gt;username: &lt;/p&gt;</code><br>3.使用类似于ng-model的指令来定义监听器:<code>&lt;input ng-model=&quot;person.username /&gt;</code></p>\n<h3 id=\"关于-digest和-apply\"><a href=\"#关于-digest和-apply\" class=\"headerlink\" title=\"关于$digest和$apply\"></a>关于$digest和$apply</h3><p>如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。</p>\n<p>当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。</p>\n<p>AngularJS的$apply函数代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$apply: function(expr) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">      beginPhase(&apos;$apply&apos;);</div><div class=\"line\">      return this.$eval(expr);</div><div class=\"line\">    &#125; catch (e) &#123;</div><div class=\"line\">      $exceptionHandler(e);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">      clearPhase();</div><div class=\"line\">      try &#123;</div><div class=\"line\">        $rootScope.$digest();</div><div class=\"line\">      &#125; catch (e) &#123;</div><div class=\"line\">        $exceptionHandler(e);</div><div class=\"line\">        throw e;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由此可见，使用$apply可带参数。</p>\n<p>$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。</p>\n<p>监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。</p>\n<p>$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。</p>\n<h3 id=\"build-your-own-dirty-checking\"><a href=\"#build-your-own-dirty-checking\" class=\"headerlink\" title=\"build your own dirty-checking\"></a>build your own dirty-checking</h3><p>了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。<br>首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];   </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果没有传入listener的话我们会把它设置为空函数。<br>$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(newValue, oldValue);</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">$scope.$digest();</div></pre></td></tr></table></figure>\n<p>我们发现在控制台输出了<code>Ryan undefined</code>，成功了！<br>最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">var element = document.querySelectorAll(&apos;input&apos;);</div><div class=\"line\"></div><div class=\"line\">element[0].onkeyup = function() &#123;</div><div class=\"line\">    $scope.name = element[0].value;</div><div class=\"line\"></div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(&apos;Input value updated - it is now &apos; + newValue);</div><div class=\"line\"></div><div class=\"line\">    element[0].value = $scope.name;</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">var updateScopeValue = function updateScopeValue( ) &#123;</div><div class=\"line\">    $scope.name = &apos;Bob&apos;;</div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://ryanclark.me/how-angularjs-implements-dirty-checking\">RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs\">stackoverflow:How does data binding work in AngularJS?</a></li>\n<li><a href=\"https://github.com/xufei/blog/issues/10\">徐飞:Angular沉思录（一）</a></li>\n<li><a href=\"http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/\">angular-tips:$watch How the $apply Runs a $digest</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/\">IBM developerWorks:AngularJS 作用域与数据绑定机制</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciqni2jz200009m61kx1yjznh","category_id":"ciqni2jzw00029m613vit0qf7","_id":"ciqni2k1r00069m61z68guyjj"},{"post_id":"ciqni2jzi00019m61wkwba3uu","category_id":"ciqni2k1p00059m6105slo5u0","_id":"ciqni2k1u00089m619sxdumn2"},{"post_id":"ciqni2k0700039m61l1l0f8fi","category_id":"ciqni2k1s00079m61syv1h6c0","_id":"ciqni2k20000a9m61tczsukzs"},{"post_id":"ciqni2k1800049m61y9p884wj","category_id":"ciqni2k1u00099m61zobxn24i","_id":"ciqni2k23000b9m6113sorm3o"},{"post_id":"ciqni2k2v000e9m61flnkkvk5","category_id":"ciqni2k1u00099m61zobxn24i","_id":"ciqni2k3g000i9m612ykzm8o1"},{"post_id":"ciqni2k3e000h9m611u1z2c3x","category_id":"ciqni2k1u00099m61zobxn24i","_id":"ciqni2k3o000m9m61v8obequq"},{"post_id":"ciqni2k2q000c9m61t9m444jh","category_id":"ciqni2k3a000f9m61mjuahtxv","_id":"ciqni2k3q000o9m61zllghspb"},{"post_id":"ciqni2k3l000l9m61w8aj1vmd","category_id":"ciqni2k1u00099m61zobxn24i","_id":"ciqni2k3q000p9m61r5iwe5sz"},{"post_id":"ciqni2k3b000g9m61pmf1n8h2","category_id":"ciqni2k3a000f9m61mjuahtxv","_id":"ciqni2k3r000q9m61f6xzznp9"},{"post_id":"ciqni2k3h000j9m61x1l6hulf","category_id":"ciqni2k3p000n9m61g9h0720v","_id":"ciqni2k3t000r9m61zs68br8j"}],"PostTag":[],"Tag":[]}}