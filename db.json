{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"41b9040a70fd1678e830eb6dcd5ec80e66c456f4","modified":1466131534000},{"_id":"themes/next/.DS_Store","hash":"fc21f93629bb80032d4b6ac001e23fcbbcf7f1bf","modified":1465711222000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1465711211000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1465711211000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1465711211000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1465711211000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1465711211000},{"_id":"themes/next/_config.yml","hash":"cc5e5fd9e3618b7605dcd6afa42c62ed4bb10d96","modified":1466936430000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1465711211000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1465711211000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1465711211000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1465711211000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1465711211000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1465711211000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1465711211000},{"_id":"themes/next/.git/config","hash":"a33539305f85ea695520b496f67659d5751acff8","modified":1465711211000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1465711184000},{"_id":"themes/next/.git/index","hash":"c717ff34fd335a0a02a0e63b1428f3f3b2d09014","modified":1465711211000},{"_id":"source/about/index.md","hash":"97fca50532aff31db2d7c3d8a74dc9d1482a02c1","modified":1466954135000},{"_id":"source/_posts/.DS_Store","hash":"ecfd5a33699b80853126288ba837d546b9364e61","modified":1466131792000},{"_id":"themes/next/.git/packed-refs","hash":"53976698e7751830b17bab22bf9557a1a724f1c1","modified":1465711211000},{"_id":"source/_posts/2015-08-20-bfc-note.markdown","hash":"f3327f52bc77f6e882efdeba15fa7baada5b509f","modified":1466073956000},{"_id":"source/_posts/2015-08-24-qunar-interview.markdown","hash":"6a61a99c29dca1f61b9d37df117a4088148f1380","modified":1466073931000},{"_id":"source/_posts/2015-12-03-html-in-email.md","hash":"6c38a451aaa542df03b9c072ecc706068afc4933","modified":1466074158000},{"_id":"source/_posts/2015-08-20-javascript-oop.md","hash":"d1c7755cb277a4c9550453fdcf075a5280e476b9","modified":1466073974000},{"_id":"source/_posts/2015-11-23-angular-uirouter.md","hash":"23c122912323100c1d3b821b7dc808c155834ea0","modified":1466074086000},{"_id":"source/_posts/2016-06-05-angular-data-binding.markdown","hash":"1915d3be5fb6cab0cfd37f2701dae54c2bfb7ca8","modified":1466161669000},{"_id":"source/_posts/2016-03-10-cookie-localstorage-session.md","hash":"4480a7c1a202700b93614566a87416302a4d2530","modified":1466074206000},{"_id":"source/_posts/2016-03-17-vieport-percentage.md","hash":"d5e1ee205f60c90272e25720a735b8ed38e28b82","modified":1466074215000},{"_id":"source/_posts/2016-01-02-clouser-scope.md","hash":"39419259185b53ec74e6d46041faed8601d41c5a","modified":1466074200000},{"_id":"source/_posts/2016-06-09-rebase-workflow.md","hash":"7288fa6e5a7a93c33ceea4290c33b915857ca120","modified":1466075322000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1465711211000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1465711211000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1465711211000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1465711211000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1465711211000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1465711211000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1465711211000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1465711211000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1465711211000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1465711211000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1465711211000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1465711211000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1465711211000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1465711211000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1465711211000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1465711211000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1465711211000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1465711211000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1465711211000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1465711211000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1465711211000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1465711211000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1465711211000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1465711211000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1465711184000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1465711184000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1465711184000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1465711184000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1465711184000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1465711184000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1465711184000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1465711184000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1465711184000},{"_id":"themes/next/.git/logs/HEAD","hash":"5b07e06b1ac48776f9559d0562d898e4ed290b7e","modified":1465711211000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1465711184000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1465711211000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1465711211000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1465711211000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1465711211000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1465711211000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1465711211000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1465711211000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1465711211000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1465711211000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1465711211000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1465711211000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1465711211000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1465711211000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1465711211000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1465711211000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1465711211000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1465711211000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1465711211000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1465711211000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1465711211000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1465711211000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1465711211000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1465711211000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1465711211000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1465711211000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1465711211000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1465711211000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1465711211000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1465711211000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1465711211000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1465711211000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1465711211000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1465711211000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465711211000},{"_id":"themes/next/.git/refs/heads/master","hash":"70f3cec8d5c53e85ad409bc81d67edb3b16e5bf5","modified":1465711211000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1465711211000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1465711211000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1465711211000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1465711211000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1465711211000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1465711211000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1465711211000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1465711211000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1465711211000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1465711211000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1465711211000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1465711211000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1465711211000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1465711211000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1465711211000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1465711211000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1465711211000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1465711211000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1465711211000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1465711211000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1465711211000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1465711211000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1465711211000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1465711211000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1465711211000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1465711211000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1465711211000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1465711211000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1465711211000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1465711211000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1465711211000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1465711211000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1465711211000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"5b07e06b1ac48776f9559d0562d898e4ed290b7e","modified":1465711211000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1465711211000},{"_id":"themes/next/.git/objects/pack/pack-bbe032423b77714f0e653a9de098a3cc20ae81e5.idx","hash":"645aa81d56d1525522aee60adf44d15d9ed8ec87","modified":1465711210000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1465711211000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1465711211000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1465711211000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1465711211000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1465711211000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1465711211000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1465711211000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1465711211000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1465711211000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1465711211000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1465711211000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1465711211000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1465711211000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1465711211000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"5b07e06b1ac48776f9559d0562d898e4ed290b7e","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1465711211000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1465711211000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1465711211000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1465711211000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1465711211000},{"_id":"themes/next/.git/objects/pack/pack-bbe032423b77714f0e653a9de098a3cc20ae81e5.pack","hash":"aa0c5a2005f588ee0492fd9a4da4a108abbfc115","modified":1465711210000},{"_id":"source/_posts/2016-06-26-graduation.md","hash":"ffd2e2f1f64e7559b5672e636d3b9cace5d2f9e4","modified":1466956463000},{"_id":"public/about/index.html","hash":"e1c5ad6c437b19a41bb2dc3ba3d23e130a3e9f54","modified":1466994644538},{"_id":"public/2016/06/05/2016-06-26-graduation/index.html","hash":"40472e0f223fd41470c2bd8777a7452aafe9b6c8","modified":1466994644538},{"_id":"public/2015/12/03/2015-12-03-html-in-email/index.html","hash":"bac0bf4f9407c5d0d22d5d8e41dc07ff266d945f","modified":1466994644539},{"_id":"public/2015/08/20/2015-08-20-bfc-note/index.html","hash":"99d063b30a5810b0c14b51db4a4897e6c76ea937","modified":1466994644539},{"_id":"public/archives/index.html","hash":"ae92571a5f9d6cd275818f80a276b2ad04b4d248","modified":1466994644539},{"_id":"public/archives/page/2/index.html","hash":"fd5229ac6c899ba6f3951aa09c76e561fa3c1fea","modified":1466994644539},{"_id":"public/archives/2015/index.html","hash":"80f73f1f97021806733b1ca66dcdfea69364298c","modified":1466994644539},{"_id":"public/archives/2015/08/index.html","hash":"9ce32daae3b003a202981d9837762da42c48ae75","modified":1466994644539},{"_id":"public/archives/2015/11/index.html","hash":"bfcc36ebf155e31bb1775de017edffea39474e0b","modified":1466994644539},{"_id":"public/archives/2015/12/index.html","hash":"a846de4c7358e7a347eaf3e0bbee116abefdd9f2","modified":1466994644539},{"_id":"public/archives/2016/index.html","hash":"4982544c09c13275fb2474a725de37860a077b6c","modified":1466994644539},{"_id":"public/archives/2016/01/index.html","hash":"55242f94acff5d40e24b98d35e52a80199557353","modified":1466994644539},{"_id":"public/archives/2016/03/index.html","hash":"11581e41b9d649dd91cfdd6e7c9ed9aec95948b3","modified":1466994644540},{"_id":"public/archives/2016/06/index.html","hash":"246dd2c161ef1c4cd6b69f763fd20071378ce913","modified":1466994644540},{"_id":"public/page/2/index.html","hash":"b22eac5679522c7dff821158bc66d04308724cb8","modified":1466994644540},{"_id":"public/categories/css/index.html","hash":"f6f879cebc3bfd6f25926a10526a81d4d463ef2d","modified":1466994644540},{"_id":"public/categories/front-end-interview/index.html","hash":"428c5dd5f06e204432967994c52a48cef5987a27","modified":1466994644540},{"_id":"public/categories/front-end-css/index.html","hash":"6088ee7612c3475c82edf0dbe42ddb0ecdaa8427","modified":1466994644540},{"_id":"public/categories/javascript/index.html","hash":"9899e7c82b797a8f7e061e7492898ea219935d06","modified":1466994644541},{"_id":"public/categories/front-end-javascript/index.html","hash":"6fde3171e24c2632d4c69125451563422de43d73","modified":1466994644541},{"_id":"public/categories/git/index.html","hash":"b3f509a6dfe3f8f1e0ab170b8973db32cdf491d7","modified":1466994644541},{"_id":"public/categories/notes/index.html","hash":"cf52759e1ff0b7882d8c8723eb4e1f7a226b6f99","modified":1466994644541},{"_id":"public/2016/06/09/2016-06-09-rebase-workflow/index.html","hash":"d8fb5fd639e6776686b12bbceb8710f14bb10d28","modified":1466994644541},{"_id":"public/2016/06/05/2016-06-05-angular-data-binding/index.html","hash":"6b2e9808c41523f5a46e4a2125a4042dac1264c7","modified":1466994644541},{"_id":"public/2016/03/17/2016-03-17-vieport-percentage/index.html","hash":"e3105e25371f0115f96ac6fcfb7578686cbdbdec","modified":1466994644541},{"_id":"public/2016/03/10/2016-03-10-cookie-localstorage-session/index.html","hash":"99cec306c979de2c9eaebc9dc437bf4ba5f36367","modified":1466994644541},{"_id":"public/2016/01/02/2016-01-02-clouser-scope/index.html","hash":"bfd55619ba5e5a510335c8f2a680a946e2bc4cae","modified":1466994644541},{"_id":"public/2015/11/23/2015-11-23-angular-uirouter/index.html","hash":"4ca69c53aeda21f08db3b6448022e17eeef1925e","modified":1466994644541},{"_id":"public/2015/08/24/2015-08-24-qunar-interview/index.html","hash":"4cd8f80db96caf7a56bec8893af4d1a5d1ad570a","modified":1466994644541},{"_id":"public/2015/08/20/2015-08-20-javascript-oop/index.html","hash":"2b6409b48ba0a4a6840e1eb804066b23aa511d08","modified":1466994644541},{"_id":"public/index.html","hash":"76b65120f106c8ab3599f52161a60a824a9c7659","modified":1466994644541},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1466994644554},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1466994644554},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1466994644554},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1466994644554},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1466994644554},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1466994644554},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1466994644554},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1466994644554},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1466994644554},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1466994644555},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1466994644555},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1466994644555},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1466994644555},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1466994644555},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1466994644555},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1466994644555},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1466994644555},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1466994644555},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1466994644555},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1466994644555},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1466994644555},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1466994644556},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1466994644556},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1466994644556},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1466994646152},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1466994646158},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1466994646159},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1466994646169},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1466994646169},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1466994646169},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1466994646169},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1466994646170},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1466994646172},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1466994646173},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1466994646173},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1466994646173},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1466994646173},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1466994646173},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1466994646173},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1466994646173},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1466994646173},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1466994646174},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1466994646174},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1466994646174},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1466994646174},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1466994646174},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1466994646174},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1466994646174},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1466994646174},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1466994646174},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1466994646174},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1466994646174},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1466994646174},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1466994646174},{"_id":"public/css/main.css","hash":"cc02d5a227a00e55197ef8afc0773aa1d167a97b","modified":1466994646175},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1466994646175},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1466994646175},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1466994646175},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1466994646175},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1466994646175},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1466994646175},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1466994646175},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1466994646175},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1466994646175},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1466994646175},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1466994646198}],"Category":[{"name":"css","_id":"cipwg2zkr0003hys6quhrwuo4"},{"name":"front-end interview","_id":"cipwg2zl40007hys6clcmrwjm"},{"name":"front-end css","_id":"cipwg2zli000bhys6avo3tn2j"},{"name":"javascript","_id":"cipwg2zlt000fhys684cx69t3"},{"name":"front-end javascript","_id":"cipwg2zlw000ihys6ljyh3wzh"},{"name":"git","_id":"cipwg2zm9000shys60x4arur3"},{"name":"notes","_id":"cipwrewlu0001g5s619w9jj5b"}],"Data":[],"Page":[{"title":"about","date":"2015-12-29T10:03:57.000Z","comments":0,"_content":"\n## About me\nweb developer,junior programmer\n\nLat/Long 39.9\"N,116. 3\"E\n\nNow studying EE/Power in BJTU\n\nInterested in Full-Stack,Meachine Learing\n\nHaving a wonderful and firm relationship with closuer\n\n## Contact\n\n- Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t\n- Github: [MechanicianW](https://github.com/MechanicianW)","source":"about/index.md","raw":"---\ntitle: about\ndate: 2015-12-29 18:03:57\ncomments: false\n---\n\n## About me\nweb developer,junior programmer\n\nLat/Long 39.9\"N,116. 3\"E\n\nNow studying EE/Power in BJTU\n\nInterested in Full-Stack,Meachine Learing\n\nHaving a wonderful and firm relationship with closuer\n\n## Contact\n\n- Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t\n- Github: [MechanicianW](https://github.com/MechanicianW)","updated":"2016-06-26T15:15:35.000Z","path":"about/index.html","_id":"cipwg2zkf0000hys6luzjk85m","layout":"page","content":"<h2 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h2><p>web developer,junior programmer</p>\n<p>Lat/Long 39.9”N,116. 3”E</p>\n<p>Now studying EE/Power in BJTU</p>\n<p>Interested in Full-Stack,Meachine Learing</p>\n<p>Having a wonderful and firm relationship with closuer</p>\n<h2 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h2><ul>\n<li>Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t</li>\n<li>Github: <a href=\"https://github.com/MechanicianW\" target=\"_blank\" rel=\"external\">MechanicianW</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h2><p>web developer,junior programmer</p>\n<p>Lat/Long 39.9”N,116. 3”E</p>\n<p>Now studying EE/Power in BJTU</p>\n<p>Interested in Full-Stack,Meachine Learing</p>\n<p>Having a wonderful and firm relationship with closuer</p>\n<h2 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h2><ul>\n<li>Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t</li>\n<li>Github: <a href=\"https://github.com/MechanicianW\">MechanicianW</a></li>\n</ul>\n"}],"Post":[{"layout":"post","title":"BFC学习笔记","date":"2015-08-20T02:54:24.000Z","_content":"### 一.概念\n\n在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。\n\n### 二.产生BFC条件：\n\n当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：\n\n*   float的值不为none。\n*   overflow的值不为visible。\n*   display的值为table-cell, table-caption, inline-block中的任何一个。\n*   position的值不为relative和static。\n\n<!--more-->\n\n### 三.应用\n\n1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。\n\n2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖\n\n3）解决上下相邻两个元素重叠\n> 外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。\n\n4）清除元素内部浮动\n\n只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。","source":"_posts/2015-08-20-bfc-note.markdown","raw":"---\nlayout: post\ntitle:  \"BFC学习笔记\"\ndate:   2015-08-20 10:54:24\ncategories: css\n---\n### 一.概念\n\n在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。\n\n### 二.产生BFC条件：\n\n当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：\n\n*   float的值不为none。\n*   overflow的值不为visible。\n*   display的值为table-cell, table-caption, inline-block中的任何一个。\n*   position的值不为relative和static。\n\n<!--more-->\n\n### 三.应用\n\n1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。\n\n2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖\n\n3）解决上下相邻两个元素重叠\n> 外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。\n\n4）清除元素内部浮动\n\n只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。","slug":"2015-08-20-bfc-note","published":1,"updated":"2016-06-16T10:45:56.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zkh0001hys67muppsax","content":"<h3 id=\"一-概念\"><a href=\"#一-概念\" class=\"headerlink\" title=\"一.概念\"></a>一.概念</h3><p>在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。</p>\n<h3 id=\"二-产生BFC条件：\"><a href=\"#二-产生BFC条件：\" class=\"headerlink\" title=\"二.产生BFC条件：\"></a>二.产生BFC条件：</h3><p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：</p>\n<ul>\n<li>float的值不为none。</li>\n<li>overflow的值不为visible。</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个。</li>\n<li>position的值不为relative和static。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"三-应用\"><a href=\"#三-应用\" class=\"headerlink\" title=\"三.应用\"></a>三.应用</h3><p>1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。</p>\n<p>2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖</p>\n<p>3）解决上下相邻两个元素重叠</p>\n<blockquote>\n<p>外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。</p>\n</blockquote>\n<p>4）清除元素内部浮动</p>\n<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。</p>\n","excerpt":"<h3 id=\"一-概念\"><a href=\"#一-概念\" class=\"headerlink\" title=\"一.概念\"></a>一.概念</h3><p>在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。</p>\n<h3 id=\"二-产生BFC条件：\"><a href=\"#二-产生BFC条件：\" class=\"headerlink\" title=\"二.产生BFC条件：\"></a>二.产生BFC条件：</h3><p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：</p>\n<ul>\n<li>float的值不为none。</li>\n<li>overflow的值不为visible。</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个。</li>\n<li>position的值不为relative和static。</li>\n</ul>","more":"<h3 id=\"三-应用\"><a href=\"#三-应用\" class=\"headerlink\" title=\"三.应用\"></a>三.应用</h3><p>1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。</p>\n<p>2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖</p>\n<p>3）解决上下相邻两个元素重叠</p>\n<blockquote>\n<p>外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。</p>\n</blockquote>\n<p>4）清除元素内部浮动</p>\n<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。</p>"},{"layout":"post","title":"150824去哪儿网面试总结","date":"2015-08-24T14:20:24.000Z","_content":"1.get()与post()的区别\n\nHttp定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。\n\n根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。\n\n根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\nGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。\n\nPOST的安全性要比GET的安全性高：\n\n<!--more-->\n\n通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n2.CSS优先级   [参考内容](http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html)\n\n（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style\n\n选择器优先权（权重）：\n\n1.  内联样式表的权值最高 1000；\n\n2.  ID 选择器的权值为 100\n\n3.  Class 类选择器的权值为 10\n\n4.  HTML 标签选择器的权值为 1\n\n![](http://www.nowamagic.net/csszone/images/priority_rules_1.jpg)\n\nCSS **优先级法则：**\n\nA  选择器都有一个权值，权值越大越优先；\n\nB  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；\n\nC  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；\n\nD  继承的CSS 样式不如后来指定的CSS 样式；\n\nE  在同一组属性设置中标有“!important”规则的优先级最大\n\n3.一次请求的完整流程\n\n① 建立TCP连接\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n② Web浏览器向Web服务器发送请求命令\n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n③ Web浏览器发送请求头信息\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n④ Web服务器应答\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n⑤ Web服务器发送应答头信息\n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n⑥ Web服务器向浏览器发送数据\n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n⑦ Web服务器关闭TCP连接\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN\n\n“8”*11=88\n\n“8a”*11=NaN","source":"_posts/2015-08-24-qunar-interview.markdown","raw":"---\nlayout: post\ntitle:  \"150824去哪儿网面试总结\"\ndate:   2015-08-24 22:20:24\ncategories: front-end interview\n---\n1.get()与post()的区别\n\nHttp定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。\n\n根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。\n\n根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\nGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。\n\nPOST的安全性要比GET的安全性高：\n\n<!--more-->\n\n通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n2.CSS优先级   [参考内容](http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html)\n\n（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style\n\n选择器优先权（权重）：\n\n1.  内联样式表的权值最高 1000；\n\n2.  ID 选择器的权值为 100\n\n3.  Class 类选择器的权值为 10\n\n4.  HTML 标签选择器的权值为 1\n\n![](http://www.nowamagic.net/csszone/images/priority_rules_1.jpg)\n\nCSS **优先级法则：**\n\nA  选择器都有一个权值，权值越大越优先；\n\nB  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；\n\nC  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；\n\nD  继承的CSS 样式不如后来指定的CSS 样式；\n\nE  在同一组属性设置中标有“!important”规则的优先级最大\n\n3.一次请求的完整流程\n\n① 建立TCP连接\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n② Web浏览器向Web服务器发送请求命令\n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n③ Web浏览器发送请求头信息\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n④ Web服务器应答\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n⑤ Web服务器发送应答头信息\n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n⑥ Web服务器向浏览器发送数据\n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n⑦ Web服务器关闭TCP连接\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN\n\n“8”*11=88\n\n“8a”*11=NaN","slug":"2015-08-24-qunar-interview","published":1,"updated":"2016-06-16T10:45:31.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zkn0002hys6jvgdm8fu","content":"<p>1.get()与post()的区别</p>\n<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>\n<p>根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。</p>\n<p>根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。</p>\n<p>POST的安全性要比GET的安全性高：</p>\n<a id=\"more\"></a>\n<p>通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n<p>2.CSS优先级   <a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\" target=\"_blank\" rel=\"external\">参考内容</a></p>\n<p>（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style</p>\n<p>选择器优先权（权重）：</p>\n<ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<p><img src=\"http://www.nowamagic.net/csszone/images/priority_rules_1.jpg\" alt=\"\"></p>\n<p>CSS <strong>优先级法则：</strong></p>\n<p>A  选择器都有一个权值，权值越大越优先；</p>\n<p>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p>\n<p>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p>\n<p>D  继承的CSS 样式不如后来指定的CSS 样式；</p>\n<p>E  在同一组属性设置中标有“!important”规则的优先级最大</p>\n<p>3.一次请求的完整流程</p>\n<p>① 建立TCP连接</p>\n<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p>② Web浏览器向Web服务器发送请求命令</p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p>③ Web浏览器发送请求头信息</p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>④ Web服务器应答</p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p>⑤ Web服务器发送应答头信息</p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<p>⑥ Web服务器向浏览器发送数据</p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p>⑦ Web服务器关闭TCP连接</p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p>4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN</p>\n<p>“8”*11=88</p>\n<p>“8a”*11=NaN</p>\n","excerpt":"<p>1.get()与post()的区别</p>\n<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>\n<p>根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。</p>\n<p>根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。</p>\n<p>POST的安全性要比GET的安全性高：</p>","more":"<p>通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n<p>2.CSS优先级   <a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\">参考内容</a></p>\n<p>（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style</p>\n<p>选择器优先权（权重）：</p>\n<ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<p><img src=\"http://www.nowamagic.net/csszone/images/priority_rules_1.jpg\" alt=\"\"></p>\n<p>CSS <strong>优先级法则：</strong></p>\n<p>A  选择器都有一个权值，权值越大越优先；</p>\n<p>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p>\n<p>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p>\n<p>D  继承的CSS 样式不如后来指定的CSS 样式；</p>\n<p>E  在同一组属性设置中标有“!important”规则的优先级最大</p>\n<p>3.一次请求的完整流程</p>\n<p>① 建立TCP连接</p>\n<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p>② Web浏览器向Web服务器发送请求命令</p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p>③ Web浏览器发送请求头信息</p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>④ Web服务器应答</p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p>⑤ Web服务器发送应答头信息</p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<p>⑥ Web服务器向浏览器发送数据</p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p>⑦ Web服务器关闭TCP连接</p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p>4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN</p>\n<p>“8”*11=88</p>\n<p>“8a”*11=NaN</p>"},{"layout":"post","title":"tips:编写邮件中的html文件","date":"2015-12-03T09:31:00.000Z","_content":"\n最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。\n\n如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。\n目前常见的邮箱客户端有Gmail，Outlook等，[不同邮箱客户端对CSS样式的支持情况](https://www.campaignmonitor.com/css/)也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。\n1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。\n\n<!--more-->\n\n```\n<div style=\"width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;\">\n    内容区域\n</div>\n```\n\n2.网页的布局必须使用表格\n\n```\n<div style=\"text-align:center;\">\n    <table width=\"600\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"margin:0 auto;\"><tbody><tr><td>\n        <div style=\"width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;\">\n\n            <!-- 水平居中的邮件 -->\n\n        </div>\n    </td></tr></tbody></table>\n</div>\n```\n\n3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读\n\n4.如果想测试自己写的html在邮件中效果，可以使用这个网站（https://litmus.com/）\n这是我测试页面时的截图：\n\n![](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png)","source":"_posts/2015-12-03-html-in-email.md","raw":"---\nlayout: post\ntitle:  \"tips:编写邮件中的html文件\"\ndate:   2015-12-03 17:31\ncategories: front-end css\n---\n\n最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。\n\n如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。\n目前常见的邮箱客户端有Gmail，Outlook等，[不同邮箱客户端对CSS样式的支持情况](https://www.campaignmonitor.com/css/)也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。\n1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。\n\n<!--more-->\n\n```\n<div style=\"width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;\">\n    内容区域\n</div>\n```\n\n2.网页的布局必须使用表格\n\n```\n<div style=\"text-align:center;\">\n    <table width=\"600\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"margin:0 auto;\"><tbody><tr><td>\n        <div style=\"width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;\">\n\n            <!-- 水平居中的邮件 -->\n\n        </div>\n    </td></tr></tbody></table>\n</div>\n```\n\n3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读\n\n4.如果想测试自己写的html在邮件中效果，可以使用这个网站（https://litmus.com/）\n这是我测试页面时的截图：\n\n![](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png)","slug":"2015-12-03-html-in-email","published":1,"updated":"2016-06-16T10:49:18.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zkv0004hys6ik5wle47","content":"<p>最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。</p>\n<p>如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。<br>目前常见的邮箱客户端有Gmail，Outlook等，<a href=\"https://www.campaignmonitor.com/css/\" target=\"_blank\" rel=\"external\">不同邮箱客户端对CSS样式的支持情况</a>也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。<br>1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。</div></p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;&quot;&gt;</span><br><span class=\"line\">    内容区域</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>2.网页的布局必须使用表格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;text-align:center;&quot;&gt;</span><br><span class=\"line\">    &lt;table width=&quot;600&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;margin:0 auto;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;</span><br><span class=\"line\">        &lt;div style=&quot;width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;!-- 水平居中的邮件 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读</p>\n<p>4.如果想测试自己写的html在邮件中效果，可以使用这个网站（<a href=\"https://litmus.com/）\" target=\"_blank\" rel=\"external\">https://litmus.com/）</a><br>这是我测试页面时的截图：</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png\" alt=\"\"></p>\n","excerpt":"<p>最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。</p>\n<p>如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。<br>目前常见的邮箱客户端有Gmail，Outlook等，<a href=\"https://www.campaignmonitor.com/css/\">不同邮箱客户端对CSS样式的支持情况</a>也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。<br>1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;&quot;&gt;</span><br><span class=\"line\">    内容区域</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>2.网页的布局必须使用表格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;text-align:center;&quot;&gt;</span><br><span class=\"line\">    &lt;table width=&quot;600&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;margin:0 auto;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;</span><br><span class=\"line\">        &lt;div style=&quot;width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;!-- 水平居中的邮件 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读</p>\n<p>4.如果想测试自己写的html在邮件中效果，可以使用这个网站（<a href=\"https://litmus.com/）\">https://litmus.com/）</a><br>这是我测试页面时的截图：</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png\" alt=\"\"></p>"},{"layout":"post","title":"javascript面向对象的程序设计","date":"2015-08-19T23:43:50.000Z","_content":"参考《JavaScript高级程序设计》第三版\n\n阮一峰[Javascript 面向对象编程](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)\n\n## 一.创建对象\n\n#### 1.字面量\n\n```\nvar cat1 = {\n\ncat1.name = \"kitty\";\n\ncat1.color = \"white\";\n\n};\n\nvar cat2 = {\n\ncat2.name = \"greg\";\n\ncat2.color = \"black\";\n\n};\n```\n\n有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。\n\n<!--more-->\n\n#### 2.工厂模式\n\n```\nfunction creatCat(name,color){\n\nvar o = new Object();\n\n0.name = name;\n\n0.color = color;\n\nreturn 0 ;\n\n}\n\nvar cat1 = createCat(\"kitty\",white);\n\nvar cat2 = createCat(\"greg\",black);\n```\n\n\n解决了多个相似对象的问题，但没有解决对象类型识别的问题。\n\n#### 3.构造函数模式\n\n```\nfunction Cat(name,color){\n\nthis.name=name;\n\nthis.color=color;\n\n}\n\nvar cat1 = new  Cat(\"kitty\",\"white\");\n\nvar cat2 = new  Cat(\"greg\",\"black\");\n\nalert(cat1.name); // kitty\n\nalert(cat1.color); // white\n```\n\n即没有return调用，将属性，方法赋给了_this_对象，函数名始终以大写字母开头\n\n任何函数只要通过new调用，就可以作为构造函数\n\n这时cat1和cat2会自动含有一个_constructor_属性，指向它们的构造函数。\n\n```\nalert(cat1.constructor == Cat); //true\nalert(cat2.constructor == Cat); //true\n```\n\nJavascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。\n\n```\nalert(cat1 instanceof Cat); //true\nalert(cat2 instanceof Cat); //true\n```\n\n**构造函数模式的问题：**\n\n构造函数方法很好用，但是存在一个浪费内存的问题。\n\n请看，我们现在为Cat对象添加一个不变的属性\"type\"（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：\n\n```\n function Cat(name,color){\n   this.name = name;\n   this.color = color;\n   this.type = \"猫科动物\";\n   this.eat = function(){alert(\"吃老鼠\");};\n }\n ```\n\n还是采用同样的方法，生成实例：\n\n```\n var cat1 = new Cat(\"kitty\",\"white\");\n var cat2 = new Cat (\"greg\",\"black\");\n alert(cat1.type); // 猫科动物\n cat1.eat(); // 吃老鼠\n```\n\n表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。\n `alert(cat1.eat == cat2.eat); //false`\n能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。\n\n#### 3.原型模式（Prototype模式）\n\n每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。\n\n原型对象可以让所有对象实例共享它所包含的属性和方法。\n\n我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n\n```\nfunction Cat(name,color){\n\nthis.name = name;\n\nthis.color = color;\n\n}\n\nCat.prototype.type = \"猫科动物\";\n\nCat.prototype.eat = function(){alert(\"吃老鼠\")};\n```\n\n然后，生成实例。\n\n```\nvar cat1 = new Cat(\"kitty\",\"white\");\nvar cat2 = new Cat(\"greg\",\"black\");\nalert(cat1.type); // 猫科动物\ncat1.eat(); // 吃老鼠\n```\n\n这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\n`alert(cat1.eat == cat2.eat); //true`\n\n**二、 Prototype模式的验证方法**\n\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n\n**1 isPrototypeOf()**\n\n这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n\n```\nalert(Cat.prototype.isPrototypeOf(cat1)); //true\nalert(Cat.prototype.isPrototypeOf(cat2)); //true\n```\n\n**2 hasOwnProperty()**\n\n每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false\n\n```\nalert(cat1.hasOwnProperty(\"name\")); // true\nalert(cat1.hasOwnProperty(\"type\")); // false\n```\n\n**3 in运算符**\n\nin运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。\n\n```\nalert(\"name\" in cat1); // true\nalert(\"type\" in cat1); // true\n```\n\nin运算符还可以用来遍历某个对象的所有属性。\n`for(var prop in cat1) { alert(\"cat1[\"+prop+\"]=\"+cat1[prop]); }`","source":"_posts/2015-08-20-javascript-oop.md","raw":"---\nlayout: post\ntitle:  \"javascript面向对象的程序设计\"\ndate:   2015-08-20 7:43:50\ncategories: javascript\n---\n参考《JavaScript高级程序设计》第三版\n\n阮一峰[Javascript 面向对象编程](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)\n\n## 一.创建对象\n\n#### 1.字面量\n\n```\nvar cat1 = {\n\ncat1.name = \"kitty\";\n\ncat1.color = \"white\";\n\n};\n\nvar cat2 = {\n\ncat2.name = \"greg\";\n\ncat2.color = \"black\";\n\n};\n```\n\n有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。\n\n<!--more-->\n\n#### 2.工厂模式\n\n```\nfunction creatCat(name,color){\n\nvar o = new Object();\n\n0.name = name;\n\n0.color = color;\n\nreturn 0 ;\n\n}\n\nvar cat1 = createCat(\"kitty\",white);\n\nvar cat2 = createCat(\"greg\",black);\n```\n\n\n解决了多个相似对象的问题，但没有解决对象类型识别的问题。\n\n#### 3.构造函数模式\n\n```\nfunction Cat(name,color){\n\nthis.name=name;\n\nthis.color=color;\n\n}\n\nvar cat1 = new  Cat(\"kitty\",\"white\");\n\nvar cat2 = new  Cat(\"greg\",\"black\");\n\nalert(cat1.name); // kitty\n\nalert(cat1.color); // white\n```\n\n即没有return调用，将属性，方法赋给了_this_对象，函数名始终以大写字母开头\n\n任何函数只要通过new调用，就可以作为构造函数\n\n这时cat1和cat2会自动含有一个_constructor_属性，指向它们的构造函数。\n\n```\nalert(cat1.constructor == Cat); //true\nalert(cat2.constructor == Cat); //true\n```\n\nJavascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。\n\n```\nalert(cat1 instanceof Cat); //true\nalert(cat2 instanceof Cat); //true\n```\n\n**构造函数模式的问题：**\n\n构造函数方法很好用，但是存在一个浪费内存的问题。\n\n请看，我们现在为Cat对象添加一个不变的属性\"type\"（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：\n\n```\n function Cat(name,color){\n   this.name = name;\n   this.color = color;\n   this.type = \"猫科动物\";\n   this.eat = function(){alert(\"吃老鼠\");};\n }\n ```\n\n还是采用同样的方法，生成实例：\n\n```\n var cat1 = new Cat(\"kitty\",\"white\");\n var cat2 = new Cat (\"greg\",\"black\");\n alert(cat1.type); // 猫科动物\n cat1.eat(); // 吃老鼠\n```\n\n表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。\n `alert(cat1.eat == cat2.eat); //false`\n能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。\n\n#### 3.原型模式（Prototype模式）\n\n每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。\n\n原型对象可以让所有对象实例共享它所包含的属性和方法。\n\n我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n\n```\nfunction Cat(name,color){\n\nthis.name = name;\n\nthis.color = color;\n\n}\n\nCat.prototype.type = \"猫科动物\";\n\nCat.prototype.eat = function(){alert(\"吃老鼠\")};\n```\n\n然后，生成实例。\n\n```\nvar cat1 = new Cat(\"kitty\",\"white\");\nvar cat2 = new Cat(\"greg\",\"black\");\nalert(cat1.type); // 猫科动物\ncat1.eat(); // 吃老鼠\n```\n\n这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\n`alert(cat1.eat == cat2.eat); //true`\n\n**二、 Prototype模式的验证方法**\n\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n\n**1 isPrototypeOf()**\n\n这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n\n```\nalert(Cat.prototype.isPrototypeOf(cat1)); //true\nalert(Cat.prototype.isPrototypeOf(cat2)); //true\n```\n\n**2 hasOwnProperty()**\n\n每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false\n\n```\nalert(cat1.hasOwnProperty(\"name\")); // true\nalert(cat1.hasOwnProperty(\"type\")); // false\n```\n\n**3 in运算符**\n\nin运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。\n\n```\nalert(\"name\" in cat1); // true\nalert(\"type\" in cat1); // true\n```\n\nin运算符还可以用来遍历某个对象的所有属性。\n`for(var prop in cat1) { alert(\"cat1[\"+prop+\"]=\"+cat1[prop]); }`","slug":"2015-08-20-javascript-oop","published":1,"updated":"2016-06-16T10:46:14.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zky0005hys6zdvtb42z","content":"<p>参考《JavaScript高级程序设计》第三版</p>\n<p>阮一峰<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\" target=\"_blank\" rel=\"external\">Javascript 面向对象编程</a></p>\n<h2 id=\"一-创建对象\"><a href=\"#一-创建对象\" class=\"headerlink\" title=\"一.创建对象\"></a>一.创建对象</h2><h4 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1.字面量\"></a>1.字面量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat1 = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.name = &quot;kitty&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color = &quot;white&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var cat2 = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">cat2.name = &quot;greg&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">cat2.color = &quot;black&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>\n<a id=\"more\"></a>\n<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2.工厂模式\"></a>2.工厂模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function creatCat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">var o = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">0.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">0.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">return 0 ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var cat1 = createCat(&quot;kitty&quot;,white);</span><br><span class=\"line\"></span><br><span class=\"line\">var cat2 = createCat(&quot;greg&quot;,black);</span><br></pre></td></tr></table></figure>\n<p>解决了多个相似对象的问题，但没有解决对象类型识别的问题。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3.构造函数模式\"></a>3.构造函数模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">this.name=name;</span><br><span class=\"line\"></span><br><span class=\"line\">this.color=color;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var cat1 = new  Cat(&quot;kitty&quot;,&quot;white&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var cat2 = new  Cat(&quot;greg&quot;,&quot;black&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(cat1.name); // kitty</span><br><span class=\"line\"></span><br><span class=\"line\">alert(cat1.color); // white</span><br></pre></td></tr></table></figure>\n<p>即没有return调用，将属性，方法赋给了<em>this</em>对象，函数名始终以大写字母开头</p>\n<p>任何函数只要通过new调用，就可以作为构造函数</p>\n<p>这时cat1和cat2会自动含有一个<em>constructor</em>属性，指向它们的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1.constructor == Cat); //true</span><br><span class=\"line\">alert(cat2.constructor == Cat); //true</span><br></pre></td></tr></table></figure>\n<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1 instanceof Cat); //true</span><br><span class=\"line\">alert(cat2 instanceof Cat); //true</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数模式的问题：</strong></p>\n<p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>\n<p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name,color)&#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.color = color;</span><br><span class=\"line\">  this.type = &quot;猫科动物&quot;;</span><br><span class=\"line\">  this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是采用同样的方法，生成实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</span><br><span class=\"line\">var cat2 = new Cat (&quot;greg&quot;,&quot;black&quot;);</span><br><span class=\"line\">alert(cat1.type); // 猫科动物</span><br><span class=\"line\">cat1.eat(); // 吃老鼠</span><br></pre></td></tr></table></figure>\n<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。<br> <code>alert(cat1.eat == cat2.eat); //false</code><br>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>\n<h4 id=\"3-原型模式（Prototype模式）\"><a href=\"#3-原型模式（Prototype模式）\" class=\"headerlink\" title=\"3.原型模式（Prototype模式）\"></a>3.原型模式（Prototype模式）</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>\n<p>原型对象可以让所有对象实例共享它所包含的属性和方法。</p>\n<p>我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">this.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.type = &quot;猫科动物&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后，生成实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</span><br><span class=\"line\">var cat2 = new Cat(&quot;greg&quot;,&quot;black&quot;);</span><br><span class=\"line\">alert(cat1.type); // 猫科动物</span><br><span class=\"line\">cat1.eat(); // 吃老鼠</span><br></pre></td></tr></table></figure>\n<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。<br><code>alert(cat1.eat == cat2.eat); //true</code></p>\n<p><strong>二、 Prototype模式的验证方法</strong></p>\n<p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>\n<p><strong>1 isPrototypeOf()</strong></p>\n<p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class=\"line\">alert(Cat.prototype.isPrototypeOf(cat2)); //true</span><br></pre></td></tr></table></figure>\n<p><strong>2 hasOwnProperty()</strong></p>\n<p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class=\"line\">alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</span><br></pre></td></tr></table></figure>\n<p><strong>3 in运算符</strong></p>\n<p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(&quot;name&quot; in cat1); // true</span><br><span class=\"line\">alert(&quot;type&quot; in cat1); // true</span><br></pre></td></tr></table></figure>\n<p>in运算符还可以用来遍历某个对象的所有属性。<br><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }</code></p>\n","excerpt":"<p>参考《JavaScript高级程序设计》第三版</p>\n<p>阮一峰<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\">Javascript 面向对象编程</a></p>\n<h2 id=\"一-创建对象\"><a href=\"#一-创建对象\" class=\"headerlink\" title=\"一.创建对象\"></a>一.创建对象</h2><h4 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1.字面量\"></a>1.字面量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat1 = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.name = &quot;kitty&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.color = &quot;white&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var cat2 = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">cat2.name = &quot;greg&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">cat2.color = &quot;black&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>","more":"<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2.工厂模式\"></a>2.工厂模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function creatCat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">var o = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">0.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">0.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">return 0 ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var cat1 = createCat(&quot;kitty&quot;,white);</span><br><span class=\"line\"></span><br><span class=\"line\">var cat2 = createCat(&quot;greg&quot;,black);</span><br></pre></td></tr></table></figure>\n<p>解决了多个相似对象的问题，但没有解决对象类型识别的问题。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3.构造函数模式\"></a>3.构造函数模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">this.name=name;</span><br><span class=\"line\"></span><br><span class=\"line\">this.color=color;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var cat1 = new  Cat(&quot;kitty&quot;,&quot;white&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var cat2 = new  Cat(&quot;greg&quot;,&quot;black&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(cat1.name); // kitty</span><br><span class=\"line\"></span><br><span class=\"line\">alert(cat1.color); // white</span><br></pre></td></tr></table></figure>\n<p>即没有return调用，将属性，方法赋给了<em>this</em>对象，函数名始终以大写字母开头</p>\n<p>任何函数只要通过new调用，就可以作为构造函数</p>\n<p>这时cat1和cat2会自动含有一个<em>constructor</em>属性，指向它们的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1.constructor == Cat); //true</span><br><span class=\"line\">alert(cat2.constructor == Cat); //true</span><br></pre></td></tr></table></figure>\n<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1 instanceof Cat); //true</span><br><span class=\"line\">alert(cat2 instanceof Cat); //true</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数模式的问题：</strong></p>\n<p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>\n<p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name,color)&#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.color = color;</span><br><span class=\"line\">  this.type = &quot;猫科动物&quot;;</span><br><span class=\"line\">  this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是采用同样的方法，生成实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</span><br><span class=\"line\">var cat2 = new Cat (&quot;greg&quot;,&quot;black&quot;);</span><br><span class=\"line\">alert(cat1.type); // 猫科动物</span><br><span class=\"line\">cat1.eat(); // 吃老鼠</span><br></pre></td></tr></table></figure>\n<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。<br> <code>alert(cat1.eat == cat2.eat); //false</code><br>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>\n<h4 id=\"3-原型模式（Prototype模式）\"><a href=\"#3-原型模式（Prototype模式）\" class=\"headerlink\" title=\"3.原型模式（Prototype模式）\"></a>3.原型模式（Prototype模式）</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>\n<p>原型对象可以让所有对象实例共享它所包含的属性和方法。</p>\n<p>我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">this.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.type = &quot;猫科动物&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后，生成实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</span><br><span class=\"line\">var cat2 = new Cat(&quot;greg&quot;,&quot;black&quot;);</span><br><span class=\"line\">alert(cat1.type); // 猫科动物</span><br><span class=\"line\">cat1.eat(); // 吃老鼠</span><br></pre></td></tr></table></figure>\n<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。<br><code>alert(cat1.eat == cat2.eat); //true</code></p>\n<p><strong>二、 Prototype模式的验证方法</strong></p>\n<p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>\n<p><strong>1 isPrototypeOf()</strong></p>\n<p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class=\"line\">alert(Cat.prototype.isPrototypeOf(cat2)); //true</span><br></pre></td></tr></table></figure>\n<p><strong>2 hasOwnProperty()</strong></p>\n<p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class=\"line\">alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</span><br></pre></td></tr></table></figure>\n<p><strong>3 in运算符</strong></p>\n<p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(&quot;name&quot; in cat1); // true</span><br><span class=\"line\">alert(&quot;type&quot; in cat1); // true</span><br></pre></td></tr></table></figure>\n<p>in运算符还可以用来遍历某个对象的所有属性。<br><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }</code></p>"},{"layout":"post","title":"Angular  ui-router","date":"2015-11-23T12:17:00.000Z","_content":"UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。\n\n#### 原生ng-route的不足之处：\n\n- 视图不能嵌套。这意味着$scope会发生不必要的重新载入。\n- 路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。\n\n#### 显而易见，ui-router的优势为：\n\n- 提出了\"$state\"的概念，通过改变\\$state来进行URL的跳转和路由\n- 将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置\n\n> 关于ui-router最重要的参考资料是 [ui-router的官方文档](http://angular-ui.github.io/ui-router/site/#/api/ui.router)（http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\n\n#### 代码实现\n\n1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js\n\n<!--more-->\n\n```\n <script src=\"js/angular.js\"></script>\n  <!-- Include the ui-router script -->\n  <script src=\"js/angular-ui-router.min.js\"></script>\n```\n\n2.在模块中引入依赖\n\n```\n  var app = angular.module('routerApp', ['ui.router']);\n```\n\n3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template\n4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。\n5.最后我们来新建一个js文件用来配置路由。\n\n#### 配置路由\n\n示例：\n\n```\napp.config(function ($stateProvider, $urlRouterProvider) {\n  $urlRouterProvider.when(\"\", \"/page1\");\n\t$stateProvider\n    .state('page1', {\n      url: '/page1',\n      templateUrl:'viewpage1.html',\n    }).state('page2', {\n      url: '/page2',\n      templateUrl:'view/page2.html',\n      })\n})\n```\n\n在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。\n\n- state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。\n- 第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。\n-第三个参数是用来设置模板，有两种方法。第一种使用\"template\"，指定一段Html字符串。第二种方法是像示例路由中那样，使用\"templateUrl\"来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）\n\n```\n$stateProvider.state('contacts', {\n  templateUrl: function (stateParams){\n    return '/partials/contacts.' + stateParams + '.html';\n  }\n})\n```\n\n#### 触发激活\n\n路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。\n比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）\n除了上面这种方法，我们还有两种方法来更新视图。\n\n- 调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。\n\n```\n$state.go('page1');  // 指定状态名\n$state.go('page1l', {pageId: 15});  //含参， 相当于跳转到 /page1/42\n```\n\n- 在浏览器地址栏中直接输入url，这是最直接的方法。\n\n#### 传递参数\n\n先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。\n从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html\n在view/resemeList.html中，我们写入如下一行：\n\n```\n<a href=\"\" ui-sref=\"openResume({resumeId:7})\">王大锤的简历</a>\n```\n\n然后，配置路由是这样的：\n\n```\nstate('openResume', {\n        url: '/openResume/{resumeId}',\n        templateUrl:function($stateParams){\n            console.log($stateParams);\n            return 'view/openResume.html'\n        }\n    })\n```\n我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：\n![](http://o7ts2uaks.bkt.clouddn.com/001.png)\n\n在控制台中我们看到了console出的语句\n![控制台](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png)\n\n说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~\n\n#### 嵌套视图\n\n接下来我们来了解一下ui-router区别于ng-router最强大的功能，**嵌套视图**。\n在示例路由的基础上，我们新建一个文件page1-main.html\n现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a>\n在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a>\n路由变成：\n\n```\n.state('page1',{\n  url : '/page1',\n  templateUrl : 'view/page1.html'\n})\n.state('page1.main',{\n  url : '/main',\n  emplateUrl : 'view/page1-main.html'\n})\n```\n\n这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。\n\n#### 多个视图\n\nui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。\n\n```\n<div ui-view></div>\n<div ui-view=\"chart\"></div> \n<div ui-view=\"data\"></div>\n```\n\n路由：\n\n```\n$stateProvider.state(\"home\", {\n  views: {\n    \"\": {\n      template: \"<h1>HELLO!</h1>\"\n    },\n    \"chart\": {\n      template: \"<chart_thing/>\"\n    },\n    \"data\": {\n      template: \"<data_thing/>\"\n    }\n  }\n})\n```","source":"_posts/2015-11-23-angular-uirouter.md","raw":"---\nlayout: post\ntitle:  \"Angular  ui-router\"\ndate:   2015-11-23 20:17\ncategories: front-end javascript\n---\nUI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。\n\n#### 原生ng-route的不足之处：\n\n- 视图不能嵌套。这意味着$scope会发生不必要的重新载入。\n- 路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。\n\n#### 显而易见，ui-router的优势为：\n\n- 提出了\"$state\"的概念，通过改变\\$state来进行URL的跳转和路由\n- 将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置\n\n> 关于ui-router最重要的参考资料是 [ui-router的官方文档](http://angular-ui.github.io/ui-router/site/#/api/ui.router)（http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\n\n#### 代码实现\n\n1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js\n\n<!--more-->\n\n```\n <script src=\"js/angular.js\"></script>\n  <!-- Include the ui-router script -->\n  <script src=\"js/angular-ui-router.min.js\"></script>\n```\n\n2.在模块中引入依赖\n\n```\n  var app = angular.module('routerApp', ['ui.router']);\n```\n\n3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template\n4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。\n5.最后我们来新建一个js文件用来配置路由。\n\n#### 配置路由\n\n示例：\n\n```\napp.config(function ($stateProvider, $urlRouterProvider) {\n  $urlRouterProvider.when(\"\", \"/page1\");\n\t$stateProvider\n    .state('page1', {\n      url: '/page1',\n      templateUrl:'viewpage1.html',\n    }).state('page2', {\n      url: '/page2',\n      templateUrl:'view/page2.html',\n      })\n})\n```\n\n在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。\n\n- state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。\n- 第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。\n-第三个参数是用来设置模板，有两种方法。第一种使用\"template\"，指定一段Html字符串。第二种方法是像示例路由中那样，使用\"templateUrl\"来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）\n\n```\n$stateProvider.state('contacts', {\n  templateUrl: function (stateParams){\n    return '/partials/contacts.' + stateParams + '.html';\n  }\n})\n```\n\n#### 触发激活\n\n路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。\n比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）\n除了上面这种方法，我们还有两种方法来更新视图。\n\n- 调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。\n\n```\n$state.go('page1');  // 指定状态名\n$state.go('page1l', {pageId: 15});  //含参， 相当于跳转到 /page1/42\n```\n\n- 在浏览器地址栏中直接输入url，这是最直接的方法。\n\n#### 传递参数\n\n先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。\n从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html\n在view/resemeList.html中，我们写入如下一行：\n\n```\n<a href=\"\" ui-sref=\"openResume({resumeId:7})\">王大锤的简历</a>\n```\n\n然后，配置路由是这样的：\n\n```\nstate('openResume', {\n        url: '/openResume/{resumeId}',\n        templateUrl:function($stateParams){\n            console.log($stateParams);\n            return 'view/openResume.html'\n        }\n    })\n```\n我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：\n![](http://o7ts2uaks.bkt.clouddn.com/001.png)\n\n在控制台中我们看到了console出的语句\n![控制台](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png)\n\n说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~\n\n#### 嵌套视图\n\n接下来我们来了解一下ui-router区别于ng-router最强大的功能，**嵌套视图**。\n在示例路由的基础上，我们新建一个文件page1-main.html\n现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a>\n在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a>\n路由变成：\n\n```\n.state('page1',{\n  url : '/page1',\n  templateUrl : 'view/page1.html'\n})\n.state('page1.main',{\n  url : '/main',\n  emplateUrl : 'view/page1-main.html'\n})\n```\n\n这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。\n\n#### 多个视图\n\nui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。\n\n```\n<div ui-view></div>\n<div ui-view=\"chart\"></div> \n<div ui-view=\"data\"></div>\n```\n\n路由：\n\n```\n$stateProvider.state(\"home\", {\n  views: {\n    \"\": {\n      template: \"<h1>HELLO!</h1>\"\n    },\n    \"chart\": {\n      template: \"<chart_thing/>\"\n    },\n    \"data\": {\n      template: \"<data_thing/>\"\n    }\n  }\n})\n```","slug":"2015-11-23-angular-uirouter","published":1,"updated":"2016-06-16T10:48:06.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zl20006hys653g826lc","content":"<p>UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。</p>\n<h4 id=\"原生ng-route的不足之处：\"><a href=\"#原生ng-route的不足之处：\" class=\"headerlink\" title=\"原生ng-route的不足之处：\"></a>原生ng-route的不足之处：</h4><ul>\n<li>视图不能嵌套。这意味着$scope会发生不必要的重新载入。</li>\n<li>路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。</li>\n</ul>\n<h4 id=\"显而易见，ui-router的优势为：\"><a href=\"#显而易见，ui-router的优势为：\" class=\"headerlink\" title=\"显而易见，ui-router的优势为：\"></a>显而易见，ui-router的优势为：</h4><ul>\n<li>提出了”$state”的概念，通过改变\\$state来进行URL的跳转和路由</li>\n<li>将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置</li>\n</ul>\n<blockquote>\n<p>关于ui-router最重要的参考资料是 <a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router\" target=\"_blank\" rel=\"external\">ui-router的官方文档</a>（<a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\" target=\"_blank\" rel=\"external\">http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。</a></p>\n</blockquote>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"> &lt;!-- Include the ui-router script --&gt;</span><br><span class=\"line\"> &lt;script src=&quot;js/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>2.在模块中引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;routerApp&apos;, [&apos;ui.router&apos;]);</span><br></pre></td></tr></table></figure>\n<p>3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template<br>4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。<br>5.最后我们来新建一个js文件用来配置路由。</p>\n<h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.config(function ($stateProvider, $urlRouterProvider) &#123;</span><br><span class=\"line\">  $urlRouterProvider.when(&quot;&quot;, &quot;/page1&quot;);</span><br><span class=\"line\">\t$stateProvider</span><br><span class=\"line\">    .state(&apos;page1&apos;, &#123;</span><br><span class=\"line\">      url: &apos;/page1&apos;,</span><br><span class=\"line\">      templateUrl:&apos;viewpage1.html&apos;,</span><br><span class=\"line\">    &#125;).state(&apos;page2&apos;, &#123;</span><br><span class=\"line\">      url: &apos;/page2&apos;,</span><br><span class=\"line\">      templateUrl:&apos;view/page2.html&apos;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。</p>\n<ul>\n<li>state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。</li>\n<li>第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。<br>-第三个参数是用来设置模板，有两种方法。第一种使用”template”，指定一段Html字符串。第二种方法是像示例路由中那样，使用”templateUrl”来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;</span><br><span class=\"line\">  templateUrl: function (stateParams)&#123;</span><br><span class=\"line\">    return &apos;/partials/contacts.&apos; + stateParams + &apos;.html&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"触发激活\"><a href=\"#触发激活\" class=\"headerlink\" title=\"触发激活\"></a>触发激活</h4><p>路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。<br>比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）<br>除了上面这种方法，我们还有两种方法来更新视图。</p>\n<ul>\n<li>调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$state.go(&apos;page1&apos;);  // 指定状态名</span><br><span class=\"line\">$state.go(&apos;page1l&apos;, &#123;pageId: 15&#125;);  //含参， 相当于跳转到 /page1/42</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在浏览器地址栏中直接输入url，这是最直接的方法。</li>\n</ul>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。<br>从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html<br>在view/resemeList.html中，我们写入如下一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;&quot; ui-sref=&quot;openResume(&#123;resumeId:7&#125;)&quot;&gt;王大锤的简历&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>然后，配置路由是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state(&apos;openResume&apos;, &#123;</span><br><span class=\"line\">        url: &apos;/openResume/&#123;resumeId&#125;&apos;,</span><br><span class=\"line\">        templateUrl:function($stateParams)&#123;</span><br><span class=\"line\">            console.log($stateParams);</span><br><span class=\"line\">            return &apos;view/openResume.html&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/001.png\" alt=\"\"></p>\n<p>在控制台中我们看到了console出的语句<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png\" alt=\"控制台\"></p>\n<p>说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p>接下来我们来了解一下ui-router区别于ng-router最强大的功能，<strong>嵌套视图</strong>。<br>在示例路由的基础上，我们新建一个文件page1-main.html<br>现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a><br>在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a><br>路由变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.state(&apos;page1&apos;,&#123;</span><br><span class=\"line\">  url : &apos;/page1&apos;,</span><br><span class=\"line\">  templateUrl : &apos;view/page1.html&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.state(&apos;page1.main&apos;,&#123;</span><br><span class=\"line\">  url : &apos;/main&apos;,</span><br><span class=\"line\">  emplateUrl : &apos;view/page1-main.html&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。</p>\n<h4 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h4><p>ui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ui-view&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div ui-view=&quot;chart&quot;&gt;&lt;/div&gt; </span><br><span class=\"line\">&lt;div ui-view=&quot;data&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&quot;home&quot;, &#123;</span><br><span class=\"line\">  views: &#123;</span><br><span class=\"line\">    &quot;&quot;: &#123;</span><br><span class=\"line\">      template: &quot;&lt;h1&gt;HELLO!&lt;/h1&gt;&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;chart&quot;: &#123;</span><br><span class=\"line\">      template: &quot;&lt;chart_thing/&gt;&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;data&quot;: &#123;</span><br><span class=\"line\">      template: &quot;&lt;data_thing/&gt;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","excerpt":"<p>UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。</p>\n<h4 id=\"原生ng-route的不足之处：\"><a href=\"#原生ng-route的不足之处：\" class=\"headerlink\" title=\"原生ng-route的不足之处：\"></a>原生ng-route的不足之处：</h4><ul>\n<li>视图不能嵌套。这意味着$scope会发生不必要的重新载入。</li>\n<li>路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。</li>\n</ul>\n<h4 id=\"显而易见，ui-router的优势为：\"><a href=\"#显而易见，ui-router的优势为：\" class=\"headerlink\" title=\"显而易见，ui-router的优势为：\"></a>显而易见，ui-router的优势为：</h4><ul>\n<li>提出了”$state”的概念，通过改变\\$state来进行URL的跳转和路由</li>\n<li>将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置</li>\n</ul>\n<blockquote>\n<p>关于ui-router最重要的参考资料是 <a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router\">ui-router的官方文档</a>（<a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\">http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。</a></p>\n</blockquote>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"> &lt;!-- Include the ui-router script --&gt;</span><br><span class=\"line\"> &lt;script src=&quot;js/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>2.在模块中引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;routerApp&apos;, [&apos;ui.router&apos;]);</span><br></pre></td></tr></table></figure>\n<p>3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template<br>4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。<br>5.最后我们来新建一个js文件用来配置路由。</p>\n<h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.config(function ($stateProvider, $urlRouterProvider) &#123;</span><br><span class=\"line\">  $urlRouterProvider.when(&quot;&quot;, &quot;/page1&quot;);</span><br><span class=\"line\">\t$stateProvider</span><br><span class=\"line\">    .state(&apos;page1&apos;, &#123;</span><br><span class=\"line\">      url: &apos;/page1&apos;,</span><br><span class=\"line\">      templateUrl:&apos;viewpage1.html&apos;,</span><br><span class=\"line\">    &#125;).state(&apos;page2&apos;, &#123;</span><br><span class=\"line\">      url: &apos;/page2&apos;,</span><br><span class=\"line\">      templateUrl:&apos;view/page2.html&apos;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。</p>\n<ul>\n<li>state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。</li>\n<li>第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。<br>-第三个参数是用来设置模板，有两种方法。第一种使用”template”，指定一段Html字符串。第二种方法是像示例路由中那样，使用”templateUrl”来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;</span><br><span class=\"line\">  templateUrl: function (stateParams)&#123;</span><br><span class=\"line\">    return &apos;/partials/contacts.&apos; + stateParams + &apos;.html&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"触发激活\"><a href=\"#触发激活\" class=\"headerlink\" title=\"触发激活\"></a>触发激活</h4><p>路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。<br>比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）<br>除了上面这种方法，我们还有两种方法来更新视图。</p>\n<ul>\n<li>调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$state.go(&apos;page1&apos;);  // 指定状态名</span><br><span class=\"line\">$state.go(&apos;page1l&apos;, &#123;pageId: 15&#125;);  //含参， 相当于跳转到 /page1/42</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在浏览器地址栏中直接输入url，这是最直接的方法。</li>\n</ul>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。<br>从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html<br>在view/resemeList.html中，我们写入如下一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;&quot; ui-sref=&quot;openResume(&#123;resumeId:7&#125;)&quot;&gt;王大锤的简历&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>然后，配置路由是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state(&apos;openResume&apos;, &#123;</span><br><span class=\"line\">        url: &apos;/openResume/&#123;resumeId&#125;&apos;,</span><br><span class=\"line\">        templateUrl:function($stateParams)&#123;</span><br><span class=\"line\">            console.log($stateParams);</span><br><span class=\"line\">            return &apos;view/openResume.html&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/001.png\" alt=\"\"></p>\n<p>在控制台中我们看到了console出的语句<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png\" alt=\"控制台\"></p>\n<p>说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p>接下来我们来了解一下ui-router区别于ng-router最强大的功能，<strong>嵌套视图</strong>。<br>在示例路由的基础上，我们新建一个文件page1-main.html<br>现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a><br>在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a><br>路由变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.state(&apos;page1&apos;,&#123;</span><br><span class=\"line\">  url : &apos;/page1&apos;,</span><br><span class=\"line\">  templateUrl : &apos;view/page1.html&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.state(&apos;page1.main&apos;,&#123;</span><br><span class=\"line\">  url : &apos;/main&apos;,</span><br><span class=\"line\">  emplateUrl : &apos;view/page1-main.html&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。</p>\n<h4 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h4><p>ui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ui-view&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div ui-view=&quot;chart&quot;&gt;&lt;/div&gt; </span><br><span class=\"line\">&lt;div ui-view=&quot;data&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&quot;home&quot;, &#123;</span><br><span class=\"line\">  views: &#123;</span><br><span class=\"line\">    &quot;&quot;: &#123;</span><br><span class=\"line\">      template: &quot;&lt;h1&gt;HELLO!&lt;/h1&gt;&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;chart&quot;: &#123;</span><br><span class=\"line\">      template: &quot;&lt;chart_thing/&gt;&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;data&quot;: &#123;</span><br><span class=\"line\">      template: &quot;&lt;data_thing/&gt;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"How does data binding work in AngularJS","date":"2016-06-05T07:28:00.000Z","_content":"\nAngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。\n\n`$apply()`这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有`$digest()`方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。\n\n### 关于$watch\n\n每一次你在UI中绑定什么东西时你就会往`$watch`的队列中插入一条`$watch`，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：\n\n```\nUser: <input type=\"text\" ng-model=\"user\" />\nPassword: <input type=\"password\" ng-model=\"pass\" />\n```\n\n在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。\n\n<!--more-->\n\n每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。\n\n一个watcher包含了三个东西：\n\n- 它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西\n\n- 这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty\n\n- 被触发执行的函数\n\n```\n$$watchers = [\n    {\n        eq: false, // 表明我们是否需要检查对象级别的相等\n        fn: function( newValue, oldValue ) {}, // 这是我们提供的监听器函数\n        last: 'Ryan', // 变量的最新值\n        exp: function(){}, // 我们提供的watchExp函数\n        get: function(){} // Angular's编译后的watchExp函数\n    }\n];\n```\n\n定义监听器的几种方法：\n1.把$watch设置为$scope的一种属性:`$scope.$watch('person.username', validateUnique);`\n2.插入angular表达式:`<p>username: {{person.username}}</p>`\n3.使用类似于ng-model的指令来定义监听器:`<input ng-model=\"person.username />`\n\n\n\n\n### 关于$digest和$apply\n如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。\n\n当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。\n\nAngularJS的$apply函数代码如下所示：\n\n```\n$apply: function(expr) {\n    try {\n      beginPhase('$apply');\n      return this.$eval(expr);\n    } catch (e) {\n      $exceptionHandler(e);\n    } finally {\n      clearPhase();\n      try {\n        $rootScope.$digest();\n      } catch (e) {\n        $exceptionHandler(e);\n        throw e;\n      }\n    }\n}\n```\n由此可见，使用$apply可带参数。\n\n$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。\n\n监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。\n\n$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。\n\n### build your own dirty-checking\n了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。\n首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];   \n};\n\nScope.prototype.$watch = function( ) {\n\n};\n\nScope.prototype.$digest = function( ) {\n\n};\n```\n\n设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：\n\n```\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n```\n\n如果没有传入listener的话我们会把它设置为空函数。\n$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。\n\n```\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n```\n\n下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest\n\n```\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log(newValue, oldValue);\n} );\n\n$scope.$digest();\n```\n\n我们发现在控制台输出了`Ryan undefined`，成功了！\n最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];\n};\n\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n\n\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\nvar element = document.querySelectorAll('input');\n\nelement[0].onkeyup = function() {\n    $scope.name = element[0].value;\n\n    $scope.$digest();\n};\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log('Input value updated - it is now ' + newValue);\n\n    element[0].value = $scope.name;\n} );\n\nvar updateScopeValue = function updateScopeValue( ) {\n    $scope.name = 'Bob';\n    $scope.$digest();\n};\n```\n\n### 参考内容\n\n* [RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves](https://ryanclark.me/how-angularjs-implements-dirty-checking)\n* [stackoverflow:How does data binding work in AngularJS?](http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs)\n* [徐飞:Angular沉思录（一）](https://github.com/xufei/blog/issues/10)\n* [angular-tips:$watch How the $apply Runs a $digest](http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/)\n* [IBM developerWorks:AngularJS 作用域与数据绑定机制](https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/)\n\n\n\n\n\n","source":"_posts/2016-06-05-angular-data-binding.markdown","raw":"---\nlayout: post\ntitle:  \"How does data binding work in AngularJS\"\ndate:   2016-06-05 15:28\ncategories: front-end javascript\n---\n\nAngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。\n\n`$apply()`这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有`$digest()`方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。\n\n### 关于$watch\n\n每一次你在UI中绑定什么东西时你就会往`$watch`的队列中插入一条`$watch`，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：\n\n```\nUser: <input type=\"text\" ng-model=\"user\" />\nPassword: <input type=\"password\" ng-model=\"pass\" />\n```\n\n在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。\n\n<!--more-->\n\n每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。\n\n一个watcher包含了三个东西：\n\n- 它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西\n\n- 这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty\n\n- 被触发执行的函数\n\n```\n$$watchers = [\n    {\n        eq: false, // 表明我们是否需要检查对象级别的相等\n        fn: function( newValue, oldValue ) {}, // 这是我们提供的监听器函数\n        last: 'Ryan', // 变量的最新值\n        exp: function(){}, // 我们提供的watchExp函数\n        get: function(){} // Angular's编译后的watchExp函数\n    }\n];\n```\n\n定义监听器的几种方法：\n1.把$watch设置为$scope的一种属性:`$scope.$watch('person.username', validateUnique);`\n2.插入angular表达式:`<p>username: {{person.username}}</p>`\n3.使用类似于ng-model的指令来定义监听器:`<input ng-model=\"person.username />`\n\n\n\n\n### 关于$digest和$apply\n如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。\n\n当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。\n\nAngularJS的$apply函数代码如下所示：\n\n```\n$apply: function(expr) {\n    try {\n      beginPhase('$apply');\n      return this.$eval(expr);\n    } catch (e) {\n      $exceptionHandler(e);\n    } finally {\n      clearPhase();\n      try {\n        $rootScope.$digest();\n      } catch (e) {\n        $exceptionHandler(e);\n        throw e;\n      }\n    }\n}\n```\n由此可见，使用$apply可带参数。\n\n$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。\n\n监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。\n\n$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。\n\n### build your own dirty-checking\n了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。\n首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];   \n};\n\nScope.prototype.$watch = function( ) {\n\n};\n\nScope.prototype.$digest = function( ) {\n\n};\n```\n\n设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：\n\n```\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n```\n\n如果没有传入listener的话我们会把它设置为空函数。\n$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。\n\n```\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n```\n\n下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest\n\n```\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log(newValue, oldValue);\n} );\n\n$scope.$digest();\n```\n\n我们发现在控制台输出了`Ryan undefined`，成功了！\n最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];\n};\n\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n\n\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\nvar element = document.querySelectorAll('input');\n\nelement[0].onkeyup = function() {\n    $scope.name = element[0].value;\n\n    $scope.$digest();\n};\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log('Input value updated - it is now ' + newValue);\n\n    element[0].value = $scope.name;\n} );\n\nvar updateScopeValue = function updateScopeValue( ) {\n    $scope.name = 'Bob';\n    $scope.$digest();\n};\n```\n\n### 参考内容\n\n* [RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves](https://ryanclark.me/how-angularjs-implements-dirty-checking)\n* [stackoverflow:How does data binding work in AngularJS?](http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs)\n* [徐飞:Angular沉思录（一）](https://github.com/xufei/blog/issues/10)\n* [angular-tips:$watch How the $apply Runs a $digest](http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/)\n* [IBM developerWorks:AngularJS 作用域与数据绑定机制](https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/)\n\n\n\n\n\n","slug":"2016-06-05-angular-data-binding","published":1,"updated":"2016-06-17T11:07:49.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zl60008hys65tybueac","content":"<p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>\n<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>\n<h3 id=\"关于-watch\"><a href=\"#关于-watch\" class=\"headerlink\" title=\"关于$watch\"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</span><br><span class=\"line\">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p>\n<a id=\"more\"></a>\n<p>每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。</p>\n<p>一个watcher包含了三个东西：</p>\n<ul>\n<li><p>它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西</p>\n</li>\n<li><p>这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty</p>\n</li>\n<li><p>被触发执行的函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$watchers = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eq: false, // 表明我们是否需要检查对象级别的相等</span><br><span class=\"line\">        fn: function( newValue, oldValue ) &#123;&#125;, // 这是我们提供的监听器函数</span><br><span class=\"line\">        last: &apos;Ryan&apos;, // 变量的最新值</span><br><span class=\"line\">        exp: function()&#123;&#125;, // 我们提供的watchExp函数</span><br><span class=\"line\">        get: function()&#123;&#125; // Angular&apos;s编译后的watchExp函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>定义监听器的几种方法：<br>1.把$watch设置为$scope的一种属性:<code>$scope.$watch(&#39;person.username&#39;, validateUnique);</code><br>2.插入angular表达式:<code>&lt;p&gt;username: &lt;/p&gt;</code><br>3.使用类似于ng-model的指令来定义监听器:<code>&lt;input ng-model=&quot;person.username /&gt;</code></p>\n<h3 id=\"关于-digest和-apply\"><a href=\"#关于-digest和-apply\" class=\"headerlink\" title=\"关于$digest和$apply\"></a>关于$digest和$apply</h3><p>如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。</p>\n<p>当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。</p>\n<p>AngularJS的$apply函数代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$apply: function(expr) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      beginPhase(&apos;$apply&apos;);</span><br><span class=\"line\">      return this.$eval(expr);</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">      $exceptionHandler(e);</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      clearPhase();</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        $rootScope.$digest();</span><br><span class=\"line\">      &#125; catch (e) &#123;</span><br><span class=\"line\">        $exceptionHandler(e);</span><br><span class=\"line\">        throw e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可见，使用$apply可带参数。</p>\n<p>$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。</p>\n<p>监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。</p>\n<p>$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。</p>\n<h3 id=\"build-your-own-dirty-checking\"><a href=\"#build-your-own-dirty-checking\" class=\"headerlink\" title=\"build your own dirty-checking\"></a>build your own dirty-checking</h3><p>了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。<br>首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Scope = function( ) &#123;</span><br><span class=\"line\">    this.$$watchers = [];   </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$watch = function( ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$digest = function( ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</span><br><span class=\"line\">    this.$$watchers.push( &#123;</span><br><span class=\"line\">        watchExp: watchExp,</span><br><span class=\"line\">        listener: listener || function() &#123;&#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果没有传入listener的话我们会把它设置为空函数。<br>$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scope.prototype.$digest = function( ) &#123;</span><br><span class=\"line\">    var dirty;</span><br><span class=\"line\"></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">            dirty = false;</span><br><span class=\"line\"></span><br><span class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</span><br><span class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</span><br><span class=\"line\">                    oldValue = this.$$watchers[i].last;</span><br><span class=\"line\"></span><br><span class=\"line\">                if( oldValue !== newValue ) &#123;</span><br><span class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</span><br><span class=\"line\"></span><br><span class=\"line\">                    dirty = true;</span><br><span class=\"line\"></span><br><span class=\"line\">                    this.$$watchers[i].last = newValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; while(dirty);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var $scope = new Scope();</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.name = &apos;Ryan&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.$watch(function()&#123;</span><br><span class=\"line\">    return $scope.name;</span><br><span class=\"line\">&#125;, function( newValue, oldValue ) &#123;</span><br><span class=\"line\">    console.log(newValue, oldValue);</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.$digest();</span><br></pre></td></tr></table></figure>\n<p>我们发现在控制台输出了<code>Ryan undefined</code>，成功了！<br>最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Scope = function( ) &#123;</span><br><span class=\"line\">    this.$$watchers = [];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</span><br><span class=\"line\">    this.$$watchers.push( &#123;</span><br><span class=\"line\">        watchExp: watchExp,</span><br><span class=\"line\">        listener: listener || function() &#123;&#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$digest = function( ) &#123;</span><br><span class=\"line\">    var dirty;</span><br><span class=\"line\"></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">            dirty = false;</span><br><span class=\"line\"></span><br><span class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</span><br><span class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</span><br><span class=\"line\">                    oldValue = this.$$watchers[i].last;</span><br><span class=\"line\"></span><br><span class=\"line\">                if( oldValue !== newValue ) &#123;</span><br><span class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</span><br><span class=\"line\"></span><br><span class=\"line\">                    dirty = true;</span><br><span class=\"line\"></span><br><span class=\"line\">                    this.$$watchers[i].last = newValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; while(dirty);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var $scope = new Scope();</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.name = &apos;Ryan&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var element = document.querySelectorAll(&apos;input&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">element[0].onkeyup = function() &#123;</span><br><span class=\"line\">    $scope.name = element[0].value;</span><br><span class=\"line\"></span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.$watch(function()&#123;</span><br><span class=\"line\">    return $scope.name;</span><br><span class=\"line\">&#125;, function( newValue, oldValue ) &#123;</span><br><span class=\"line\">    console.log(&apos;Input value updated - it is now &apos; + newValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    element[0].value = $scope.name;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">var updateScopeValue = function updateScopeValue( ) &#123;</span><br><span class=\"line\">    $scope.name = &apos;Bob&apos;;</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://ryanclark.me/how-angularjs-implements-dirty-checking\" target=\"_blank\" rel=\"external\">RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs\" target=\"_blank\" rel=\"external\">stackoverflow:How does data binding work in AngularJS?</a></li>\n<li><a href=\"https://github.com/xufei/blog/issues/10\" target=\"_blank\" rel=\"external\">徐飞:Angular沉思录（一）</a></li>\n<li><a href=\"http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/\" target=\"_blank\" rel=\"external\">angular-tips:$watch How the $apply Runs a $digest</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/\" target=\"_blank\" rel=\"external\">IBM developerWorks:AngularJS 作用域与数据绑定机制</a></li>\n</ul>\n","excerpt":"<p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>\n<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>\n<h3 id=\"关于-watch\"><a href=\"#关于-watch\" class=\"headerlink\" title=\"关于$watch\"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</span><br><span class=\"line\">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p>","more":"<p>每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。</p>\n<p>一个watcher包含了三个东西：</p>\n<ul>\n<li><p>它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西</p>\n</li>\n<li><p>这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty</p>\n</li>\n<li><p>被触发执行的函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$watchers = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eq: false, // 表明我们是否需要检查对象级别的相等</span><br><span class=\"line\">        fn: function( newValue, oldValue ) &#123;&#125;, // 这是我们提供的监听器函数</span><br><span class=\"line\">        last: &apos;Ryan&apos;, // 变量的最新值</span><br><span class=\"line\">        exp: function()&#123;&#125;, // 我们提供的watchExp函数</span><br><span class=\"line\">        get: function()&#123;&#125; // Angular&apos;s编译后的watchExp函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>定义监听器的几种方法：<br>1.把$watch设置为$scope的一种属性:<code>$scope.$watch(&#39;person.username&#39;, validateUnique);</code><br>2.插入angular表达式:<code>&lt;p&gt;username: &lt;/p&gt;</code><br>3.使用类似于ng-model的指令来定义监听器:<code>&lt;input ng-model=&quot;person.username /&gt;</code></p>\n<h3 id=\"关于-digest和-apply\"><a href=\"#关于-digest和-apply\" class=\"headerlink\" title=\"关于$digest和$apply\"></a>关于$digest和$apply</h3><p>如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。</p>\n<p>当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。</p>\n<p>AngularJS的$apply函数代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$apply: function(expr) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      beginPhase(&apos;$apply&apos;);</span><br><span class=\"line\">      return this.$eval(expr);</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">      $exceptionHandler(e);</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      clearPhase();</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        $rootScope.$digest();</span><br><span class=\"line\">      &#125; catch (e) &#123;</span><br><span class=\"line\">        $exceptionHandler(e);</span><br><span class=\"line\">        throw e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可见，使用$apply可带参数。</p>\n<p>$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。</p>\n<p>监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。</p>\n<p>$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。</p>\n<h3 id=\"build-your-own-dirty-checking\"><a href=\"#build-your-own-dirty-checking\" class=\"headerlink\" title=\"build your own dirty-checking\"></a>build your own dirty-checking</h3><p>了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。<br>首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Scope = function( ) &#123;</span><br><span class=\"line\">    this.$$watchers = [];   </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$watch = function( ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$digest = function( ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</span><br><span class=\"line\">    this.$$watchers.push( &#123;</span><br><span class=\"line\">        watchExp: watchExp,</span><br><span class=\"line\">        listener: listener || function() &#123;&#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果没有传入listener的话我们会把它设置为空函数。<br>$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scope.prototype.$digest = function( ) &#123;</span><br><span class=\"line\">    var dirty;</span><br><span class=\"line\"></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">            dirty = false;</span><br><span class=\"line\"></span><br><span class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</span><br><span class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</span><br><span class=\"line\">                    oldValue = this.$$watchers[i].last;</span><br><span class=\"line\"></span><br><span class=\"line\">                if( oldValue !== newValue ) &#123;</span><br><span class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</span><br><span class=\"line\"></span><br><span class=\"line\">                    dirty = true;</span><br><span class=\"line\"></span><br><span class=\"line\">                    this.$$watchers[i].last = newValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; while(dirty);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var $scope = new Scope();</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.name = &apos;Ryan&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.$watch(function()&#123;</span><br><span class=\"line\">    return $scope.name;</span><br><span class=\"line\">&#125;, function( newValue, oldValue ) &#123;</span><br><span class=\"line\">    console.log(newValue, oldValue);</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.$digest();</span><br></pre></td></tr></table></figure>\n<p>我们发现在控制台输出了<code>Ryan undefined</code>，成功了！<br>最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Scope = function( ) &#123;</span><br><span class=\"line\">    this.$$watchers = [];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</span><br><span class=\"line\">    this.$$watchers.push( &#123;</span><br><span class=\"line\">        watchExp: watchExp,</span><br><span class=\"line\">        listener: listener || function() &#123;&#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Scope.prototype.$digest = function( ) &#123;</span><br><span class=\"line\">    var dirty;</span><br><span class=\"line\"></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">            dirty = false;</span><br><span class=\"line\"></span><br><span class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</span><br><span class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</span><br><span class=\"line\">                    oldValue = this.$$watchers[i].last;</span><br><span class=\"line\"></span><br><span class=\"line\">                if( oldValue !== newValue ) &#123;</span><br><span class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</span><br><span class=\"line\"></span><br><span class=\"line\">                    dirty = true;</span><br><span class=\"line\"></span><br><span class=\"line\">                    this.$$watchers[i].last = newValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; while(dirty);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var $scope = new Scope();</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.name = &apos;Ryan&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var element = document.querySelectorAll(&apos;input&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">element[0].onkeyup = function() &#123;</span><br><span class=\"line\">    $scope.name = element[0].value;</span><br><span class=\"line\"></span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$scope.$watch(function()&#123;</span><br><span class=\"line\">    return $scope.name;</span><br><span class=\"line\">&#125;, function( newValue, oldValue ) &#123;</span><br><span class=\"line\">    console.log(&apos;Input value updated - it is now &apos; + newValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    element[0].value = $scope.name;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">var updateScopeValue = function updateScopeValue( ) &#123;</span><br><span class=\"line\">    $scope.name = &apos;Bob&apos;;</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://ryanclark.me/how-angularjs-implements-dirty-checking\">RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs\">stackoverflow:How does data binding work in AngularJS?</a></li>\n<li><a href=\"https://github.com/xufei/blog/issues/10\">徐飞:Angular沉思录（一）</a></li>\n<li><a href=\"http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/\">angular-tips:$watch How the $apply Runs a $digest</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/\">IBM developerWorks:AngularJS 作用域与数据绑定机制</a></li>\n</ul>"},{"layout":"post","title":"Viewport-Percentage (or Viewport-Relative) Lengths","date":"2016-03-17T11:16:00.000Z","_content":"\n### 什么是视区百分比长度（viewport-percentage lengths）？\n\n先看一下W3C给出的定义：\n\n >The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.\n\n意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。`initial containing block`意为浏览器内部的可视区域，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n\n<!--more-->\n\n视区单位有`vh` (相对于视区高度), `vw`(相对于视区宽度), `vmin` (相对于视区高度或宽度，取决于哪个更小) and `vmax` (类似于vw但取决于哪个更大)。\n\n### 它是如何分配浏览器高度的？\n\n我们可以假借`vh`: `1vh`相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。\n\n### 浏览器兼容性？\n\n![caniuse](http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png)\n\n在css属性可用性查询网站[caniuse](http://caniuse.com/#search=viewport%20units)中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，**Chrome 20+, IE9+ ,FireFox19+以及Safari6** 都是支持的。\n\n### 100vh与100%的区别？\n\n我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于`window.innerWidth/window.innerHeight`的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）\n就像这个例子：\n\n```\n<body style=\"height:100%\">\n    <div style=\"height:200px\">\n        <p style=\"height:100%; display:block;\">Hello, world!</p>\n    </div>\n</body>\n```\n\n虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px\n\n### 如何用百分比实现同vh一样的效果？\n\n某些情况下，`vw`, `vh`所产生的效果与百分比`%单位`无异，尤其对于`absolute/fixed`定位属性的元素。比如：\n```\n{\n    position: fixed;\n    top: 100%;\n    top: 100vh;\n    left: 5%;\n    left: 5vw;\n    right: 5%;\n    right: 5vw;\n}\n```\n支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。\n\n### 参考内容\n\n* [James Donnelly__stackoverflow](http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window):视区单位布道\n* [视区相关单位_张鑫旭博客](http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/):更多相关与视区单位应用场景的尝试\n* [JS,Jquery获取各种屏幕的宽度和高度](http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html):复习一下有关屏幕高度的知识","source":"_posts/2016-03-17-vieport-percentage.md","raw":"---\nlayout: post\ntitle:  \"Viewport-Percentage (or Viewport-Relative) Lengths\"\ndate:   2016-03-17 19:16\ncategories: front-end css\n---\n\n### 什么是视区百分比长度（viewport-percentage lengths）？\n\n先看一下W3C给出的定义：\n\n >The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.\n\n意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。`initial containing block`意为浏览器内部的可视区域，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n\n<!--more-->\n\n视区单位有`vh` (相对于视区高度), `vw`(相对于视区宽度), `vmin` (相对于视区高度或宽度，取决于哪个更小) and `vmax` (类似于vw但取决于哪个更大)。\n\n### 它是如何分配浏览器高度的？\n\n我们可以假借`vh`: `1vh`相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。\n\n### 浏览器兼容性？\n\n![caniuse](http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png)\n\n在css属性可用性查询网站[caniuse](http://caniuse.com/#search=viewport%20units)中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，**Chrome 20+, IE9+ ,FireFox19+以及Safari6** 都是支持的。\n\n### 100vh与100%的区别？\n\n我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于`window.innerWidth/window.innerHeight`的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）\n就像这个例子：\n\n```\n<body style=\"height:100%\">\n    <div style=\"height:200px\">\n        <p style=\"height:100%; display:block;\">Hello, world!</p>\n    </div>\n</body>\n```\n\n虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px\n\n### 如何用百分比实现同vh一样的效果？\n\n某些情况下，`vw`, `vh`所产生的效果与百分比`%单位`无异，尤其对于`absolute/fixed`定位属性的元素。比如：\n```\n{\n    position: fixed;\n    top: 100%;\n    top: 100vh;\n    left: 5%;\n    left: 5vw;\n    right: 5%;\n    right: 5vw;\n}\n```\n支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。\n\n### 参考内容\n\n* [James Donnelly__stackoverflow](http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window):视区单位布道\n* [视区相关单位_张鑫旭博客](http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/):更多相关与视区单位应用场景的尝试\n* [JS,Jquery获取各种屏幕的宽度和高度](http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html):复习一下有关屏幕高度的知识","slug":"2016-03-17-vieport-percentage","published":1,"updated":"2016-06-16T10:50:15.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zla000ahys6eumbjuaj","content":"<h3 id=\"什么是视区百分比长度（viewport-percentage-lengths）？\"><a href=\"#什么是视区百分比长度（viewport-percentage-lengths）？\" class=\"headerlink\" title=\"什么是视区百分比长度（viewport-percentage lengths）？\"></a>什么是视区百分比长度（viewport-percentage lengths）？</h3><p>先看一下W3C给出的定义：</p>\n<blockquote>\n<p>The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>\n</blockquote>\n<p>意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。<code>initial containing block</code>意为浏览器内部的可视区域，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>\n<a id=\"more\"></a>\n<p>视区单位有<code>vh</code> (相对于视区高度), <code>vw</code>(相对于视区宽度), <code>vmin</code> (相对于视区高度或宽度，取决于哪个更小) and <code>vmax</code> (类似于vw但取决于哪个更大)。</p>\n<h3 id=\"它是如何分配浏览器高度的？\"><a href=\"#它是如何分配浏览器高度的？\" class=\"headerlink\" title=\"它是如何分配浏览器高度的？\"></a>它是如何分配浏览器高度的？</h3><p>我们可以假借<code>vh</code>: <code>1vh</code>相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。</p>\n<h3 id=\"浏览器兼容性？\"><a href=\"#浏览器兼容性？\" class=\"headerlink\" title=\"浏览器兼容性？\"></a>浏览器兼容性？</h3><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png\" alt=\"caniuse\"></p>\n<p>在css属性可用性查询网站<a href=\"http://caniuse.com/#search=viewport%20units\" target=\"_blank\" rel=\"external\">caniuse</a>中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，<strong>Chrome 20+, IE9+ ,FireFox19+以及Safari6</strong> 都是支持的。</p>\n<h3 id=\"100vh与100-的区别？\"><a href=\"#100vh与100-的区别？\" class=\"headerlink\" title=\"100vh与100%的区别？\"></a>100vh与100%的区别？</h3><p>我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于<code>window.innerWidth/window.innerHeight</code>的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）<br>就像这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body style=&quot;height:100%&quot;&gt;</span><br><span class=\"line\">    &lt;div style=&quot;height:200px&quot;&gt;</span><br><span class=\"line\">        &lt;p style=&quot;height:100%; display:block;&quot;&gt;Hello, world!&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px</p>\n<h3 id=\"如何用百分比实现同vh一样的效果？\"><a href=\"#如何用百分比实现同vh一样的效果？\" class=\"headerlink\" title=\"如何用百分比实现同vh一样的效果？\"></a>如何用百分比实现同vh一样的效果？</h3><p>某些情况下，<code>vw</code>, <code>vh</code>所产生的效果与百分比<code>%单位</code>无异，尤其对于<code>absolute/fixed</code>定位属性的元素。比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position: fixed;</span><br><span class=\"line\">    top: 100%;</span><br><span class=\"line\">    top: 100vh;</span><br><span class=\"line\">    left: 5%;</span><br><span class=\"line\">    left: 5vw;</span><br><span class=\"line\">    right: 5%;</span><br><span class=\"line\">    right: 5vw;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window\" target=\"_blank\" rel=\"external\">James Donnelly__stackoverflow</a>:视区单位布道</li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/\" target=\"_blank\" rel=\"external\">视区相关单位_张鑫旭博客</a>:更多相关与视区单位应用场景的尝试</li>\n<li><a href=\"http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html\" target=\"_blank\" rel=\"external\">JS,Jquery获取各种屏幕的宽度和高度</a>:复习一下有关屏幕高度的知识</li>\n</ul>\n","excerpt":"<h3 id=\"什么是视区百分比长度（viewport-percentage-lengths）？\"><a href=\"#什么是视区百分比长度（viewport-percentage-lengths）？\" class=\"headerlink\" title=\"什么是视区百分比长度（viewport-percentage lengths）？\"></a>什么是视区百分比长度（viewport-percentage lengths）？</h3><p>先看一下W3C给出的定义：</p>\n<blockquote>\n<p>The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>\n</blockquote>\n<p>意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。<code>initial containing block</code>意为浏览器内部的可视区域，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>","more":"<p>视区单位有<code>vh</code> (相对于视区高度), <code>vw</code>(相对于视区宽度), <code>vmin</code> (相对于视区高度或宽度，取决于哪个更小) and <code>vmax</code> (类似于vw但取决于哪个更大)。</p>\n<h3 id=\"它是如何分配浏览器高度的？\"><a href=\"#它是如何分配浏览器高度的？\" class=\"headerlink\" title=\"它是如何分配浏览器高度的？\"></a>它是如何分配浏览器高度的？</h3><p>我们可以假借<code>vh</code>: <code>1vh</code>相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。</p>\n<h3 id=\"浏览器兼容性？\"><a href=\"#浏览器兼容性？\" class=\"headerlink\" title=\"浏览器兼容性？\"></a>浏览器兼容性？</h3><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png\" alt=\"caniuse\"></p>\n<p>在css属性可用性查询网站<a href=\"http://caniuse.com/#search=viewport%20units\">caniuse</a>中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，<strong>Chrome 20+, IE9+ ,FireFox19+以及Safari6</strong> 都是支持的。</p>\n<h3 id=\"100vh与100-的区别？\"><a href=\"#100vh与100-的区别？\" class=\"headerlink\" title=\"100vh与100%的区别？\"></a>100vh与100%的区别？</h3><p>我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于<code>window.innerWidth/window.innerHeight</code>的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）<br>就像这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body style=&quot;height:100%&quot;&gt;</span><br><span class=\"line\">    &lt;div style=&quot;height:200px&quot;&gt;</span><br><span class=\"line\">        &lt;p style=&quot;height:100%; display:block;&quot;&gt;Hello, world!&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px</p>\n<h3 id=\"如何用百分比实现同vh一样的效果？\"><a href=\"#如何用百分比实现同vh一样的效果？\" class=\"headerlink\" title=\"如何用百分比实现同vh一样的效果？\"></a>如何用百分比实现同vh一样的效果？</h3><p>某些情况下，<code>vw</code>, <code>vh</code>所产生的效果与百分比<code>%单位</code>无异，尤其对于<code>absolute/fixed</code>定位属性的元素。比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    position: fixed;</span><br><span class=\"line\">    top: 100%;</span><br><span class=\"line\">    top: 100vh;</span><br><span class=\"line\">    left: 5%;</span><br><span class=\"line\">    left: 5vw;</span><br><span class=\"line\">    right: 5%;</span><br><span class=\"line\">    right: 5vw;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window\">James Donnelly__stackoverflow</a>:视区单位布道</li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/\">视区相关单位_张鑫旭博客</a>:更多相关与视区单位应用场景的尝试</li>\n<li><a href=\"http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html\">JS,Jquery获取各种屏幕的宽度和高度</a>:复习一下有关屏幕高度的知识</li>\n</ul>"},{"layout":"post","title":"Cookie, LocalStorage 与 SessionStorage","date":"2016-03-10T07:02:00.000Z","_content":"有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。\n\n## 基本概念\n\n### Cookie\n\nCookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie\n\n### localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。\n\n<!--more-->\n\n### sessionStorage\n\nsessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。\n<table>\n    <tr>\n        <th>特性</th>\n        <th>Chorme</th>\n        <th>Firefox</th>\n        <th>IE</th>\n        <td>Opera</td>\n        <td>Safari</td>\n    </tr>\n    <tr>\n        <td>localStorage</td>\n        <td>4</td>\n        <td>3.5</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>sessionStorage</td>\n        <td>5</td>\n        <td>2</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n</table>\n\n## 共同点\n\n- 都是保存在浏览器端，而且同源。 \n- 三者都是键值对的集合。\n\n## 区别\n\n- cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据\n- 如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交\n- 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n- 数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。\n- 安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。\n- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。\n\n## 应用场景\n\n- 每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。\n- 由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。","source":"_posts/2016-03-10-cookie-localstorage-session.md","raw":"---\nlayout: post\ntitle:  \"Cookie, LocalStorage 与 SessionStorage\"\ndate:   2016-03-10 15:02\ncategories: front-end javascript\n---\n有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。\n\n## 基本概念\n\n### Cookie\n\nCookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie\n\n### localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。\n\n<!--more-->\n\n### sessionStorage\n\nsessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。\n<table>\n    <tr>\n        <th>特性</th>\n        <th>Chorme</th>\n        <th>Firefox</th>\n        <th>IE</th>\n        <td>Opera</td>\n        <td>Safari</td>\n    </tr>\n    <tr>\n        <td>localStorage</td>\n        <td>4</td>\n        <td>3.5</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>sessionStorage</td>\n        <td>5</td>\n        <td>2</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n</table>\n\n## 共同点\n\n- 都是保存在浏览器端，而且同源。 \n- 三者都是键值对的集合。\n\n## 区别\n\n- cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据\n- 如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交\n- 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n- 数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。\n- 安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。\n- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。\n\n## 应用场景\n\n- 每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。\n- 由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。","slug":"2016-03-10-cookie-localstorage-session","published":1,"updated":"2016-06-16T10:50:06.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zlk000chys62d07oaqc","content":"<p>有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p>\n<a id=\"more\"></a>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<table><br>    <tr><br>        <th>特性</th><br>        <th>Chorme</th><br>        <th>Firefox</th><br>        <th>IE</th><br>        <td>Opera</td><br>        <td>Safari</td><br>    </tr><br>    <tr><br>        <td>localStorage</td><br>        <td>4</td><br>        <td>3.5</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br>    <tr><br>        <td>sessionStorage</td><br>        <td>5</td><br>        <td>2</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br></table>\n\n<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li>都是保存在浏览器端，而且同源。 </li>\n<li>三者都是键值对的集合。</li>\n</ul>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据</li>\n<li>如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交</li>\n<li>存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。</li>\n<li>安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。</li>\n<li>由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。</li>\n</ul>\n","excerpt":"<p>有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p>","more":"<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<table><br>    <tr><br>        <th>特性</th><br>        <th>Chorme</th><br>        <th>Firefox</th><br>        <th>IE</th><br>        <td>Opera</td><br>        <td>Safari</td><br>    </tr><br>    <tr><br>        <td>localStorage</td><br>        <td>4</td><br>        <td>3.5</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br>    <tr><br>        <td>sessionStorage</td><br>        <td>5</td><br>        <td>2</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br></table>\n\n<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li>都是保存在浏览器端，而且同源。 </li>\n<li>三者都是键值对的集合。</li>\n</ul>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据</li>\n<li>如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交</li>\n<li>存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。</li>\n<li>安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。</li>\n<li>由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。</li>\n</ul>"},{"layout":"post","title":"有关闭包，作用域，this对象","date":"2016-01-02T08:51:00.000Z","_content":"\n### 首先看一下维基百科中，闭包的概念：\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n\n#### 在创建函数和调用函数时，都发生了什么\n\n- 创建函数时\n 1. 创建了预先包含全局变量对象的作用域链\n 2. 该作用域链保存在内部[[scope]]属性中\n- 调用函数时\n 1. 创建执行环境\n 2. 复制函数[[scope]]属性中的对象构建作用域链\n 3. 用arguments与其它形参初始化函数的活动对象\n\n<!--more-->\n\n要理解这句话：**JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。**\n\n#### 再用计数器函数来看一个简单的闭包例子\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\ncounter2(); // Number of events: 1\ncounter1(); // Number of events: 3\n```\n\n这个函数实现了分别计数的功能。\n在createCounter()的最后一句：`return increment;`我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。\n因此，在使用`var counter1 = createCounter();`时，实际上，**我们生成了一个新的函数**。\n每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。\n**内部变量 counter 都是独立存在于每个作用域！**例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。\n\n#### 闭包的内存\n\n后台的每个执行环境都有一个表示变量的对象——变量对象。\n\n- 全局环境的变量对象始终存在\n- 像 createCounter()函数这样的局部变量，只在函数执行的过程中存在\n- 作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象\n- *一般来讲*当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。\n\n*但闭包的情况有所不同：*\n内部定义的函数会把外部函数的活动对象添加到它的作用域链中。\n当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为**匿名函数的作用域链仍然在引用这个活动对象**。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。\n一个简单的构造闭包以及释放内存的例子：\n\n```\nfunction outer () {\n\tvar name = 'foo';\n\treturn function () {\n\t\tconsole.log(name);\n\t}\n}\nvar inner = outer();\ninner();  // foo\ninner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存\n```\n\n并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。\n由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。\n\n#### 闭包的陷阱：循环闭包\n\n**请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。**\n因此，下面这个例子只会返回同一个值。\n\n```\nfunction foo(){\n    var result = new Array();\n    for(var i=0; i<10; i++){\n    result[i] = function(){\n    return i;\n    }\n    }\n    return result;\n}\n```\n\n表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.\n应改为：\n\n```\nfunction foo(){\nvar result = new Array();\nfor(var i=0; i<10; i++){\n    result[i] = function(num){\n    return function(){\n    return num\n    }\n    }(i);\n}\nreturn result;\n}\n```\n\n在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。\n匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。\n\n换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。\n代码简化如下：\n\n```\nvar arr = new Array();\nfor (var i = 0; i < 50; i++) {\n    (function () {\n        arr[i] = document.createElement('i');\n        arr[i].index = i;\n        arr[i].onclick = function () {\n            console.log(this.index);\n        };\n    })(i);\n};\n```\n\n`arr[i].index = i;`这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50\n\n#### 闭包中的this对象\n\n**匿名函数的执行环境具有全局性，因此其this对象通常指向window**\n```\nvar name = \"The Window\";\n　　var object = {\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()()); // “The Window”\n```\n内部函数在搜索`this`和`arguments`这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。\n\n### 关于this关键字\n\n在《JavaScripts语言精粹》中，把this的出现场景分为四种：\n\n> 有对象就指向调用对象\n\n> 没调用对象就指向全局对象\n\n> 用new构造就指向新对象\n\n> 通过 apply 或 call 或 bind 来改变 this 的所指。\n\n#### 1.全局的this===window\n\n#### 2.作为对象方法的函数的this指向这个上级对象\n\n```\nvar o ={\n    prop:37;\n    f:function(){return this.prop}\n    }\nconsole.log(o.f()); //37\n```\n\n#### 3.构造函数调用，this指向其生成的新对象\n\n```\nwindow. x = 2;\n　　function test(m){\n　　　　this.x = m;\n　　}\n　　var o = new test(5);\n　　alert(x); //5\n```\n\n#### 4.apply 和 call 调用以及 bind 绑定\n\n全局函数apply和call可以用来改变函数中this的指向，如下：\n\n```\n// 定义一个全局函数\n   function foo() {\n       console.log(this.fruit);\n   }\n // 定义一个全局变量\n   var fruit = \"apple\";\n   // 自定义一个对象\n   var pack = {\n       fruit: \"orange\"\n   };\n    // 等价于window.foo();\n   foo.apply(window);  // \"apple\",此时this等于window\n   // 此时foo中的this === pack\n   foo.apply(pack);    // \"orange\"\n```","source":"_posts/2016-01-02-clouser-scope.md","raw":"---\nlayout: post\ntitle:  \"有关闭包，作用域，this对象\"\ndate:   2016-01-02 16:51\ncategories: front-end javascript\n---\n\n### 首先看一下维基百科中，闭包的概念：\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n\n#### 在创建函数和调用函数时，都发生了什么\n\n- 创建函数时\n 1. 创建了预先包含全局变量对象的作用域链\n 2. 该作用域链保存在内部[[scope]]属性中\n- 调用函数时\n 1. 创建执行环境\n 2. 复制函数[[scope]]属性中的对象构建作用域链\n 3. 用arguments与其它形参初始化函数的活动对象\n\n<!--more-->\n\n要理解这句话：**JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。**\n\n#### 再用计数器函数来看一个简单的闭包例子\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\ncounter2(); // Number of events: 1\ncounter1(); // Number of events: 3\n```\n\n这个函数实现了分别计数的功能。\n在createCounter()的最后一句：`return increment;`我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。\n因此，在使用`var counter1 = createCounter();`时，实际上，**我们生成了一个新的函数**。\n每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。\n**内部变量 counter 都是独立存在于每个作用域！**例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。\n\n#### 闭包的内存\n\n后台的每个执行环境都有一个表示变量的对象——变量对象。\n\n- 全局环境的变量对象始终存在\n- 像 createCounter()函数这样的局部变量，只在函数执行的过程中存在\n- 作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象\n- *一般来讲*当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。\n\n*但闭包的情况有所不同：*\n内部定义的函数会把外部函数的活动对象添加到它的作用域链中。\n当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为**匿名函数的作用域链仍然在引用这个活动对象**。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。\n一个简单的构造闭包以及释放内存的例子：\n\n```\nfunction outer () {\n\tvar name = 'foo';\n\treturn function () {\n\t\tconsole.log(name);\n\t}\n}\nvar inner = outer();\ninner();  // foo\ninner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存\n```\n\n并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。\n由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。\n\n#### 闭包的陷阱：循环闭包\n\n**请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。**\n因此，下面这个例子只会返回同一个值。\n\n```\nfunction foo(){\n    var result = new Array();\n    for(var i=0; i<10; i++){\n    result[i] = function(){\n    return i;\n    }\n    }\n    return result;\n}\n```\n\n表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.\n应改为：\n\n```\nfunction foo(){\nvar result = new Array();\nfor(var i=0; i<10; i++){\n    result[i] = function(num){\n    return function(){\n    return num\n    }\n    }(i);\n}\nreturn result;\n}\n```\n\n在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。\n匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。\n\n换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。\n代码简化如下：\n\n```\nvar arr = new Array();\nfor (var i = 0; i < 50; i++) {\n    (function () {\n        arr[i] = document.createElement('i');\n        arr[i].index = i;\n        arr[i].onclick = function () {\n            console.log(this.index);\n        };\n    })(i);\n};\n```\n\n`arr[i].index = i;`这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50\n\n#### 闭包中的this对象\n\n**匿名函数的执行环境具有全局性，因此其this对象通常指向window**\n```\nvar name = \"The Window\";\n　　var object = {\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()()); // “The Window”\n```\n内部函数在搜索`this`和`arguments`这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。\n\n### 关于this关键字\n\n在《JavaScripts语言精粹》中，把this的出现场景分为四种：\n\n> 有对象就指向调用对象\n\n> 没调用对象就指向全局对象\n\n> 用new构造就指向新对象\n\n> 通过 apply 或 call 或 bind 来改变 this 的所指。\n\n#### 1.全局的this===window\n\n#### 2.作为对象方法的函数的this指向这个上级对象\n\n```\nvar o ={\n    prop:37;\n    f:function(){return this.prop}\n    }\nconsole.log(o.f()); //37\n```\n\n#### 3.构造函数调用，this指向其生成的新对象\n\n```\nwindow. x = 2;\n　　function test(m){\n　　　　this.x = m;\n　　}\n　　var o = new test(5);\n　　alert(x); //5\n```\n\n#### 4.apply 和 call 调用以及 bind 绑定\n\n全局函数apply和call可以用来改变函数中this的指向，如下：\n\n```\n// 定义一个全局函数\n   function foo() {\n       console.log(this.fruit);\n   }\n // 定义一个全局变量\n   var fruit = \"apple\";\n   // 自定义一个对象\n   var pack = {\n       fruit: \"orange\"\n   };\n    // 等价于window.foo();\n   foo.apply(window);  // \"apple\",此时this等于window\n   // 此时foo中的this === pack\n   foo.apply(pack);    // \"orange\"\n```","slug":"2016-01-02-clouser-scope","published":1,"updated":"2016-06-16T10:50:00.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zlp000dhys680i1ksbn","content":"<h3 id=\"首先看一下维基百科中，闭包的概念：\"><a href=\"#首先看一下维基百科中，闭包的概念：\" class=\"headerlink\" title=\"首先看一下维基百科中，闭包的概念：\"></a>首先看一下维基百科中，闭包的概念：</h3><blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。<br>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n</blockquote>\n<h4 id=\"在创建函数和调用函数时，都发生了什么\"><a href=\"#在创建函数和调用函数时，都发生了什么\" class=\"headerlink\" title=\"在创建函数和调用函数时，都发生了什么\"></a>在创建函数和调用函数时，都发生了什么</h4><ul>\n<li>创建函数时<ol>\n<li>创建了预先包含全局变量对象的作用域链</li>\n<li>该作用域链保存在内部[[scope]]属性中</li>\n</ol>\n</li>\n<li>调用函数时<ol>\n<li>创建执行环境</li>\n<li>复制函数[[scope]]属性中的对象构建作用域链</li>\n<li>用arguments与其它形参初始化函数的活动对象</li>\n</ol>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>要理解这句话：<strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong></p>\n<h4 id=\"再用计数器函数来看一个简单的闭包例子\"><a href=\"#再用计数器函数来看一个简单的闭包例子\" class=\"headerlink\" title=\"再用计数器函数来看一个简单的闭包例子\"></a>再用计数器函数来看一个简单的闭包例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createCounter() &#123;</span><br><span class=\"line\">  var counter = 0;</span><br><span class=\"line\">  function increment() &#123;</span><br><span class=\"line\">    counter = counter + 1;</span><br><span class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return increment;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var counter1 = createCounter();</span><br><span class=\"line\">var counter2 = createCounter();</span><br><span class=\"line\"></span><br><span class=\"line\">counter1(); // Number of events: 1</span><br><span class=\"line\">counter1(); // Number of events: 2</span><br><span class=\"line\">counter2(); // Number of events: 1</span><br><span class=\"line\">counter1(); // Number of events: 3</span><br></pre></td></tr></table></figure>\n<p>这个函数实现了分别计数的功能。<br>在createCounter()的最后一句：<code>return increment;</code>我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。<br>因此，在使用<code>var counter1 = createCounter();</code>时，实际上，<strong>我们生成了一个新的函数</strong>。<br>每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。<br><strong>内部变量 counter 都是独立存在于每个作用域！</strong>例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。</p>\n<h4 id=\"闭包的内存\"><a href=\"#闭包的内存\" class=\"headerlink\" title=\"闭包的内存\"></a>闭包的内存</h4><p>后台的每个执行环境都有一个表示变量的对象——变量对象。</p>\n<ul>\n<li>全局环境的变量对象始终存在</li>\n<li>像 createCounter()函数这样的局部变量，只在函数执行的过程中存在</li>\n<li>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象</li>\n<li><em>一般来讲</em>当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。</li>\n</ul>\n<p><em>但闭包的情况有所不同：</em><br>内部定义的函数会把外部函数的活动对象添加到它的作用域链中。<br>当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为<strong>匿名函数的作用域链仍然在引用这个活动对象</strong>。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。<br>一个简单的构造闭包以及释放内存的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function outer () &#123;</span><br><span class=\"line\">\tvar name = &apos;foo&apos;;</span><br><span class=\"line\">\treturn function () &#123;</span><br><span class=\"line\">\t\tconsole.log(name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var inner = outer();</span><br><span class=\"line\">inner();  // foo</span><br><span class=\"line\">inner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存</span><br></pre></td></tr></table></figure>\n<p>并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。<br>由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。</p>\n<h4 id=\"闭包的陷阱：循环闭包\"><a href=\"#闭包的陷阱：循环闭包\" class=\"headerlink\" title=\"闭包的陷阱：循环闭包\"></a>闭包的陷阱：循环闭包</h4><p><strong>请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。</strong><br>因此，下面这个例子只会返回同一个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    var result = new Array();</span><br><span class=\"line\">    for(var i=0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    result[i] = function()&#123;</span><br><span class=\"line\">    return i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.<br>应改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">var result = new Array();</span><br><span class=\"line\">for(var i=0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    result[i] = function(num)&#123;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">    return num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。<br>匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。</p>\n<p>换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。<br>代码简化如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = new Array();</span><br><span class=\"line\">for (var i = 0; i &lt; 50; i++) &#123;</span><br><span class=\"line\">    (function () &#123;</span><br><span class=\"line\">        arr[i] = document.createElement(&apos;i&apos;);</span><br><span class=\"line\">        arr[i].index = i;</span><br><span class=\"line\">        arr[i].onclick = function () &#123;</span><br><span class=\"line\">            console.log(this.index);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>arr[i].index = i;</code>这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50</p>\n<h4 id=\"闭包中的this对象\"><a href=\"#闭包中的this对象\" class=\"headerlink\" title=\"闭包中的this对象\"></a>闭包中的this对象</h4><p><strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;The Window&quot;;</span><br><span class=\"line\">　　var object = &#123;</span><br><span class=\"line\">　　　　name : &quot;My Object&quot;,</span><br><span class=\"line\">　　　　getNameFunc : function()&#123;</span><br><span class=\"line\">　　　　　　return function()&#123;</span><br><span class=\"line\">　　　　　　　　return this.name;</span><br><span class=\"line\">　　　　　　&#125;;</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　alert(object.getNameFunc()()); // “The Window”</span><br></pre></td></tr></table></figure></p>\n<p>内部函数在搜索<code>this</code>和<code>arguments</code>这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。</p>\n<h3 id=\"关于this关键字\"><a href=\"#关于this关键字\" class=\"headerlink\" title=\"关于this关键字\"></a>关于this关键字</h3><p>在《JavaScripts语言精粹》中，把this的出现场景分为四种：</p>\n<blockquote>\n<p>有对象就指向调用对象</p>\n<p>没调用对象就指向全局对象</p>\n<p>用new构造就指向新对象</p>\n<p>通过 apply 或 call 或 bind 来改变 this 的所指。</p>\n</blockquote>\n<h4 id=\"1-全局的this-window\"><a href=\"#1-全局的this-window\" class=\"headerlink\" title=\"1.全局的this===window\"></a>1.全局的this===window</h4><h4 id=\"2-作为对象方法的函数的this指向这个上级对象\"><a href=\"#2-作为对象方法的函数的this指向这个上级对象\" class=\"headerlink\" title=\"2.作为对象方法的函数的this指向这个上级对象\"></a>2.作为对象方法的函数的this指向这个上级对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o =&#123;</span><br><span class=\"line\">    prop:37;</span><br><span class=\"line\">    f:function()&#123;return this.prop&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">console.log(o.f()); //37</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-构造函数调用，this指向其生成的新对象\"><a href=\"#3-构造函数调用，this指向其生成的新对象\" class=\"headerlink\" title=\"3.构造函数调用，this指向其生成的新对象\"></a>3.构造函数调用，this指向其生成的新对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window. x = 2;</span><br><span class=\"line\">　　function test(m)&#123;</span><br><span class=\"line\">　　　　this.x = m;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　var o = new test(5);</span><br><span class=\"line\">　　alert(x); //5</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-apply-和-call-调用以及-bind-绑定\"><a href=\"#4-apply-和-call-调用以及-bind-绑定\" class=\"headerlink\" title=\"4.apply 和 call 调用以及 bind 绑定\"></a>4.apply 和 call 调用以及 bind 绑定</h4><p>全局函数apply和call可以用来改变函数中this的指向，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个全局函数</span><br><span class=\"line\">   function foo() &#123;</span><br><span class=\"line\">       console.log(this.fruit);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> // 定义一个全局变量</span><br><span class=\"line\">   var fruit = &quot;apple&quot;;</span><br><span class=\"line\">   // 自定义一个对象</span><br><span class=\"line\">   var pack = &#123;</span><br><span class=\"line\">       fruit: &quot;orange&quot;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">    // 等价于window.foo();</span><br><span class=\"line\">   foo.apply(window);  // &quot;apple&quot;,此时this等于window</span><br><span class=\"line\">   // 此时foo中的this === pack</span><br><span class=\"line\">   foo.apply(pack);    // &quot;orange&quot;</span><br></pre></td></tr></table></figure>","excerpt":"<h3 id=\"首先看一下维基百科中，闭包的概念：\"><a href=\"#首先看一下维基百科中，闭包的概念：\" class=\"headerlink\" title=\"首先看一下维基百科中，闭包的概念：\"></a>首先看一下维基百科中，闭包的概念：</h3><blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。<br>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n</blockquote>\n<h4 id=\"在创建函数和调用函数时，都发生了什么\"><a href=\"#在创建函数和调用函数时，都发生了什么\" class=\"headerlink\" title=\"在创建函数和调用函数时，都发生了什么\"></a>在创建函数和调用函数时，都发生了什么</h4><ul>\n<li>创建函数时<ol>\n<li>创建了预先包含全局变量对象的作用域链</li>\n<li>该作用域链保存在内部[[scope]]属性中</li>\n</ol>\n</li>\n<li>调用函数时<ol>\n<li>创建执行环境</li>\n<li>复制函数[[scope]]属性中的对象构建作用域链</li>\n<li>用arguments与其它形参初始化函数的活动对象</li>\n</ol>\n</li>\n</ul>","more":"<p>要理解这句话：<strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong></p>\n<h4 id=\"再用计数器函数来看一个简单的闭包例子\"><a href=\"#再用计数器函数来看一个简单的闭包例子\" class=\"headerlink\" title=\"再用计数器函数来看一个简单的闭包例子\"></a>再用计数器函数来看一个简单的闭包例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createCounter() &#123;</span><br><span class=\"line\">  var counter = 0;</span><br><span class=\"line\">  function increment() &#123;</span><br><span class=\"line\">    counter = counter + 1;</span><br><span class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return increment;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var counter1 = createCounter();</span><br><span class=\"line\">var counter2 = createCounter();</span><br><span class=\"line\"></span><br><span class=\"line\">counter1(); // Number of events: 1</span><br><span class=\"line\">counter1(); // Number of events: 2</span><br><span class=\"line\">counter2(); // Number of events: 1</span><br><span class=\"line\">counter1(); // Number of events: 3</span><br></pre></td></tr></table></figure>\n<p>这个函数实现了分别计数的功能。<br>在createCounter()的最后一句：<code>return increment;</code>我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。<br>因此，在使用<code>var counter1 = createCounter();</code>时，实际上，<strong>我们生成了一个新的函数</strong>。<br>每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。<br><strong>内部变量 counter 都是独立存在于每个作用域！</strong>例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。</p>\n<h4 id=\"闭包的内存\"><a href=\"#闭包的内存\" class=\"headerlink\" title=\"闭包的内存\"></a>闭包的内存</h4><p>后台的每个执行环境都有一个表示变量的对象——变量对象。</p>\n<ul>\n<li>全局环境的变量对象始终存在</li>\n<li>像 createCounter()函数这样的局部变量，只在函数执行的过程中存在</li>\n<li>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象</li>\n<li><em>一般来讲</em>当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。</li>\n</ul>\n<p><em>但闭包的情况有所不同：</em><br>内部定义的函数会把外部函数的活动对象添加到它的作用域链中。<br>当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为<strong>匿名函数的作用域链仍然在引用这个活动对象</strong>。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。<br>一个简单的构造闭包以及释放内存的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function outer () &#123;</span><br><span class=\"line\">\tvar name = &apos;foo&apos;;</span><br><span class=\"line\">\treturn function () &#123;</span><br><span class=\"line\">\t\tconsole.log(name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var inner = outer();</span><br><span class=\"line\">inner();  // foo</span><br><span class=\"line\">inner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存</span><br></pre></td></tr></table></figure>\n<p>并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。<br>由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。</p>\n<h4 id=\"闭包的陷阱：循环闭包\"><a href=\"#闭包的陷阱：循环闭包\" class=\"headerlink\" title=\"闭包的陷阱：循环闭包\"></a>闭包的陷阱：循环闭包</h4><p><strong>请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。</strong><br>因此，下面这个例子只会返回同一个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    var result = new Array();</span><br><span class=\"line\">    for(var i=0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    result[i] = function()&#123;</span><br><span class=\"line\">    return i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.<br>应改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">var result = new Array();</span><br><span class=\"line\">for(var i=0; i&lt;10; i++)&#123;</span><br><span class=\"line\">    result[i] = function(num)&#123;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">    return num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。<br>匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。</p>\n<p>换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。<br>代码简化如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = new Array();</span><br><span class=\"line\">for (var i = 0; i &lt; 50; i++) &#123;</span><br><span class=\"line\">    (function () &#123;</span><br><span class=\"line\">        arr[i] = document.createElement(&apos;i&apos;);</span><br><span class=\"line\">        arr[i].index = i;</span><br><span class=\"line\">        arr[i].onclick = function () &#123;</span><br><span class=\"line\">            console.log(this.index);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>arr[i].index = i;</code>这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50</p>\n<h4 id=\"闭包中的this对象\"><a href=\"#闭包中的this对象\" class=\"headerlink\" title=\"闭包中的this对象\"></a>闭包中的this对象</h4><p><strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;The Window&quot;;</span><br><span class=\"line\">　　var object = &#123;</span><br><span class=\"line\">　　　　name : &quot;My Object&quot;,</span><br><span class=\"line\">　　　　getNameFunc : function()&#123;</span><br><span class=\"line\">　　　　　　return function()&#123;</span><br><span class=\"line\">　　　　　　　　return this.name;</span><br><span class=\"line\">　　　　　　&#125;;</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　alert(object.getNameFunc()()); // “The Window”</span><br></pre></td></tr></table></figure></p>\n<p>内部函数在搜索<code>this</code>和<code>arguments</code>这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。</p>\n<h3 id=\"关于this关键字\"><a href=\"#关于this关键字\" class=\"headerlink\" title=\"关于this关键字\"></a>关于this关键字</h3><p>在《JavaScripts语言精粹》中，把this的出现场景分为四种：</p>\n<blockquote>\n<p>有对象就指向调用对象</p>\n<p>没调用对象就指向全局对象</p>\n<p>用new构造就指向新对象</p>\n<p>通过 apply 或 call 或 bind 来改变 this 的所指。</p>\n</blockquote>\n<h4 id=\"1-全局的this-window\"><a href=\"#1-全局的this-window\" class=\"headerlink\" title=\"1.全局的this===window\"></a>1.全局的this===window</h4><h4 id=\"2-作为对象方法的函数的this指向这个上级对象\"><a href=\"#2-作为对象方法的函数的this指向这个上级对象\" class=\"headerlink\" title=\"2.作为对象方法的函数的this指向这个上级对象\"></a>2.作为对象方法的函数的this指向这个上级对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o =&#123;</span><br><span class=\"line\">    prop:37;</span><br><span class=\"line\">    f:function()&#123;return this.prop&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">console.log(o.f()); //37</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-构造函数调用，this指向其生成的新对象\"><a href=\"#3-构造函数调用，this指向其生成的新对象\" class=\"headerlink\" title=\"3.构造函数调用，this指向其生成的新对象\"></a>3.构造函数调用，this指向其生成的新对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window. x = 2;</span><br><span class=\"line\">　　function test(m)&#123;</span><br><span class=\"line\">　　　　this.x = m;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　var o = new test(5);</span><br><span class=\"line\">　　alert(x); //5</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-apply-和-call-调用以及-bind-绑定\"><a href=\"#4-apply-和-call-调用以及-bind-绑定\" class=\"headerlink\" title=\"4.apply 和 call 调用以及 bind 绑定\"></a>4.apply 和 call 调用以及 bind 绑定</h4><p>全局函数apply和call可以用来改变函数中this的指向，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个全局函数</span><br><span class=\"line\">   function foo() &#123;</span><br><span class=\"line\">       console.log(this.fruit);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> // 定义一个全局变量</span><br><span class=\"line\">   var fruit = &quot;apple&quot;;</span><br><span class=\"line\">   // 自定义一个对象</span><br><span class=\"line\">   var pack = &#123;</span><br><span class=\"line\">       fruit: &quot;orange&quot;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">    // 等价于window.foo();</span><br><span class=\"line\">   foo.apply(window);  // &quot;apple&quot;,此时this等于window</span><br><span class=\"line\">   // 此时foo中的this === pack</span><br><span class=\"line\">   foo.apply(pack);    // &quot;orange&quot;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"避免脏pr：使用git rebase避免无谓的merge","date":"2016-06-09T03:51:00.000Z","_content":"\n### 问题复现与解决\n\n在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:\n\n![commit history](http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg)\n\n事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。\n\n想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。\n\n<!--more-->\n\n```\ngit fetch origin master\n# git merge origin/master # 不要这么干\ngit rebase origin/master\n```\n\n```\n# git pull origin master # 不要这么干\ngit pull --rebase\n```\n\n主要是因为`git pull`这一git命令实际执行了`git fetch`和`git merge FETCH_HEAD`两条指令。因此不要直接使用`git pull`来更新代码。`git pull --rebase `指令的意思是：\n\n1. 把本地repo自从上次pull之后的变更暂存起来\n2. 回到上次pull时的情况\n3. 套用远端的变更\n4. 套用第一步中暂存的本地变更\n\n### 关于git rebase\n`git rebase`和`git merge`做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。\n假设合并前是这样：\n\n>D---E master\n     /\nA---B---C---F origin/master\n\n使用merge合并后：\n\n>D--------E  \n     /          \\\nA---B---C---F----G   master, origin/master\n\n适应rebase合并后：\n\n>A---B---C---F---D'---E'   master, origin/master\n\n由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。\n\n### A rebase-based workflow\n1.新建分支\n\n> git checkout master\n  git pull    #更新master\n  git checkout master -b test   #从master创建feature分支\n  git push -u origin test:test\n  \\#把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支\n\n2.更新分支\n\n从master更新\n\n> git pull --rebase origin master #此方法不会更新本地master分支\n\n从test更新\n\n> git pull --rebase #需先设置追踪分支\n\n3.完成后回到主分支\n\n> git checkout master\n  git pull     #这里不会导致出现merge commit\n  git rebase test     #把commits拉取到主分支\n  git push\n\n### 处理脏pr\n这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。\n\n> git fetch origin master:new-feature\n  git checkout new-feature\n  git cherry-pick COMMIT_HASH_1\n  git cherry-pick COMMIT_HASH_2\n  ...\n  git cherry-pick COMMIT_HASH_N\n  \ncherry-pick命令\"复制\"一个提交节点并在当前分支做一次完全一样的新提交。\n注意cherry-pick的顺序应是commit **从旧到新** 的顺序，否则会一直出现无数冲突。\n\n### 参考内容\n* [RandyFay:A Rebase Workflow for Git](https://randyfay.com/node/91)\n* [stackoverflow:When do you use git rebase instead of git merge?](http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge)\n* [stackoverflow:git workflow and rebase vs merge questions](http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions)\n* [git-recipes:代码合并:Merge、Rebase的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n* [WEB研究所:git 实践之避免 merge](https://www.web-tinker.com/article/21112.html)\n\n\n\n\n\n\n\n","source":"_posts/2016-06-09-rebase-workflow.md","raw":"---\nlayout: post\ntitle:  \"避免脏pr：使用git rebase避免无谓的merge\"\ndate:   2016-06-09 11:51\ncategories: git\n---\n\n### 问题复现与解决\n\n在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:\n\n![commit history](http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg)\n\n事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。\n\n想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。\n\n<!--more-->\n\n```\ngit fetch origin master\n# git merge origin/master # 不要这么干\ngit rebase origin/master\n```\n\n```\n# git pull origin master # 不要这么干\ngit pull --rebase\n```\n\n主要是因为`git pull`这一git命令实际执行了`git fetch`和`git merge FETCH_HEAD`两条指令。因此不要直接使用`git pull`来更新代码。`git pull --rebase `指令的意思是：\n\n1. 把本地repo自从上次pull之后的变更暂存起来\n2. 回到上次pull时的情况\n3. 套用远端的变更\n4. 套用第一步中暂存的本地变更\n\n### 关于git rebase\n`git rebase`和`git merge`做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。\n假设合并前是这样：\n\n>D---E master\n     /\nA---B---C---F origin/master\n\n使用merge合并后：\n\n>D--------E  \n     /          \\\nA---B---C---F----G   master, origin/master\n\n适应rebase合并后：\n\n>A---B---C---F---D'---E'   master, origin/master\n\n由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。\n\n### A rebase-based workflow\n1.新建分支\n\n> git checkout master\n  git pull    #更新master\n  git checkout master -b test   #从master创建feature分支\n  git push -u origin test:test\n  \\#把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支\n\n2.更新分支\n\n从master更新\n\n> git pull --rebase origin master #此方法不会更新本地master分支\n\n从test更新\n\n> git pull --rebase #需先设置追踪分支\n\n3.完成后回到主分支\n\n> git checkout master\n  git pull     #这里不会导致出现merge commit\n  git rebase test     #把commits拉取到主分支\n  git push\n\n### 处理脏pr\n这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。\n\n> git fetch origin master:new-feature\n  git checkout new-feature\n  git cherry-pick COMMIT_HASH_1\n  git cherry-pick COMMIT_HASH_2\n  ...\n  git cherry-pick COMMIT_HASH_N\n  \ncherry-pick命令\"复制\"一个提交节点并在当前分支做一次完全一样的新提交。\n注意cherry-pick的顺序应是commit **从旧到新** 的顺序，否则会一直出现无数冲突。\n\n### 参考内容\n* [RandyFay:A Rebase Workflow for Git](https://randyfay.com/node/91)\n* [stackoverflow:When do you use git rebase instead of git merge?](http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge)\n* [stackoverflow:git workflow and rebase vs merge questions](http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions)\n* [git-recipes:代码合并:Merge、Rebase的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n* [WEB研究所:git 实践之避免 merge](https://www.web-tinker.com/article/21112.html)\n\n\n\n\n\n\n\n","slug":"2016-06-09-rebase-workflow","published":1,"updated":"2016-06-16T11:08:42.000Z","comments":1,"photos":[],"link":"","_id":"cipwg2zlu000ghys6c3oh4lmw","content":"<h3 id=\"问题复现与解决\"><a href=\"#问题复现与解决\" class=\"headerlink\" title=\"问题复现与解决\"></a>问题复现与解决</h3><p>在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg\" alt=\"commit history\"></p>\n<p>事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。</p>\n<p>想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin master</span><br><span class=\"line\"># git merge origin/master # 不要这么干</span><br><span class=\"line\">git rebase origin/master</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git pull origin master # 不要这么干</span><br><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure>\n<p>主要是因为<code>git pull</code>这一git命令实际执行了<code>git fetch</code>和<code>git merge FETCH_HEAD</code>两条指令。因此不要直接使用<code>git pull</code>来更新代码。<code>git pull --rebase</code>指令的意思是：</p>\n<ol>\n<li>把本地repo自从上次pull之后的变更暂存起来</li>\n<li>回到上次pull时的情况</li>\n<li>套用远端的变更</li>\n<li>套用第一步中暂存的本地变更</li>\n</ol>\n<h3 id=\"关于git-rebase\"><a href=\"#关于git-rebase\" class=\"headerlink\" title=\"关于git rebase\"></a>关于git rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。<br>假设合并前是这样：</p>\n<blockquote>\n<p>D—E master<br>     /<br>A—B—C—F origin/master</p>\n</blockquote>\n<p>使用merge合并后：</p>\n<blockquote>\n<p>D——–E<br>     /          \\<br>A—B—C—F—-G   master, origin/master</p>\n</blockquote>\n<p>适应rebase合并后：</p>\n<blockquote>\n<p>A—B—C—F—D’—E’   master, origin/master</p>\n</blockquote>\n<p>由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。</p>\n<h3 id=\"A-rebase-based-workflow\"><a href=\"#A-rebase-based-workflow\" class=\"headerlink\" title=\"A rebase-based workflow\"></a>A rebase-based workflow</h3><p>1.新建分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull    #更新master<br>  git checkout master -b test   #从master创建feature分支<br>  git push -u origin test:test<br>  #把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支</p>\n</blockquote>\n<p>2.更新分支</p>\n<p>从master更新</p>\n<blockquote>\n<p>git pull –rebase origin master #此方法不会更新本地master分支</p>\n</blockquote>\n<p>从test更新</p>\n<blockquote>\n<p>git pull –rebase #需先设置追踪分支</p>\n</blockquote>\n<p>3.完成后回到主分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull     #这里不会导致出现merge commit<br>  git rebase test     #把commits拉取到主分支<br>  git push</p>\n</blockquote>\n<h3 id=\"处理脏pr\"><a href=\"#处理脏pr\" class=\"headerlink\" title=\"处理脏pr\"></a>处理脏pr</h3><p>这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。</p>\n<blockquote>\n<p>git fetch origin master:new-feature<br>  git checkout new-feature<br>  git cherry-pick COMMIT_HASH_1<br>  git cherry-pick COMMIT_HASH_2<br>  …<br>  git cherry-pick COMMIT_HASH_N</p>\n</blockquote>\n<p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br>注意cherry-pick的顺序应是commit <strong>从旧到新</strong> 的顺序，否则会一直出现无数冲突。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://randyfay.com/node/91\" target=\"_blank\" rel=\"external\">RandyFay:A Rebase Workflow for Git</a></li>\n<li><a href=\"http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge\" target=\"_blank\" rel=\"external\">stackoverflow:When do you use git rebase instead of git merge?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions\" target=\"_blank\" rel=\"external\">stackoverflow:git workflow and rebase vs merge questions</a></li>\n<li><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\" target=\"_blank\" rel=\"external\">git-recipes:代码合并:Merge、Rebase的选择</a></li>\n<li><a href=\"https://www.web-tinker.com/article/21112.html\" target=\"_blank\" rel=\"external\">WEB研究所:git 实践之避免 merge</a></li>\n</ul>\n","excerpt":"<h3 id=\"问题复现与解决\"><a href=\"#问题复现与解决\" class=\"headerlink\" title=\"问题复现与解决\"></a>问题复现与解决</h3><p>在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg\" alt=\"commit history\"></p>\n<p>事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。</p>\n<p>想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin master</span><br><span class=\"line\"># git merge origin/master # 不要这么干</span><br><span class=\"line\">git rebase origin/master</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git pull origin master # 不要这么干</span><br><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure>\n<p>主要是因为<code>git pull</code>这一git命令实际执行了<code>git fetch</code>和<code>git merge FETCH_HEAD</code>两条指令。因此不要直接使用<code>git pull</code>来更新代码。<code>git pull --rebase</code>指令的意思是：</p>\n<ol>\n<li>把本地repo自从上次pull之后的变更暂存起来</li>\n<li>回到上次pull时的情况</li>\n<li>套用远端的变更</li>\n<li>套用第一步中暂存的本地变更</li>\n</ol>\n<h3 id=\"关于git-rebase\"><a href=\"#关于git-rebase\" class=\"headerlink\" title=\"关于git rebase\"></a>关于git rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。<br>假设合并前是这样：</p>\n<blockquote>\n<p>D—E master<br>     /<br>A—B—C—F origin/master</p>\n</blockquote>\n<p>使用merge合并后：</p>\n<blockquote>\n<p>D——–E<br>     /          \\<br>A—B—C—F—-G   master, origin/master</p>\n</blockquote>\n<p>适应rebase合并后：</p>\n<blockquote>\n<p>A—B—C—F—D’—E’   master, origin/master</p>\n</blockquote>\n<p>由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。</p>\n<h3 id=\"A-rebase-based-workflow\"><a href=\"#A-rebase-based-workflow\" class=\"headerlink\" title=\"A rebase-based workflow\"></a>A rebase-based workflow</h3><p>1.新建分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull    #更新master<br>  git checkout master -b test   #从master创建feature分支<br>  git push -u origin test:test<br>  #把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支</p>\n</blockquote>\n<p>2.更新分支</p>\n<p>从master更新</p>\n<blockquote>\n<p>git pull –rebase origin master #此方法不会更新本地master分支</p>\n</blockquote>\n<p>从test更新</p>\n<blockquote>\n<p>git pull –rebase #需先设置追踪分支</p>\n</blockquote>\n<p>3.完成后回到主分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull     #这里不会导致出现merge commit<br>  git rebase test     #把commits拉取到主分支<br>  git push</p>\n</blockquote>\n<h3 id=\"处理脏pr\"><a href=\"#处理脏pr\" class=\"headerlink\" title=\"处理脏pr\"></a>处理脏pr</h3><p>这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。</p>\n<blockquote>\n<p>git fetch origin master:new-feature<br>  git checkout new-feature<br>  git cherry-pick COMMIT_HASH_1<br>  git cherry-pick COMMIT_HASH_2<br>  …<br>  git cherry-pick COMMIT_HASH_N</p>\n</blockquote>\n<p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br>注意cherry-pick的顺序应是commit <strong>从旧到新</strong> 的顺序，否则会一直出现无数冲突。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://randyfay.com/node/91\">RandyFay:A Rebase Workflow for Git</a></li>\n<li><a href=\"http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge\">stackoverflow:When do you use git rebase instead of git merge?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions\">stackoverflow:git workflow and rebase vs merge questions</a></li>\n<li><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\">git-recipes:代码合并:Merge、Rebase的选择</a></li>\n<li><a href=\"https://www.web-tinker.com/article/21112.html\">WEB研究所:git 实践之避免 merge</a></li>\n</ul>"},{"layout":"post","title":"毕业时","date":"2016-06-05T07:28:00.000Z","_content":"\n从去年八月到现在，除了最后一个月忙着论文答辩，就一直在实习，大三之后也很少在学校住，所以并没有太多的离开学校的伤感。同届的朋友们也都留在北京了，还是可以继续一次吃吃喝喝，除了最后跑学校办手续累断腿之外再没有别的感觉了。\n\n最后还是拒了ST的offer，留在了新的公司。不过ST的那个组真的是我呆过的氛围最棒的组，两任leader技术和情商都6得不行，本以为可以做为第一份工作一个好的开端，结果还是猝不及防，还是觉得挺遗憾的。周三签了正式的合同，从此不再打卡，也可以用企业版滴滴了，还是很有阶段性意义的。","source":"_posts/2016-06-26-graduation.md","raw":"---\nlayout: post\ntitle:  \"毕业时\"\ndate:   2016-06-05 15:28\ncategories: notes\n---\n\n从去年八月到现在，除了最后一个月忙着论文答辩，就一直在实习，大三之后也很少在学校住，所以并没有太多的离开学校的伤感。同届的朋友们也都留在北京了，还是可以继续一次吃吃喝喝，除了最后跑学校办手续累断腿之外再没有别的感觉了。\n\n最后还是拒了ST的offer，留在了新的公司。不过ST的那个组真的是我呆过的氛围最棒的组，两任leader技术和情商都6得不行，本以为可以做为第一份工作一个好的开端，结果还是猝不及防，还是觉得挺遗憾的。周三签了正式的合同，从此不再打卡，也可以用企业版滴滴了，还是很有阶段性意义的。","slug":"2016-06-26-graduation","published":1,"updated":"2016-06-26T15:54:23.000Z","_id":"cipwqr88x0000g5s6r7elegqw","comments":1,"photos":[],"link":"","content":"<p>从去年八月到现在，除了最后一个月忙着论文答辩，就一直在实习，大三之后也很少在学校住，所以并没有太多的离开学校的伤感。同届的朋友们也都留在北京了，还是可以继续一次吃吃喝喝，除了最后跑学校办手续累断腿之外再没有别的感觉了。</p>\n<p>最后还是拒了ST的offer，留在了新的公司。不过ST的那个组真的是我呆过的氛围最棒的组，两任leader技术和情商都6得不行，本以为可以做为第一份工作一个好的开端，结果还是猝不及防，还是觉得挺遗憾的。周三签了正式的合同，从此不再打卡，也可以用企业版滴滴了，还是很有阶段性意义的。</p>\n","excerpt":"","more":"<p>从去年八月到现在，除了最后一个月忙着论文答辩，就一直在实习，大三之后也很少在学校住，所以并没有太多的离开学校的伤感。同届的朋友们也都留在北京了，还是可以继续一次吃吃喝喝，除了最后跑学校办手续累断腿之外再没有别的感觉了。</p>\n<p>最后还是拒了ST的offer，留在了新的公司。不过ST的那个组真的是我呆过的氛围最棒的组，两任leader技术和情商都6得不行，本以为可以做为第一份工作一个好的开端，结果还是猝不及防，还是觉得挺遗憾的。周三签了正式的合同，从此不再打卡，也可以用企业版滴滴了，还是很有阶段性意义的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cipwg2zkh0001hys67muppsax","category_id":"cipwg2zkr0003hys6quhrwuo4","_id":"cipwg2zl90009hys6l47f8nf7"},{"post_id":"cipwg2zkn0002hys6jvgdm8fu","category_id":"cipwg2zl40007hys6clcmrwjm","_id":"cipwg2zlt000ehys6q30ahnfv"},{"post_id":"cipwg2zkv0004hys6ik5wle47","category_id":"cipwg2zli000bhys6avo3tn2j","_id":"cipwg2zlw000hhys66skue71s"},{"post_id":"cipwg2zky0005hys6zdvtb42z","category_id":"cipwg2zlt000fhys684cx69t3","_id":"cipwg2zlx000jhys6gsiu1sp9"},{"post_id":"cipwg2zl20006hys653g826lc","category_id":"cipwg2zlw000ihys6ljyh3wzh","_id":"cipwg2zm1000lhys63kvjv5dq"},{"post_id":"cipwg2zl60008hys65tybueac","category_id":"cipwg2zlw000ihys6ljyh3wzh","_id":"cipwg2zm3000nhys6udmlpt9y"},{"post_id":"cipwg2zla000ahys6eumbjuaj","category_id":"cipwg2zli000bhys6avo3tn2j","_id":"cipwg2zm5000phys6xc2d6lih"},{"post_id":"cipwg2zlk000chys62d07oaqc","category_id":"cipwg2zlw000ihys6ljyh3wzh","_id":"cipwg2zm9000rhys6e4oqu1l4"},{"post_id":"cipwg2zlp000dhys680i1ksbn","category_id":"cipwg2zlw000ihys6ljyh3wzh","_id":"cipwg2zmb000thys6b8tau4do"},{"post_id":"cipwg2zlu000ghys6c3oh4lmw","category_id":"cipwg2zm9000shys60x4arur3","_id":"cipwg2zmc000uhys6sm4lanmr"},{"post_id":"cipwqr88x0000g5s6r7elegqw","category_id":"cipwrewlu0001g5s619w9jj5b","_id":"cipwrewm90002g5s616uo1tdq"}],"PostTag":[],"Tag":[]}}