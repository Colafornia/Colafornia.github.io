{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/apollo/source/favicon.jpg","path":"favicon.jpg","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1},{"_id":"source/images/icons/batman.png","path":"images/icons/batman.png","modified":0,"renderable":0},{"_id":"source/images/icons/lego.jpeg","path":"images/icons/lego.jpeg","modified":0,"renderable":0},{"_id":"source/images/chinese-pinyin.gif","path":"images/chinese-pinyin.gif","modified":0,"renderable":0},{"_id":"source/images/jstips-animation.gif","path":"images/jstips-animation.gif","modified":0,"renderable":0},{"_id":"source/images/vue-reactive.jpg","path":"images/vue-reactive.jpg","modified":0,"renderable":0},{"_id":"source/images/iife.png","path":"images/iife.png","modified":0,"renderable":0},{"_id":"source/images/JavaScript-for-Kids.png","path":"images/JavaScript-for-Kids.png","modified":0,"renderable":0},{"_id":"source/images/tokyo-in-2017.jpg","path":"images/tokyo-in-2017.jpg","modified":0,"renderable":0},{"_id":"source/images/javascript-is-fast.png","path":"images/javascript-is-fast.png","modified":0,"renderable":0},{"_id":"source/images/review-copy-in-javascript.png","path":"images/review-copy-in-javascript.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"b5e705e4f828455f6b1c3a9541a9fdf4081529aa","modified":1514781017000},{"_id":"source/manifest.json","hash":"1d10ff6b324b44d6759b0c2d5c8f81bdf6612949","modified":1511073540000},{"_id":"themes/apollo/.DS_Store","hash":"3178bbf4e23f25354147bb89d89f9525c6420a52","modified":1477486901000},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1468567412000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1468567412000},{"_id":"themes/apollo/_config.yml","hash":"aa43e6ffe1f277db80fce64bfccca802e302d39a","modified":1468574574000},{"_id":"themes/apollo/README.md","hash":"a3e70662d82b7f7dcc76bd57e95389ba67dd52a4","modified":1468567412000},{"_id":"source/CNAME","hash":"d4b188a94193dc87c56580eeb341953b9d059b14","modified":1510994528000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1468567412000},{"_id":"themes/apollo/package.json","hash":"4d13f5f859db7d008f49251543a8f610b2ecabd5","modified":1468567412000},{"_id":"source/about/.DS_Store","hash":"8208a60b8feacf7ffb9395ac09bc39029f5b3898","modified":1468572330000},{"_id":"source/_posts/angular-data-binding.markdown","hash":"1915d3be5fb6cab0cfd37f2701dae54c2bfb7ca8","modified":1489588146000},{"_id":"source/_posts/angular-ui-router.md","hash":"23c122912323100c1d3b821b7dc808c155834ea0","modified":1489588146000},{"_id":"source/_posts/.DS_Store","hash":"ee48165761ad13cb71414e6d1fa855a4a2cf3484","modified":1514728835000},{"_id":"source/about/index.md","hash":"7960c3ac69df368c8f835ab1868526aac39b9610","modified":1515415522000},{"_id":"source/_posts/basic-fetch-api.md","hash":"b0139251e1234cd3b0acb432ffc36bb352e783b1","modified":1489588146000},{"_id":"source/_posts/browser-cache-summary.md","hash":"ff14e6cf1ebb15ede390a1f19188d15c607dc705","modified":1489588146000},{"_id":"source/_posts/basic-review-from-anonymous-function-to-iife.md","hash":"704d88f24d3452cf34185976a125bdac39efb177","modified":1511074235000},{"_id":"source/_posts/cookie-localstorage-session.md","hash":"4480a7c1a202700b93614566a87416302a4d2530","modified":1489588146000},{"_id":"source/_posts/from-settimeout-to-event-loop.md","hash":"23e4194b6992fa62d3e9949ef617a52a3e199918","modified":1511074168000},{"_id":"source/_posts/git-rebase-workflow.md","hash":"7288fa6e5a7a93c33ceea4290c33b915857ca120","modified":1489588146000},{"_id":"source/_posts/high-performance-javascript-a.md","hash":"dc27fdd57637ad959070853827f075821c5217e4","modified":1489588146000},{"_id":"source/_posts/high-performance-javascript-b.md","hash":"2da1f0d60afefa6e7823727c4c2adb0fb155475a","modified":1511074323000},{"_id":"source/_posts/html-in-email.md","hash":"6c38a451aaa542df03b9c072ecc706068afc4933","modified":1489588146000},{"_id":"source/_posts/intern-qunar-interview.markdown","hash":"6a61a99c29dca1f61b9d37df117a4088148f1380","modified":1489588146000},{"_id":"source/_posts/javascript-patterns.md","hash":"344b507e3f96aa5fd5440afd425d9afdeaa15710","modified":1511074271000},{"_id":"source/_posts/learning-clouser-scope.md","hash":"d8f7336d47498770eb069801050dc2a514c0121b","modified":1489588146000},{"_id":"source/_posts/fix-chinese-input-listener.md","hash":"9723a160f18d92d650dbaef9b6b25790c6454109","modified":1511074107000},{"_id":"source/_posts/learning-note-bfc.md","hash":"f3327f52bc77f6e882efdeba15fa7baada5b509f","modified":1489588146000},{"_id":"source/_posts/make-shell-and-git-better.md","hash":"58115658e01842939a2af2d60a8af7a27f0b7a28","modified":1505491279000},{"_id":"source/_posts/note-learning-javascript-oop.md","hash":"d1c7755cb277a4c9550453fdcf075a5280e476b9","modified":1489588146000},{"_id":"source/_posts/observer-pattern-in-vue.md","hash":"0ea6cb250b88ed5048a0062fddce304dc278168b","modified":1511074201000},{"_id":"source/_posts/reading-pragmatic-programmer.md","hash":"763992c44ffd482f0f44a3953ab036fe6631d076","modified":1511065266000},{"_id":"source/_posts/trans-javascript-code-tips.md","hash":"fbe85d25ebbc506675ad2423e51c258a8b428a84","modified":1489588146000},{"_id":"source/_posts/vieport-percentage.md","hash":"d5e1ee205f60c90272e25720a735b8ed38e28b82","modified":1489588146000},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1468567412000},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1468567412000},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1468567402000},{"_id":"themes/apollo/.git/index","hash":"5ce160f22a700e7fce7095acf178b208f327d828","modified":1472026864000},{"_id":"themes/apollo/.git/packed-refs","hash":"8de9fd125b7e377e0bc28c0d6c03e6e4d2eec3ca","modified":1468567412000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1468567412000},{"_id":"themes/apollo/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1468567412000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1468567412000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1468567412000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1468567412000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1468567412000},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1468567412000},{"_id":"themes/apollo/source/.DS_Store","hash":"b517ad3a975bf2db7dbf09e52359ea2db512dafd","modified":1477486901000},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1468567412000},{"_id":"themes/apollo/source/favicon.jpg","hash":"e1d18eb032e8995a28e41d7974e04551d386f3aa","modified":1462788458000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1468567402000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1468567402000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1468567402000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"cb33a29ae068752a9aeb77791c717249d2b26634","modified":1468567412000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1468567412000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1468567412000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1468567412000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"012f7c94bf78bd9ffba00b32496c140ba286ac98","modified":1511063353000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"768ebe4c616e87e770366e58682726aeee6f58aa","modified":1511063251000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"eb15573ff66bdbb110ac77cf360b740170cee738","modified":1468567412000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"c35d3061da4b053b73150d9741c542d660798270","modified":1468567412000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"af6fd6296207e59d9208a048563e084c4a3e37de","modified":1515830673000},{"_id":"themes/apollo/source/css/apollo.css","hash":"c00c76a701a8c5a829b4490b0db645da8cd54380","modified":1477392723000},{"_id":"themes/apollo/source/css/.DS_Store","hash":"b79826bade18535fef338e5484acf99bbd09f20a","modified":1477486907000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"a3153dfedbaff08c20930b2bde95f2db49f6d518","modified":1468567412000},{"_id":"themes/apollo/.git/objects/pack/pack-5ea86fc15e2c0310d7dbab9f8c03402f249bc773.idx","hash":"c94e2cfcd524d0bdfcc02b5e5792aa961d2be7c6","modified":1468567412000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"f11c8b2d21f6bf2f1587f105627f2058507958bb","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"f7e3e6f06bb81321673a546d51973a052c6d99b4","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1468567412000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"ae780828148f79e5069b480e3576f1fea1246866","modified":1468567412000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"cb33a29ae068752a9aeb77791c717249d2b26634","modified":1468567412000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1468567412000},{"_id":"themes/apollo/.git/objects/pack/pack-5ea86fc15e2c0310d7dbab9f8c03402f249bc773.pack","hash":"af8f09cb29862ea4638800555d2c5d5bf6d3130c","modified":1468567412000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"cb33a29ae068752a9aeb77791c717249d2b26634","modified":1468567412000},{"_id":"public/manifest.json","hash":"7bb51a7431f50c47f9bc34f8c5e645cc7d570e6b","modified":1511074583841},{"_id":"public/atom.xml","hash":"0a70164a2baef06be19cfeb8327dbff2f6b1ba28","modified":1515849587843},{"_id":"public/sitemap.xml","hash":"5f49fdb15ba4378ae0b0b2af8c1090d715e927f3","modified":1515849587838},{"_id":"public/about/index.html","hash":"3262dfad0f4565565dff5303b405880d7c8d877c","modified":1515848788960},{"_id":"public/2017/09/15/reading-pragmatic-programmer/index.html","hash":"59498ca752b247f05c9f1b748000453e1c808c21","modified":1515848788962},{"_id":"public/2017/09/15/make-shell-and-git-better/index.html","hash":"9b95ef30cc1a2e9c7235a406abae43a3c2cb79e6","modified":1515848788962},{"_id":"public/2017/08/22/fix-chinese-input-listener/index.html","hash":"8bd365f82f2d4b1055e979d6ea1f9034d89a56d4","modified":1515848788962},{"_id":"public/2016/11/17/javascript-patterns/index.html","hash":"ca359584f25086406d132c4cae797fb106b66821","modified":1515848788962},{"_id":"public/2016/08/22/basic-fetch-api/index.html","hash":"2e7c0c239f1748eed72544f4125cdcdf336ebccd","modified":1515848788963},{"_id":"public/2016/07/18/browser-cache-summary/index.html","hash":"b458c41783b895c8efa6b925290fdca54c12e204","modified":1515848788963},{"_id":"public/2016/06/09/git-rebase-workflow/index.html","hash":"774b778f23c19a468d0b22fcfe7a341343c08e74","modified":1515848788963},{"_id":"public/2016/03/17/vieport-percentage/index.html","hash":"c0d531c784a8eab6efc4d7fe7004fd18c64c18af","modified":1515848788963},{"_id":"public/2016/03/10/cookie-localstorage-session/index.html","hash":"7e0d1f0a2c5768d84da447361b70de61f8245446","modified":1515848788963},{"_id":"public/2015/12/03/html-in-email/index.html","hash":"b0f2e1c4437c4651339f694b0c040bad25ef8cf8","modified":1515848788963},{"_id":"public/2015/11/23/angular-ui-router/index.html","hash":"64d4aab06a04a2c32663e96fda55016ed4ffe258","modified":1515848788963},{"_id":"public/2015/08/20/learning-note-bfc/index.html","hash":"1212c3993efd19b3b314a1044e704e07fe3708b8","modified":1515848788963},{"_id":"public/2015/08/24/intern-qunar-interview/index.html","hash":"b6ddbdb8ed60b2f0adf75ec0cd36054eb841895c","modified":1515848788963},{"_id":"public/2015/08/20/note-learning-javascript-oop/index.html","hash":"43d4f7c25a80955ffcb642800ba74da1e40a93d9","modified":1515848788963},{"_id":"public/archives/index.html","hash":"4a33acc855c372ccf5be56e3d17d2b4e82885597","modified":1515849587857},{"_id":"public/categories/front-end-javascript/index.html","hash":"3e31c561de6933ac9993b864a2b426097783d882","modified":1515848788964},{"_id":"public/categories/javascript/index.html","hash":"3f95d239cc49d0c141dc2df44a1ad25e69e36925","modified":1515849587856},{"_id":"public/categories/http/index.html","hash":"409eab5fc43179f946a17d0ed0f066f98f639b7e","modified":1515848788965},{"_id":"public/categories/git/index.html","hash":"87741ab2bb7085242c6ea94eee702da9bda24804","modified":1515848788965},{"_id":"public/categories/front-end-css/index.html","hash":"fb35b2c104058eec70acc983c4de9532d70c0603","modified":1515848788965},{"_id":"public/categories/front-end-interview/index.html","hash":"6ed12d5c3794d6bf6831ebcdf1df3560b7ce2665","modified":1515848788965},{"_id":"public/categories/css/index.html","hash":"f58ba4c288833df859e69f8c083d5990a5175cc1","modified":1515848788965},{"_id":"public/categories/shell-git-linux/index.html","hash":"ceeb068841bab4231e004c5d92efc6148d57d0b5","modified":1515848788965},{"_id":"public/categories/programmer-reading/index.html","hash":"db2aca79e691d7e02ae3bbffda0a819e6398d232","modified":1515848788965},{"_id":"public/categories/front-end-javascript-pattern/index.html","hash":"037f554f9d4f2b8bff38ef812842bdf215bf2f79","modified":1515848788965},{"_id":"public/page/2/index.html","hash":"e55c879dff0957f5146e44396420e5acd1b6b3b9","modified":1515848788966},{"_id":"public/page/3/index.html","hash":"5057f48692ce76202b9e9091541a32cb0332988e","modified":1515848788965},{"_id":"public/2017/06/04/from-settimeout-to-event-loop/index.html","hash":"ce01f1d0e8cb778a21a1a75c363762952cd4b0ef","modified":1515848788965},{"_id":"public/2017/03/14/observer-pattern-in-vue/index.html","hash":"cd7af734d97f98acb907dd0b0342003e97aad638","modified":1515848788965},{"_id":"public/2016/11/23/basic-review-from-anonymous-function-to-iife/index.html","hash":"717599382b7c3f1282726329ec4f554dd31ec2cf","modified":1515848788965},{"_id":"public/2016/10/03/high-performance-javascript-b/index.html","hash":"22b2db995a71f858c6d8c994b8040785d0a15578","modified":1515848788965},{"_id":"public/2016/09/26/high-performance-javascript-a/index.html","hash":"f4a5fb3929e8852e0f58def604d21e19fff4f1a1","modified":1515848788965},{"_id":"public/2016/06/05/angular-data-binding/index.html","hash":"f95285d5dbd489f9227aca270371546e2d2b09b3","modified":1515848788965},{"_id":"public/2016/03/13/trans-javascript-code-tips/index.html","hash":"260171d400312e261e5cfe08071312cc3e12a425","modified":1515848788965},{"_id":"public/2016/01/02/learning-clouser-scope/index.html","hash":"1c5e21deaad6dee7c618cc3f462b0ae46497146a","modified":1515848788965},{"_id":"public/index.html","hash":"8f56e428fb7c4ed1096c416ad73d125f778fb83e","modified":1515849587857},{"_id":"source/images/icons/batman.png","hash":"824c06253b8aea91de3079728bb62e766f94dc4a","modified":1511011175000},{"_id":"public/images/icons/batman.png","hash":"824c06253b8aea91de3079728bb62e766f94dc4a","modified":1511025873171},{"_id":"source/images/icons/lego.jpeg","hash":"c2765fe3cacc21dcc6934d3f5edcaeb7e7fd54dd","modified":1511062948000},{"_id":"public/images/icons/lego.jpeg","hash":"c2765fe3cacc21dcc6934d3f5edcaeb7e7fd54dd","modified":1511065278713},{"_id":"source/images/chinese-pinyin.gif","hash":"0da2ae0e5ab63c7a165c12215fb10c9ca1d8272c","modified":1511074062000},{"_id":"source/images/.DS_Store","hash":"17537c326a7a56d11ea1f252141fe00b7c05e1e9","modified":1515415625000},{"_id":"source/images/iife.png","hash":"98c6d89bf65d7b7844a9a82397cf75124d4c536c","modified":1511074361000},{"_id":"source/images/javascirpt-is-fast.png","hash":"6b9bcc575bbef5fffc5e580ae0065db6e5f9ab1a","modified":1511074363000},{"_id":"source/images/vue-reactive.jpg","hash":"96cc76abc3092c34b84c83e36a0474bf5fd472fe","modified":1511074366000},{"_id":"source/images/JavaScript-for-Kids.png","hash":"bbd844a97bb70485b97109d9373df62e5569178f","modified":1511074364000},{"_id":"source/images/jstips-animation.gif","hash":"d44bf70508a9bac20de05cfd77d44fa7b35a2092","modified":1511074151000},{"_id":"public/images/vue-reactive.jpg","hash":"96cc76abc3092c34b84c83e36a0474bf5fd472fe","modified":1511074583865},{"_id":"public/images/javascirpt-is-fast.png","hash":"6b9bcc575bbef5fffc5e580ae0065db6e5f9ab1a","modified":1511074583865},{"_id":"public/images/iife.png","hash":"98c6d89bf65d7b7844a9a82397cf75124d4c536c","modified":1511074583865},{"_id":"public/images/chinese-pinyin.gif","hash":"0da2ae0e5ab63c7a165c12215fb10c9ca1d8272c","modified":1511074583865},{"_id":"public/images/JavaScript-for-Kids.png","hash":"bbd844a97bb70485b97109d9373df62e5569178f","modified":1511074583866},{"_id":"public/images/jstips-animation.gif","hash":"d44bf70508a9bac20de05cfd77d44fa7b35a2092","modified":1511074583874},{"_id":"source/_posts/2017-review.md","hash":"c20ab2fa4030c1676cf1f53849b301210df32cb3","modified":1514729544000},{"_id":"source/images/tokyo-in-2017.jpg","hash":"adcb03c8ecefa213806c2d1f76aa3ee71bc40432","modified":1514712024000},{"_id":"public/2017/12/31/2017-review/index.html","hash":"6ef86ad09013a2d49bdf3c9c90644e268b31ebb0","modified":1515849587855},{"_id":"public/categories/summary/index.html","hash":"b4e054b4b195957a34fdfe5a4c7febb2405653e1","modified":1515848788965},{"_id":"public/images/tokyo-in-2017.jpg","hash":"adcb03c8ecefa213806c2d1f76aa3ee71bc40432","modified":1514729622953},{"_id":"source/images/javascript-is-fast.png","hash":"6b9bcc575bbef5fffc5e580ae0065db6e5f9ab1a","modified":1511074363000},{"_id":"public/images/javascript-is-fast.png","hash":"6b9bcc575bbef5fffc5e580ae0065db6e5f9ab1a","modified":1514781037456},{"_id":"source/_posts/review-copy-in-javascript.md","hash":"4a0b4f3bc375ea30017a2e250bc21e9ab0ea669b","modified":1515849580000},{"_id":"source/images/review-copy-injavascript.png","hash":"e0f3e5876417c20ccf078a84f8dc173a648b5b64","modified":1515841323000},{"_id":"source/images/review-copy-in-javascript.png","hash":"e0f3e5876417c20ccf078a84f8dc173a648b5b64","modified":1515841323000},{"_id":"public/2018/01/13/review-copy-in-javascript/index.html","hash":"8f63d782cc1594d81b2b001bffc406c1bbfd844b","modified":1515849587858},{"_id":"public/images/review-copy-in-javascript.png","hash":"e0f3e5876417c20ccf078a84f8dc173a648b5b64","modified":1515848788975},{"_id":"public/2018/01/12/review-copy-in-javascript/index.html","hash":"479ad876dbfb643344bc7169da1244a16703d8b8","modified":1515849307451}],"Category":[{"name":"front-end javascript","_id":"cja54xyia0004gbeh9upwye82"},{"name":"javascript","_id":"cja54xyiv000cgbeh72jb2eo5"},{"name":"http","_id":"cja54xyj1000hgbehdyjocij9"},{"name":"git","_id":"cja54xyja000mgbeh23zzdp0m"},{"name":"front-end css","_id":"cja54xyjj000rgbeh7t1mq4xs"},{"name":"front-end interview","_id":"cja54xyjq000ygbehot4dbikz"},{"name":"css","_id":"cja54xyjw0013gbeh39hnmytv"},{"name":"shell git linux","_id":"cja54xyka001agbehej9amkv3"},{"name":"programmer reading","_id":"cja54xykc001fgbehoel3yoza"},{"name":"front-end javascript pattern","_id":"cja54xykc001igbehik50btus"},{"name":"summary","_id":"cjbuug4nv00017j6mwm2jw15u"}],"Data":[],"Page":[{"_content":"{\n  \"name\": \"Minibase\",\n  \"short_name\": \"Minibase\",\n  \"theme_color\": \"#42b983\",\n  \"background_color\": \"#42b983\",\n  \"display\": \"fullscreen\",\n  \"Scope\": \"/\",\n  \"start_url\": \"/\",\n  \"icons\": [\n    {\n      \"src\": \"images/icons/batman.png\",\n      \"sizes\": \"128x128\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"images/icons/lego.jpeg\",\n      \"sizes\": \"225x225\",\n      \"type\": \"image/png\"\n    }\n  ],\n  \"splash_pages\": null\n}","source":"manifest.json","raw":"{\n  \"name\": \"Minibase\",\n  \"short_name\": \"Minibase\",\n  \"theme_color\": \"#42b983\",\n  \"background_color\": \"#42b983\",\n  \"display\": \"fullscreen\",\n  \"Scope\": \"/\",\n  \"start_url\": \"/\",\n  \"icons\": [\n    {\n      \"src\": \"images/icons/batman.png\",\n      \"sizes\": \"128x128\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"images/icons/lego.jpeg\",\n      \"sizes\": \"225x225\",\n      \"type\": \"image/png\"\n    }\n  ],\n  \"splash_pages\": null\n}","date":"2017-11-19T06:39:00.000Z","updated":"2017-11-19T06:39:00.000Z","path":"manifest.json","layout":"false","_id":"cja54xy270000gbehprh12amm","title":"","comments":1,"content":"{\"name\":\"Minibase\",\"short_name\":\"Minibase\",\"theme_color\":\"#42b983\",\"background_color\":\"#42b983\",\"display\":\"fullscreen\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/icons/batman.png\",\"sizes\":\"128x128\",\"type\":\"image/png\"},{\"src\":\"images/icons/lego.jpeg\",\"sizes\":\"225x225\",\"type\":\"image/png\"}],\"splash_pages\":null}","excerpt":"","more":"{\"name\":\"Minibase\",\"short_name\":\"Minibase\",\"theme_color\":\"#42b983\",\"background_color\":\"#42b983\",\"display\":\"fullscreen\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/icons/batman.png\",\"sizes\":\"128x128\",\"type\":\"image/png\"},{\"src\":\"images/icons/lego.jpeg\",\"sizes\":\"225x225\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"about","date":"2015-12-29T10:03:57.000Z","comments":0,"_content":"\n## About me\nweb developer,junior programmer\n\nLat/Long 39.9\"N,116. 3\"E\n\nGraduated from EE/Power in BJTU\n\nInterested in Full-Stack,Meachine Learing\n\nHaving a wonderful and firm relationship with closuer\n\n## Contact\n\n- Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t\n- Github: [MechanicianW](https://github.com/MechanicianW)\n\n## Friends\n\n- Caraws@Chengdu: [Caraws](https://caraws.github.io/)\n- wznonstop@Beijing: [wznonstop](http://wznonstop.github.io/)\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2015-12-29 18:03:57\ncomments: false\n---\n\n## About me\nweb developer,junior programmer\n\nLat/Long 39.9\"N,116. 3\"E\n\nGraduated from EE/Power in BJTU\n\nInterested in Full-Stack,Meachine Learing\n\nHaving a wonderful and firm relationship with closuer\n\n## Contact\n\n- Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t\n- Github: [MechanicianW](https://github.com/MechanicianW)\n\n## Friends\n\n- Caraws@Chengdu: [Caraws](https://caraws.github.io/)\n- wznonstop@Beijing: [wznonstop](http://wznonstop.github.io/)\n\n","updated":"2018-01-08T12:45:22.000Z","path":"about/index.html","_id":"cja54xyi00002gbehm06aluaj","layout":"page","content":"<h2 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h2><p>web developer,junior programmer</p>\n<p>Lat/Long 39.9”N,116. 3”E</p>\n<p>Graduated from EE/Power in BJTU</p>\n<p>Interested in Full-Stack,Meachine Learing</p>\n<p>Having a wonderful and firm relationship with closuer</p>\n<h2 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h2><ul>\n<li>Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t</li>\n<li>Github: <a href=\"https://github.com/MechanicianW\" target=\"_blank\" rel=\"external\">MechanicianW</a></li>\n</ul>\n<h2 id=\"Friends\"><a href=\"#Friends\" class=\"headerlink\" title=\"Friends\"></a>Friends</h2><ul>\n<li>Caraws@Chengdu: <a href=\"https://caraws.github.io/\" target=\"_blank\" rel=\"external\">Caraws</a></li>\n<li>wznonstop@Beijing: <a href=\"http://wznonstop.github.io/\" target=\"_blank\" rel=\"external\">wznonstop</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h2><p>web developer,junior programmer</p>\n<p>Lat/Long 39.9”N,116. 3”E</p>\n<p>Graduated from EE/Power in BJTU</p>\n<p>Interested in Full-Stack,Meachine Learing</p>\n<p>Having a wonderful and firm relationship with closuer</p>\n<h2 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h2><ul>\n<li>Email: d2FuZ3lpbGluY2huQGZveG1haWwuY29t</li>\n<li>Github: <a href=\"https://github.com/MechanicianW\">MechanicianW</a></li>\n</ul>\n<h2 id=\"Friends\"><a href=\"#Friends\" class=\"headerlink\" title=\"Friends\"></a>Friends</h2><ul>\n<li>Caraws@Chengdu: <a href=\"https://caraws.github.io/\">Caraws</a></li>\n<li>wznonstop@Beijing: <a href=\"http://wznonstop.github.io/\">wznonstop</a></li>\n</ul>\n"}],"Post":[{"layout":"post","title":"Angular  ui-router","date":"2015-11-23T12:17:00.000Z","_content":"UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。\n\n#### 原生ng-route的不足之处：\n\n- 视图不能嵌套。这意味着$scope会发生不必要的重新载入。\n- 路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。\n\n#### 显而易见，ui-router的优势为：\n\n- 提出了\"$state\"的概念，通过改变\\$state来进行URL的跳转和路由\n- 将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置\n\n> 关于ui-router最重要的参考资料是 [ui-router的官方文档](http://angular-ui.github.io/ui-router/site/#/api/ui.router)（http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\n\n#### 代码实现\n\n1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js\n\n<!--more-->\n\n```\n <script src=\"js/angular.js\"></script>\n  <!-- Include the ui-router script -->\n  <script src=\"js/angular-ui-router.min.js\"></script>\n```\n\n2.在模块中引入依赖\n\n```\n  var app = angular.module('routerApp', ['ui.router']);\n```\n\n3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template\n4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。\n5.最后我们来新建一个js文件用来配置路由。\n\n#### 配置路由\n\n示例：\n\n```\napp.config(function ($stateProvider, $urlRouterProvider) {\n  $urlRouterProvider.when(\"\", \"/page1\");\n\t$stateProvider\n    .state('page1', {\n      url: '/page1',\n      templateUrl:'viewpage1.html',\n    }).state('page2', {\n      url: '/page2',\n      templateUrl:'view/page2.html',\n      })\n})\n```\n\n在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。\n\n- state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。\n- 第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。\n-第三个参数是用来设置模板，有两种方法。第一种使用\"template\"，指定一段Html字符串。第二种方法是像示例路由中那样，使用\"templateUrl\"来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）\n\n```\n$stateProvider.state('contacts', {\n  templateUrl: function (stateParams){\n    return '/partials/contacts.' + stateParams + '.html';\n  }\n})\n```\n\n#### 触发激活\n\n路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。\n比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）\n除了上面这种方法，我们还有两种方法来更新视图。\n\n- 调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。\n\n```\n$state.go('page1');  // 指定状态名\n$state.go('page1l', {pageId: 15});  //含参， 相当于跳转到 /page1/42\n```\n\n- 在浏览器地址栏中直接输入url，这是最直接的方法。\n\n#### 传递参数\n\n先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。\n从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html\n在view/resemeList.html中，我们写入如下一行：\n\n```\n<a href=\"\" ui-sref=\"openResume({resumeId:7})\">王大锤的简历</a>\n```\n\n然后，配置路由是这样的：\n\n```\nstate('openResume', {\n        url: '/openResume/{resumeId}',\n        templateUrl:function($stateParams){\n            console.log($stateParams);\n            return 'view/openResume.html'\n        }\n    })\n```\n我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：\n![](http://o7ts2uaks.bkt.clouddn.com/001.png)\n\n在控制台中我们看到了console出的语句\n![控制台](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png)\n\n说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~\n\n#### 嵌套视图\n\n接下来我们来了解一下ui-router区别于ng-router最强大的功能，**嵌套视图**。\n在示例路由的基础上，我们新建一个文件page1-main.html\n现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a>\n在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a>\n路由变成：\n\n```\n.state('page1',{\n  url : '/page1',\n  templateUrl : 'view/page1.html'\n})\n.state('page1.main',{\n  url : '/main',\n  emplateUrl : 'view/page1-main.html'\n})\n```\n\n这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。\n\n#### 多个视图\n\nui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。\n\n```\n<div ui-view></div>\n<div ui-view=\"chart\"></div> \n<div ui-view=\"data\"></div>\n```\n\n路由：\n\n```\n$stateProvider.state(\"home\", {\n  views: {\n    \"\": {\n      template: \"<h1>HELLO!</h1>\"\n    },\n    \"chart\": {\n      template: \"<chart_thing/>\"\n    },\n    \"data\": {\n      template: \"<data_thing/>\"\n    }\n  }\n})\n```","source":"_posts/angular-ui-router.md","raw":"---\nlayout: post\ntitle:  \"Angular  ui-router\"\ndate:   2015-11-23 20:17\ncategories: front-end javascript\n---\nUI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。\n\n#### 原生ng-route的不足之处：\n\n- 视图不能嵌套。这意味着$scope会发生不必要的重新载入。\n- 路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。\n\n#### 显而易见，ui-router的优势为：\n\n- 提出了\"$state\"的概念，通过改变\\$state来进行URL的跳转和路由\n- 将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置\n\n> 关于ui-router最重要的参考资料是 [ui-router的官方文档](http://angular-ui.github.io/ui-router/site/#/api/ui.router)（http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\n\n#### 代码实现\n\n1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js\n\n<!--more-->\n\n```\n <script src=\"js/angular.js\"></script>\n  <!-- Include the ui-router script -->\n  <script src=\"js/angular-ui-router.min.js\"></script>\n```\n\n2.在模块中引入依赖\n\n```\n  var app = angular.module('routerApp', ['ui.router']);\n```\n\n3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template\n4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。\n5.最后我们来新建一个js文件用来配置路由。\n\n#### 配置路由\n\n示例：\n\n```\napp.config(function ($stateProvider, $urlRouterProvider) {\n  $urlRouterProvider.when(\"\", \"/page1\");\n\t$stateProvider\n    .state('page1', {\n      url: '/page1',\n      templateUrl:'viewpage1.html',\n    }).state('page2', {\n      url: '/page2',\n      templateUrl:'view/page2.html',\n      })\n})\n```\n\n在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。\n\n- state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。\n- 第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。\n-第三个参数是用来设置模板，有两种方法。第一种使用\"template\"，指定一段Html字符串。第二种方法是像示例路由中那样，使用\"templateUrl\"来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）\n\n```\n$stateProvider.state('contacts', {\n  templateUrl: function (stateParams){\n    return '/partials/contacts.' + stateParams + '.html';\n  }\n})\n```\n\n#### 触发激活\n\n路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。\n比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）\n除了上面这种方法，我们还有两种方法来更新视图。\n\n- 调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。\n\n```\n$state.go('page1');  // 指定状态名\n$state.go('page1l', {pageId: 15});  //含参， 相当于跳转到 /page1/42\n```\n\n- 在浏览器地址栏中直接输入url，这是最直接的方法。\n\n#### 传递参数\n\n先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。\n从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html\n在view/resemeList.html中，我们写入如下一行：\n\n```\n<a href=\"\" ui-sref=\"openResume({resumeId:7})\">王大锤的简历</a>\n```\n\n然后，配置路由是这样的：\n\n```\nstate('openResume', {\n        url: '/openResume/{resumeId}',\n        templateUrl:function($stateParams){\n            console.log($stateParams);\n            return 'view/openResume.html'\n        }\n    })\n```\n我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：\n![](http://o7ts2uaks.bkt.clouddn.com/001.png)\n\n在控制台中我们看到了console出的语句\n![控制台](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png)\n\n说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~\n\n#### 嵌套视图\n\n接下来我们来了解一下ui-router区别于ng-router最强大的功能，**嵌套视图**。\n在示例路由的基础上，我们新建一个文件page1-main.html\n现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a>\n在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a>\n路由变成：\n\n```\n.state('page1',{\n  url : '/page1',\n  templateUrl : 'view/page1.html'\n})\n.state('page1.main',{\n  url : '/main',\n  emplateUrl : 'view/page1-main.html'\n})\n```\n\n这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。\n\n#### 多个视图\n\nui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。\n\n```\n<div ui-view></div>\n<div ui-view=\"chart\"></div> \n<div ui-view=\"data\"></div>\n```\n\n路由：\n\n```\n$stateProvider.state(\"home\", {\n  views: {\n    \"\": {\n      template: \"<h1>HELLO!</h1>\"\n    },\n    \"chart\": {\n      template: \"<chart_thing/>\"\n    },\n    \"data\": {\n      template: \"<data_thing/>\"\n    }\n  }\n})\n```","slug":"angular-ui-router","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyhw0001gbehmqau1haz","content":"<p>UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。</p>\n<h4 id=\"原生ng-route的不足之处：\"><a href=\"#原生ng-route的不足之处：\" class=\"headerlink\" title=\"原生ng-route的不足之处：\"></a>原生ng-route的不足之处：</h4><ul>\n<li>视图不能嵌套。这意味着$scope会发生不必要的重新载入。</li>\n<li>路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。</li>\n</ul>\n<h4 id=\"显而易见，ui-router的优势为：\"><a href=\"#显而易见，ui-router的优势为：\" class=\"headerlink\" title=\"显而易见，ui-router的优势为：\"></a>显而易见，ui-router的优势为：</h4><ul>\n<li>提出了”$state”的概念，通过改变\\$state来进行URL的跳转和路由</li>\n<li>将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置</li>\n</ul>\n<blockquote>\n<p>关于ui-router最重要的参考资料是 <a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router\" target=\"_blank\" rel=\"external\">ui-router的官方文档</a>（<a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\" target=\"_blank\" rel=\"external\">http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。</a></p>\n</blockquote>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"> &lt;!-- Include the ui-router script --&gt;</div><div class=\"line\"> &lt;script src=&quot;js/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>2.在模块中引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;routerApp&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure>\n<p>3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template<br>4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。<br>5.最后我们来新建一个js文件用来配置路由。</p>\n<h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config(function ($stateProvider, $urlRouterProvider) &#123;</div><div class=\"line\">  $urlRouterProvider.when(&quot;&quot;, &quot;/page1&quot;);</div><div class=\"line\">\t$stateProvider</div><div class=\"line\">    .state(&apos;page1&apos;, &#123;</div><div class=\"line\">      url: &apos;/page1&apos;,</div><div class=\"line\">      templateUrl:&apos;viewpage1.html&apos;,</div><div class=\"line\">    &#125;).state(&apos;page2&apos;, &#123;</div><div class=\"line\">      url: &apos;/page2&apos;,</div><div class=\"line\">      templateUrl:&apos;view/page2.html&apos;,</div><div class=\"line\">      &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。</p>\n<ul>\n<li>state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。</li>\n<li>第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。<br>-第三个参数是用来设置模板，有两种方法。第一种使用”template”，指定一段Html字符串。第二种方法是像示例路由中那样，使用”templateUrl”来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;</div><div class=\"line\">  templateUrl: function (stateParams)&#123;</div><div class=\"line\">    return &apos;/partials/contacts.&apos; + stateParams + &apos;.html&apos;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"触发激活\"><a href=\"#触发激活\" class=\"headerlink\" title=\"触发激活\"></a>触发激活</h4><p>路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。<br>比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）<br>除了上面这种方法，我们还有两种方法来更新视图。</p>\n<ul>\n<li>调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$state.go(&apos;page1&apos;);  // 指定状态名</div><div class=\"line\">$state.go(&apos;page1l&apos;, &#123;pageId: 15&#125;);  //含参， 相当于跳转到 /page1/42</div></pre></td></tr></table></figure>\n<ul>\n<li>在浏览器地址栏中直接输入url，这是最直接的方法。</li>\n</ul>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。<br>从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html<br>在view/resemeList.html中，我们写入如下一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;&quot; ui-sref=&quot;openResume(&#123;resumeId:7&#125;)&quot;&gt;王大锤的简历&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>然后，配置路由是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">state(&apos;openResume&apos;, &#123;</div><div class=\"line\">        url: &apos;/openResume/&#123;resumeId&#125;&apos;,</div><div class=\"line\">        templateUrl:function($stateParams)&#123;</div><div class=\"line\">            console.log($stateParams);</div><div class=\"line\">            return &apos;view/openResume.html&apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/001.png\" alt=\"\"></p>\n<p>在控制台中我们看到了console出的语句<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png\" alt=\"控制台\"></p>\n<p>说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p>接下来我们来了解一下ui-router区别于ng-router最强大的功能，<strong>嵌套视图</strong>。<br>在示例路由的基础上，我们新建一个文件page1-main.html<br>现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a><br>在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a><br>路由变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.state(&apos;page1&apos;,&#123;</div><div class=\"line\">  url : &apos;/page1&apos;,</div><div class=\"line\">  templateUrl : &apos;view/page1.html&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">.state(&apos;page1.main&apos;,&#123;</div><div class=\"line\">  url : &apos;/main&apos;,</div><div class=\"line\">  emplateUrl : &apos;view/page1-main.html&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。</p>\n<h4 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h4><p>ui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ui-view&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div ui-view=&quot;chart&quot;&gt;&lt;/div&gt; </div><div class=\"line\">&lt;div ui-view=&quot;data&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&quot;home&quot;, &#123;</div><div class=\"line\">  views: &#123;</div><div class=\"line\">    &quot;&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;h1&gt;HELLO!&lt;/h1&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;chart&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;chart_thing/&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;data&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;data_thing/&gt;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>","excerpt":"<p>UI-Router是Angular-UI提供的客户端路由框架，解决了原生ng-route的不足之处，它们的工作原理类似，区别的是ui-router只关注状态。</p>\n<h4 id=\"原生ng-route的不足之处：\"><a href=\"#原生ng-route的不足之处：\" class=\"headerlink\" title=\"原生ng-route的不足之处：\"></a>原生ng-route的不足之处：</h4><ul>\n<li>视图不能嵌套。这意味着$scope会发生不必要的重新载入。</li>\n<li>路由配置只有一个模板，无法配置多个，同一URL下不支持多个视图。</li>\n</ul>\n<h4 id=\"显而易见，ui-router的优势为：\"><a href=\"#显而易见，ui-router的优势为：\" class=\"headerlink\" title=\"显而易见，ui-router的优势为：\"></a>显而易见，ui-router的优势为：</h4><ul>\n<li>提出了”$state”的概念，通过改变\\$state来进行URL的跳转和路由</li>\n<li>将web界面的设计分块，在整个用户界面和导航中，一个状态对应于一个页面位置</li>\n</ul>\n<blockquote>\n<p>关于ui-router最重要的参考资料是 <a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router\">ui-router的官方文档</a>（<a href=\"http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。\">http://angular-ui.github.io/ui-router/site/#/api/ui.router）内容十分详尽。</a></p>\n</blockquote>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>1.引入文件：在index.html中除了angular.js之外，还要引入ui-router的文件ui-router.js</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"> &lt;!-- Include the ui-router script --&gt;</div><div class=\"line\"> &lt;script src=&quot;js/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>2.在模块中引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;routerApp&apos;, [&apos;ui.router&apos;]);</div></pre></td></tr></table></figure>\n<p>3.在html文件中使用ui-view指令，用来告诉$state该在哪插入template<br>4.添加触发器ui-sref（ui-sref=$state），你可以把它放在a标签内，button标签内，触发之后它就会在ui-view的位置更新对应的视图，选择不同的html文件来填充进包含ui-view的标签内。<br>5.最后我们来新建一个js文件用来配置路由。</p>\n<h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.config(function ($stateProvider, $urlRouterProvider) &#123;</div><div class=\"line\">  $urlRouterProvider.when(&quot;&quot;, &quot;/page1&quot;);</div><div class=\"line\">\t$stateProvider</div><div class=\"line\">    .state(&apos;page1&apos;, &#123;</div><div class=\"line\">      url: &apos;/page1&apos;,</div><div class=\"line\">      templateUrl:&apos;viewpage1.html&apos;,</div><div class=\"line\">    &#125;).state(&apos;page2&apos;, &#123;</div><div class=\"line\">      url: &apos;/page2&apos;,</div><div class=\"line\">      templateUrl:&apos;view/page2.html&apos;,</div><div class=\"line\">      &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在这个示例路由中，我们先定义了默认页，就是url为空或者是没有在路由配置中查询到相应状态名的情况下，默认展示的页面。</p>\n<ul>\n<li>state的第一个参数（如page1,page2）是状态名，可以将它放在触发器中用来触发视图更新。</li>\n<li>第二个参数url就是，当我们在浏览器地址栏中输入xx.com/index.html/url时，页面显示的是我们配置的相应的template。<br>-第三个参数是用来设置模板，有两种方法。第一种使用”template”，指定一段Html字符串。第二种方法是像示例路由中那样，使用”templateUrl”来指定模板文件。在这种方法中，我们也可以由函数来返回。（我们可以用这种方法来传递参数，后文再讲）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;</div><div class=\"line\">  templateUrl: function (stateParams)&#123;</div><div class=\"line\">    return &apos;/partials/contacts.&apos; + stateParams + &apos;.html&apos;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"触发激活\"><a href=\"#触发激活\" class=\"headerlink\" title=\"触发激活\"></a>触发激活</h4><p>路由配置完了，我们现在回到触发器上。上文讲到我们可以用ui-sref来作触发器。<br>比如，用\\<a href=\"\" ui-sref=\"page1\">进入page1\\</a>表示一个链接。点击它的话，我们的视图就会更新为view/page1.html的内容了。（在工程中最好把用以更新的视图的文件与index.html分开存储便于管理，在我的招聘项目中是把这些页面都存在view文件夹中，像index.html,login.html这些文件存在外面）<br>除了上面这种方法，我们还有两种方法来更新视图。</p>\n<ul>\n<li>调用$state.go()方法：这是ui-router特有的方法，可以用在js文件中手动更新视图。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$state.go(&apos;page1&apos;);  // 指定状态名</div><div class=\"line\">$state.go(&apos;page1l&apos;, &#123;pageId: 15&#125;);  //含参， 相当于跳转到 /page1/42</div></pre></td></tr></table></figure>\n<ul>\n<li>在浏览器地址栏中直接输入url，这是最直接的方法。</li>\n</ul>\n<h4 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h4><p>先给个应用场景好了，在一个简历列表页中，我想点击不同的简历名，就跳转到相应的简历详情。在这一过程中必然要传递参数，这样才能在简历详情页中看到自己想要浏览的那份简历。<br>从头开始看，我们有一个简历详情页面view/openResume.html，还有以一个简历列表页view/resumeList.html<br>在view/resemeList.html中，我们写入如下一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;&quot; ui-sref=&quot;openResume(&#123;resumeId:7&#125;)&quot;&gt;王大锤的简历&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>然后，配置路由是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">state(&apos;openResume&apos;, &#123;</div><div class=\"line\">        url: &apos;/openResume/&#123;resumeId&#125;&apos;,</div><div class=\"line\">        templateUrl:function($stateParams)&#123;</div><div class=\"line\">            console.log($stateParams);</div><div class=\"line\">            return &apos;view/openResume.html&apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>我们点击链接“王大锤的简历”，发现视图更新了，浏览器地址栏变成了：<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/001.png\" alt=\"\"></p>\n<p>在控制台中我们看到了console出的语句<br><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151222154531.png\" alt=\"控制台\"></p>\n<p>说明如果想在路由中传递参数，就是加一个括号，里面放一个我们要传递的对象即可。当然了我们可以通过很多方法完成动态传参的需求~</p>\n<h4 id=\"嵌套视图\"><a href=\"#嵌套视图\" class=\"headerlink\" title=\"嵌套视图\"></a>嵌套视图</h4><p>接下来我们来了解一下ui-router区别于ng-router最强大的功能，<strong>嵌套视图</strong>。<br>在示例路由的基础上，我们新建一个文件page1-main.html<br>现在，在index.html中：\\<a href=\"\" ui-sref=\"page1\">进入page1</a><br>在page1.html中，：\\<a href=\"\" ui-sref=\"page1.main\">进入page1-main</a><br>路由变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.state(&apos;page1&apos;,&#123;</div><div class=\"line\">  url : &apos;/page1&apos;,</div><div class=\"line\">  templateUrl : &apos;view/page1.html&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">.state(&apos;page1.main&apos;,&#123;</div><div class=\"line\">  url : &apos;/main&apos;,</div><div class=\"line\">  emplateUrl : &apos;view/page1-main.html&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样我们就完成了嵌套视图，在ui-router中我们可以进行任意层级的嵌套，在page1-main的同级，子级我们依然可以再嵌套别的视图。</p>\n<h4 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h4><p>ui-router的另一优越性在于，一个$state下可以有多个视图，它们有各自的模板和控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ui-view&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div ui-view=&quot;chart&quot;&gt;&lt;/div&gt; </div><div class=\"line\">&lt;div ui-view=&quot;data&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$stateProvider.state(&quot;home&quot;, &#123;</div><div class=\"line\">  views: &#123;</div><div class=\"line\">    &quot;&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;h1&gt;HELLO!&lt;/h1&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;chart&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;chart_thing/&gt;&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;data&quot;: &#123;</div><div class=\"line\">      template: &quot;&lt;data_thing/&gt;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>"},{"layout":"post","title":"How does data binding work in AngularJS","date":"2016-06-05T07:28:00.000Z","_content":"\nAngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。\n\n`$apply()`这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有`$digest()`方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。\n\n### 关于$watch\n\n每一次你在UI中绑定什么东西时你就会往`$watch`的队列中插入一条`$watch`，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：\n\n```\nUser: <input type=\"text\" ng-model=\"user\" />\nPassword: <input type=\"password\" ng-model=\"pass\" />\n```\n\n在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。\n\n<!--more-->\n\n每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。\n\n一个watcher包含了三个东西：\n\n- 它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西\n\n- 这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty\n\n- 被触发执行的函数\n\n```\n$$watchers = [\n    {\n        eq: false, // 表明我们是否需要检查对象级别的相等\n        fn: function( newValue, oldValue ) {}, // 这是我们提供的监听器函数\n        last: 'Ryan', // 变量的最新值\n        exp: function(){}, // 我们提供的watchExp函数\n        get: function(){} // Angular's编译后的watchExp函数\n    }\n];\n```\n\n定义监听器的几种方法：\n1.把$watch设置为$scope的一种属性:`$scope.$watch('person.username', validateUnique);`\n2.插入angular表达式:`<p>username: {{person.username}}</p>`\n3.使用类似于ng-model的指令来定义监听器:`<input ng-model=\"person.username />`\n\n\n\n\n### 关于$digest和$apply\n如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。\n\n当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。\n\nAngularJS的$apply函数代码如下所示：\n\n```\n$apply: function(expr) {\n    try {\n      beginPhase('$apply');\n      return this.$eval(expr);\n    } catch (e) {\n      $exceptionHandler(e);\n    } finally {\n      clearPhase();\n      try {\n        $rootScope.$digest();\n      } catch (e) {\n        $exceptionHandler(e);\n        throw e;\n      }\n    }\n}\n```\n由此可见，使用$apply可带参数。\n\n$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。\n\n监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。\n\n$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。\n\n### build your own dirty-checking\n了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。\n首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];   \n};\n\nScope.prototype.$watch = function( ) {\n\n};\n\nScope.prototype.$digest = function( ) {\n\n};\n```\n\n设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：\n\n```\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n```\n\n如果没有传入listener的话我们会把它设置为空函数。\n$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。\n\n```\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n```\n\n下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest\n\n```\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log(newValue, oldValue);\n} );\n\n$scope.$digest();\n```\n\n我们发现在控制台输出了`Ryan undefined`，成功了！\n最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];\n};\n\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n\n\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\nvar element = document.querySelectorAll('input');\n\nelement[0].onkeyup = function() {\n    $scope.name = element[0].value;\n\n    $scope.$digest();\n};\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log('Input value updated - it is now ' + newValue);\n\n    element[0].value = $scope.name;\n} );\n\nvar updateScopeValue = function updateScopeValue( ) {\n    $scope.name = 'Bob';\n    $scope.$digest();\n};\n```\n\n### 参考内容\n\n* [RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves](https://ryanclark.me/how-angularjs-implements-dirty-checking)\n* [stackoverflow:How does data binding work in AngularJS?](http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs)\n* [徐飞:Angular沉思录（一）](https://github.com/xufei/blog/issues/10)\n* [angular-tips:$watch How the $apply Runs a $digest](http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/)\n* [IBM developerWorks:AngularJS 作用域与数据绑定机制](https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/)\n\n\n\n\n\n","source":"_posts/angular-data-binding.markdown","raw":"---\nlayout: post\ntitle:  \"How does data binding work in AngularJS\"\ndate:   2016-06-05 15:28\ncategories: front-end javascript\n---\n\nAngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。\n\n`$apply()`这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有`$digest()`方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。\n\n### 关于$watch\n\n每一次你在UI中绑定什么东西时你就会往`$watch`的队列中插入一条`$watch`，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：\n\n```\nUser: <input type=\"text\" ng-model=\"user\" />\nPassword: <input type=\"password\" ng-model=\"pass\" />\n```\n\n在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。\n\n<!--more-->\n\n每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。\n\n一个watcher包含了三个东西：\n\n- 它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西\n\n- 这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty\n\n- 被触发执行的函数\n\n```\n$$watchers = [\n    {\n        eq: false, // 表明我们是否需要检查对象级别的相等\n        fn: function( newValue, oldValue ) {}, // 这是我们提供的监听器函数\n        last: 'Ryan', // 变量的最新值\n        exp: function(){}, // 我们提供的watchExp函数\n        get: function(){} // Angular's编译后的watchExp函数\n    }\n];\n```\n\n定义监听器的几种方法：\n1.把$watch设置为$scope的一种属性:`$scope.$watch('person.username', validateUnique);`\n2.插入angular表达式:`<p>username: {{person.username}}</p>`\n3.使用类似于ng-model的指令来定义监听器:`<input ng-model=\"person.username />`\n\n\n\n\n### 关于$digest和$apply\n如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。\n\n当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。\n\nAngularJS的$apply函数代码如下所示：\n\n```\n$apply: function(expr) {\n    try {\n      beginPhase('$apply');\n      return this.$eval(expr);\n    } catch (e) {\n      $exceptionHandler(e);\n    } finally {\n      clearPhase();\n      try {\n        $rootScope.$digest();\n      } catch (e) {\n        $exceptionHandler(e);\n        throw e;\n      }\n    }\n}\n```\n由此可见，使用$apply可带参数。\n\n$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。\n\n监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。\n\n$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。\n\n### build your own dirty-checking\n了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。\n首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];   \n};\n\nScope.prototype.$watch = function( ) {\n\n};\n\nScope.prototype.$digest = function( ) {\n\n};\n```\n\n设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：\n\n```\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n```\n\n如果没有传入listener的话我们会把它设置为空函数。\n$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。\n\n```\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n```\n\n下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest\n\n```\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log(newValue, oldValue);\n} );\n\n$scope.$digest();\n```\n\n我们发现在控制台输出了`Ryan undefined`，成功了！\n最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！\n\n```\nvar Scope = function( ) {\n    this.$$watchers = [];\n};\n\nScope.prototype.$watch = function( watchExp, listener ) {\n    this.$$watchers.push( {\n        watchExp: watchExp,\n        listener: listener || function() {}\n    } );\n};\n\nScope.prototype.$digest = function( ) {\n    var dirty;\n\n    do {\n            dirty = false;\n\n            for( var i = 0; i < this.$$watchers.length; i++ ) {\n                var newValue = this.$$watchers[i].watchExp(),\n                    oldValue = this.$$watchers[i].last;\n\n                if( oldValue !== newValue ) {\n                    this.$$watchers[i].listener(newValue, oldValue);\n\n                    dirty = true;\n\n                    this.$$watchers[i].last = newValue;\n                }\n            }\n    } while(dirty);\n};\n\n\nvar $scope = new Scope();\n\n$scope.name = 'Ryan';\n\nvar element = document.querySelectorAll('input');\n\nelement[0].onkeyup = function() {\n    $scope.name = element[0].value;\n\n    $scope.$digest();\n};\n\n$scope.$watch(function(){\n    return $scope.name;\n}, function( newValue, oldValue ) {\n    console.log('Input value updated - it is now ' + newValue);\n\n    element[0].value = $scope.name;\n} );\n\nvar updateScopeValue = function updateScopeValue( ) {\n    $scope.name = 'Bob';\n    $scope.$digest();\n};\n```\n\n### 参考内容\n\n* [RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves](https://ryanclark.me/how-angularjs-implements-dirty-checking)\n* [stackoverflow:How does data binding work in AngularJS?](http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs)\n* [徐飞:Angular沉思录（一）](https://github.com/xufei/blog/issues/10)\n* [angular-tips:$watch How the $apply Runs a $digest](http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/)\n* [IBM developerWorks:AngularJS 作用域与数据绑定机制](https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/)\n\n\n\n\n\n","slug":"angular-data-binding","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyi20003gbeh1y55q7o2","content":"<p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>\n<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>\n<h3 id=\"关于-watch\"><a href=\"#关于-watch\" class=\"headerlink\" title=\"关于$watch\"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</div><div class=\"line\">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p>\n<a id=\"more\"></a>\n<p>每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。</p>\n<p>一个watcher包含了三个东西：</p>\n<ul>\n<li><p>它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西</p>\n</li>\n<li><p>这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty</p>\n</li>\n<li><p>被触发执行的函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$$watchers = [</div><div class=\"line\">    &#123;</div><div class=\"line\">        eq: false, // 表明我们是否需要检查对象级别的相等</div><div class=\"line\">        fn: function( newValue, oldValue ) &#123;&#125;, // 这是我们提供的监听器函数</div><div class=\"line\">        last: &apos;Ryan&apos;, // 变量的最新值</div><div class=\"line\">        exp: function()&#123;&#125;, // 我们提供的watchExp函数</div><div class=\"line\">        get: function()&#123;&#125; // Angular&apos;s编译后的watchExp函数</div><div class=\"line\">    &#125;</div><div class=\"line\">];</div></pre></td></tr></table></figure>\n<p>定义监听器的几种方法：<br>1.把$watch设置为$scope的一种属性:<code>$scope.$watch(&#39;person.username&#39;, validateUnique);</code><br>2.插入angular表达式:<code>&lt;p&gt;username: &lt;/p&gt;</code><br>3.使用类似于ng-model的指令来定义监听器:<code>&lt;input ng-model=&quot;person.username /&gt;</code></p>\n<h3 id=\"关于-digest和-apply\"><a href=\"#关于-digest和-apply\" class=\"headerlink\" title=\"关于$digest和$apply\"></a>关于$digest和$apply</h3><p>如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。</p>\n<p>当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。</p>\n<p>AngularJS的$apply函数代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$apply: function(expr) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">      beginPhase(&apos;$apply&apos;);</div><div class=\"line\">      return this.$eval(expr);</div><div class=\"line\">    &#125; catch (e) &#123;</div><div class=\"line\">      $exceptionHandler(e);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">      clearPhase();</div><div class=\"line\">      try &#123;</div><div class=\"line\">        $rootScope.$digest();</div><div class=\"line\">      &#125; catch (e) &#123;</div><div class=\"line\">        $exceptionHandler(e);</div><div class=\"line\">        throw e;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由此可见，使用$apply可带参数。</p>\n<p>$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。</p>\n<p>监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。</p>\n<p>$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。</p>\n<h3 id=\"build-your-own-dirty-checking\"><a href=\"#build-your-own-dirty-checking\" class=\"headerlink\" title=\"build your own dirty-checking\"></a>build your own dirty-checking</h3><p>了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。<br>首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];   </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果没有传入listener的话我们会把它设置为空函数。<br>$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(newValue, oldValue);</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">$scope.$digest();</div></pre></td></tr></table></figure>\n<p>我们发现在控制台输出了<code>Ryan undefined</code>，成功了！<br>最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">var element = document.querySelectorAll(&apos;input&apos;);</div><div class=\"line\"></div><div class=\"line\">element[0].onkeyup = function() &#123;</div><div class=\"line\">    $scope.name = element[0].value;</div><div class=\"line\"></div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(&apos;Input value updated - it is now &apos; + newValue);</div><div class=\"line\"></div><div class=\"line\">    element[0].value = $scope.name;</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">var updateScopeValue = function updateScopeValue( ) &#123;</div><div class=\"line\">    $scope.name = &apos;Bob&apos;;</div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://ryanclark.me/how-angularjs-implements-dirty-checking\" target=\"_blank\" rel=\"external\">RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs\" target=\"_blank\" rel=\"external\">stackoverflow:How does data binding work in AngularJS?</a></li>\n<li><a href=\"https://github.com/xufei/blog/issues/10\" target=\"_blank\" rel=\"external\">徐飞:Angular沉思录（一）</a></li>\n<li><a href=\"http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/\" target=\"_blank\" rel=\"external\">angular-tips:$watch How the $apply Runs a $digest</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/\" target=\"_blank\" rel=\"external\">IBM developerWorks:AngularJS 作用域与数据绑定机制</a></li>\n</ul>\n","excerpt":"<p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>\n<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>\n<h3 id=\"关于-watch\"><a href=\"#关于-watch\" class=\"headerlink\" title=\"关于$watch\"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</div><div class=\"line\">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p>","more":"<p>每一个绑定到了UI上的数据都会生成一个$watch，我们的模板加载完成时，也就是在linking阶段，Angular解释器会寻找每一个directive并且创造它们所需的$watch。</p>\n<p>一个watcher包含了三个东西：</p>\n<ul>\n<li><p>它正在监听的表达式。有可能是一个简单的属性名，也有可能是更复杂的东西</p>\n</li>\n<li><p>这个表达式目前已知的value值，它会与当前正在计算的表达式value值进行核对比较，如果监听到value值发生了改变将会触发函数并把$scope标记为dirty</p>\n</li>\n<li><p>被触发执行的函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$$watchers = [</div><div class=\"line\">    &#123;</div><div class=\"line\">        eq: false, // 表明我们是否需要检查对象级别的相等</div><div class=\"line\">        fn: function( newValue, oldValue ) &#123;&#125;, // 这是我们提供的监听器函数</div><div class=\"line\">        last: &apos;Ryan&apos;, // 变量的最新值</div><div class=\"line\">        exp: function()&#123;&#125;, // 我们提供的watchExp函数</div><div class=\"line\">        get: function()&#123;&#125; // Angular&apos;s编译后的watchExp函数</div><div class=\"line\">    &#125;</div><div class=\"line\">];</div></pre></td></tr></table></figure>\n<p>定义监听器的几种方法：<br>1.把$watch设置为$scope的一种属性:<code>$scope.$watch(&#39;person.username&#39;, validateUnique);</code><br>2.插入angular表达式:<code>&lt;p&gt;username: &lt;/p&gt;</code><br>3.使用类似于ng-model的指令来定义监听器:<code>&lt;input ng-model=&quot;person.username /&gt;</code></p>\n<h3 id=\"关于-digest和-apply\"><a href=\"#关于-digest和-apply\" class=\"headerlink\" title=\"关于$digest和$apply\"></a>关于$digest和$apply</h3><p>如果你点击一个按钮，或者在一个input框中输入，事件的回调函数会在javascript中运行，并且你可以做任意的DOM操作，当回调函数结束时，浏览器会相应地在DOM中做出改变。</p>\n<p>当一个控制器/指令/等等东西在AngularJS中运行时，AngularJS内部会运行一个叫做$scope.$apply的函数。这个$apply函数会接收一个函数作为参数并运行它，在这之后才会在rootScope上运行$digest函数。</p>\n<p>AngularJS的$apply函数代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$apply: function(expr) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">      beginPhase(&apos;$apply&apos;);</div><div class=\"line\">      return this.$eval(expr);</div><div class=\"line\">    &#125; catch (e) &#123;</div><div class=\"line\">      $exceptionHandler(e);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">      clearPhase();</div><div class=\"line\">      try &#123;</div><div class=\"line\">        $rootScope.$digest();</div><div class=\"line\">      &#125; catch (e) &#123;</div><div class=\"line\">        $exceptionHandler(e);</div><div class=\"line\">        throw e;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由此可见，使用$apply可带参数。</p>\n<p>$digest函数将会在$rootScope中被$scope.$apply所调用。它将会在$rootScope中运行digest循环，然后向下遍历每一个作用域并在每个作用域上运行循环。在简单的情形中，digest循环将会触发所有位于$$watchers变量中的所有watchExp函数，将它们和最新的值进行对比，如果值不相同，就会触发监听器。$digest函数检查$watch队列中的所有监听器最新的value值，一次$digest循环是被指令触发的。如果表达式新的value值与之前不同，就会调用监听器的函数，这个函数可能是重新编译部分的DOM，重新计算$scope的值，激活一个AJAX请求，或者任何你想做的事。</p>\n<p>监听器函数可以修改$scope或是父$scope的其他属性，一旦有出发了一个监听器函数，我们就无法保证其它的$scope也是干净的，所以我们会再次执行整个digest循环。</p>\n<p>$apply与$digest作用类似，$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。不同之处在于$apply可以带参数，并且会触发作用域上的所有监控，\\$digest仅仅触发当前作用域和子作用域的监控。</p>\n<h3 id=\"build-your-own-dirty-checking\"><a href=\"#build-your-own-dirty-checking\" class=\"headerlink\" title=\"build your own dirty-checking\"></a>build your own dirty-checking</h3><p>了解以上知识后，我们可以自己写一个具有基本功能的脏检测了。<br>首先定义Scope，然后扩展这个函数的原型对象来复制\\$digest和\\$watch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];   </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>设置\\$watch函数，它接收watchExp和listener这两个参数，被调用时我们会把其push到$$watchers数组中。因此代码扩展为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果没有传入listener的话我们会把它设置为空函数。<br>$digest用来检查新值旧值是否相等，如果不相等则触发监听器，不断循环这个过程，直到新值旧值相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>下一步我们需要创建一个作用域的实例，并把实例赋值给$scope，然后注册监听函数，使得更新$scope之后运行$digest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(newValue, oldValue);</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">$scope.$digest();</div></pre></td></tr></table></figure>\n<p>我们发现在控制台输出了<code>Ryan undefined</code>，成功了！<br>最后我们可以把$digest函数绑定到事件上，比如input元素的keyup事件，即意味着我们可以实现双向数据绑定！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Scope = function( ) &#123;</div><div class=\"line\">    this.$$watchers = [];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$watch = function( watchExp, listener ) &#123;</div><div class=\"line\">    this.$$watchers.push( &#123;</div><div class=\"line\">        watchExp: watchExp,</div><div class=\"line\">        listener: listener || function() &#123;&#125;</div><div class=\"line\">    &#125; );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Scope.prototype.$digest = function( ) &#123;</div><div class=\"line\">    var dirty;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">            dirty = false;</div><div class=\"line\"></div><div class=\"line\">            for( var i = 0; i &lt; this.$$watchers.length; i++ ) &#123;</div><div class=\"line\">                var newValue = this.$$watchers[i].watchExp(),</div><div class=\"line\">                    oldValue = this.$$watchers[i].last;</div><div class=\"line\"></div><div class=\"line\">                if( oldValue !== newValue ) &#123;</div><div class=\"line\">                    this.$$watchers[i].listener(newValue, oldValue);</div><div class=\"line\"></div><div class=\"line\">                    dirty = true;</div><div class=\"line\"></div><div class=\"line\">                    this.$$watchers[i].last = newValue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125; while(dirty);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var $scope = new Scope();</div><div class=\"line\"></div><div class=\"line\">$scope.name = &apos;Ryan&apos;;</div><div class=\"line\"></div><div class=\"line\">var element = document.querySelectorAll(&apos;input&apos;);</div><div class=\"line\"></div><div class=\"line\">element[0].onkeyup = function() &#123;</div><div class=\"line\">    $scope.name = element[0].value;</div><div class=\"line\"></div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(function()&#123;</div><div class=\"line\">    return $scope.name;</div><div class=\"line\">&#125;, function( newValue, oldValue ) &#123;</div><div class=\"line\">    console.log(&apos;Input value updated - it is now &apos; + newValue);</div><div class=\"line\"></div><div class=\"line\">    element[0].value = $scope.name;</div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">var updateScopeValue = function updateScopeValue( ) &#123;</div><div class=\"line\">    $scope.name = &apos;Bob&apos;;</div><div class=\"line\">    $scope.$digest();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://ryanclark.me/how-angularjs-implements-dirty-checking\">RyanClark:How AngularJS implements dirty checking and how to replicate it ourselves</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9682092/how-does-data-binding-work-in-angularjs\">stackoverflow:How does data binding work in AngularJS?</a></li>\n<li><a href=\"https://github.com/xufei/blog/issues/10\">徐飞:Angular沉思录（一）</a></li>\n<li><a href=\"http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/\">angular-tips:$watch How the $apply Runs a $digest</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/\">IBM developerWorks:AngularJS 作用域与数据绑定机制</a></li>\n</ul>"},{"layout":"post","title":"一些关于 fetch api 的基本设定","date":"2016-08-22T08:24:00.000Z","_content":"\n长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api `Fetch`来替换它。\n\n### XMLHttpRequest的缺陷\n\n先看一个典型的XHR例子：\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', url);\nxhr.responseType = 'json';\n\nxhr.onload = function() {\n  console.log(xhr.response);\n};\n\nxhr.onerror = function() {\n  console.log(\"Booo\");\n};\n\nxhr.send();\n```\n可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。\n\n<!--more-->\n\n### Fetch Api的特点\n\nfetch api是基于`Promise`设计的，定义在BOM的`window`对象之中。建议阅读资料：\n\n* [Fetch Living Standard](https://fetch.spec.whatwg.org/)\n* [MDN: GlobalFetch 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch)\n* [caniuse 浏览器支持率](http://caniuse.com/#search=fetch)\n\n![caniuse-fetch](http://o7ts2uaks.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-18%20%E4%B8%8B%E5%8D%8810.03.45.png)\n\n截止到2016年8月，Chrome43+，Firefox47+支持fetch api，对于低版本的浏览器，github上有许多[polyfill](https://github.com/camsong/fetch-ie8)可以使其兼容。\n\n一个典型的fetch例子：\n```javascript\nfetch(url).then(function(response) {\n  return response.json();\n}).then(function(data) {\n  console.log(data);\n}).catch(function() {\n  console.log(\"Booo\");\n});\n```\n\n用ES6的箭头函数重构之后：\n```javascript\nfetch(url).then(r => r.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Booo\"))\n```\n\n用还处于草案阶段的[ES7的async函数](http://es6.ruanyifeng.com/#docs/async#async函数)再重构一下：\n```javascript\n(async() => {\n  try {\n    var response = await fetch(url);\n    var data = await response.json();\n    console.log(data);\n  } catch (e) {\n    console.log(\"Booo\")\n  }\n})();\n```\n就可以把一个异步的请求代码结构写得看起来跟同步请求差不多了。\n\n由此可见，`Fetch`基于Promise实现，支持async/await，语法更简洁。\n\n### How to Use\n\n#### fetch()\n\n语法：\n```javascript\nfetch(input, init).then(function(response) { ... });\n```\n参数：\n\n* `input` :要获取的资源\n  * 字符串，资源的url\n  * 一个`Request`对象（后面会介绍Request)\n* `init` :可选，是请求的配置项\n  * method: 请求方式，GET/POST/PUT/DELETE等等\n  * headers: 请求头，可能是` Headers 对象`或者 ByteString\n  * body: 请求的Body信息\n  * mode: 请求的模式，cors/no-cors/same-origin\n  * credentials: 请求的credentials，omit/same-origin/include\n  * cache: 请求的缓存模式， default/no-store/reload/ no-cache/force-cache/only-if-cached\n\n返回值：返回一个`Promise对象`\n\nFetch引入了3个接口，它们分别是 `Headers`,`Request` 以及 `Response` 。\n\n#### Headers()\n\nHeaders()是一个可检索的多映射名值表，也可穿多维数组或者json\n\n```javascript\nvar reqHeaders = new Headers();\nreqHeaders = new Headers({\n  \"Content-Length\": content.length.toString(),\n});\nreqHeaders.append(\"Content-Type\", \"text/plain\");\nconsole.log(reqHeaders.has(\"Content-Type\")); // true\nconsole.log(reqHeaders.has(\"Set-Cookie\")); // false\n```\nHeaders()有一个`guard`属性来规定哪些参数是可写的。\n\n#### Requset()\n\n语法，参数与fetch()类似：\n\n\n`var myRequest = new Request(input, init);`\n\n其中可选的init配置项比fetch()多了几项(redirect/integrity/referrer)\n\n#### Response()\n\n在fetch()的回调中我们可以获得一个[Response实例](https://developer.mozilla.org/en-US/docs/Web/API/Response)。Response有很多实用的只读属性，比如Response.ok/Response.type/Response.headers等等。\n\n\n### 参考内容\n* [MDN: GlobalFetch 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch)\n* [Jake Archibald: That's so fetch](https://jakearchibald.com/2015/thats-so-fetch/)\n* [Hacks Mozilla: This API is so Fetching](https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/)\n* [camsong: 传统Ajax 已死，Fetch 永生](https://github.com/camsong/blog/issues/2)\n","source":"_posts/basic-fetch-api.md","raw":"---\nlayout: post\ntitle:  \"一些关于 fetch api 的基本设定\"\ndate:   2016-08-22 16:24\ncategories: javascript\n---\n\n长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api `Fetch`来替换它。\n\n### XMLHttpRequest的缺陷\n\n先看一个典型的XHR例子：\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', url);\nxhr.responseType = 'json';\n\nxhr.onload = function() {\n  console.log(xhr.response);\n};\n\nxhr.onerror = function() {\n  console.log(\"Booo\");\n};\n\nxhr.send();\n```\n可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。\n\n<!--more-->\n\n### Fetch Api的特点\n\nfetch api是基于`Promise`设计的，定义在BOM的`window`对象之中。建议阅读资料：\n\n* [Fetch Living Standard](https://fetch.spec.whatwg.org/)\n* [MDN: GlobalFetch 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch)\n* [caniuse 浏览器支持率](http://caniuse.com/#search=fetch)\n\n![caniuse-fetch](http://o7ts2uaks.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-18%20%E4%B8%8B%E5%8D%8810.03.45.png)\n\n截止到2016年8月，Chrome43+，Firefox47+支持fetch api，对于低版本的浏览器，github上有许多[polyfill](https://github.com/camsong/fetch-ie8)可以使其兼容。\n\n一个典型的fetch例子：\n```javascript\nfetch(url).then(function(response) {\n  return response.json();\n}).then(function(data) {\n  console.log(data);\n}).catch(function() {\n  console.log(\"Booo\");\n});\n```\n\n用ES6的箭头函数重构之后：\n```javascript\nfetch(url).then(r => r.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Booo\"))\n```\n\n用还处于草案阶段的[ES7的async函数](http://es6.ruanyifeng.com/#docs/async#async函数)再重构一下：\n```javascript\n(async() => {\n  try {\n    var response = await fetch(url);\n    var data = await response.json();\n    console.log(data);\n  } catch (e) {\n    console.log(\"Booo\")\n  }\n})();\n```\n就可以把一个异步的请求代码结构写得看起来跟同步请求差不多了。\n\n由此可见，`Fetch`基于Promise实现，支持async/await，语法更简洁。\n\n### How to Use\n\n#### fetch()\n\n语法：\n```javascript\nfetch(input, init).then(function(response) { ... });\n```\n参数：\n\n* `input` :要获取的资源\n  * 字符串，资源的url\n  * 一个`Request`对象（后面会介绍Request)\n* `init` :可选，是请求的配置项\n  * method: 请求方式，GET/POST/PUT/DELETE等等\n  * headers: 请求头，可能是` Headers 对象`或者 ByteString\n  * body: 请求的Body信息\n  * mode: 请求的模式，cors/no-cors/same-origin\n  * credentials: 请求的credentials，omit/same-origin/include\n  * cache: 请求的缓存模式， default/no-store/reload/ no-cache/force-cache/only-if-cached\n\n返回值：返回一个`Promise对象`\n\nFetch引入了3个接口，它们分别是 `Headers`,`Request` 以及 `Response` 。\n\n#### Headers()\n\nHeaders()是一个可检索的多映射名值表，也可穿多维数组或者json\n\n```javascript\nvar reqHeaders = new Headers();\nreqHeaders = new Headers({\n  \"Content-Length\": content.length.toString(),\n});\nreqHeaders.append(\"Content-Type\", \"text/plain\");\nconsole.log(reqHeaders.has(\"Content-Type\")); // true\nconsole.log(reqHeaders.has(\"Set-Cookie\")); // false\n```\nHeaders()有一个`guard`属性来规定哪些参数是可写的。\n\n#### Requset()\n\n语法，参数与fetch()类似：\n\n\n`var myRequest = new Request(input, init);`\n\n其中可选的init配置项比fetch()多了几项(redirect/integrity/referrer)\n\n#### Response()\n\n在fetch()的回调中我们可以获得一个[Response实例](https://developer.mozilla.org/en-US/docs/Web/API/Response)。Response有很多实用的只读属性，比如Response.ok/Response.type/Response.headers等等。\n\n\n### 参考内容\n* [MDN: GlobalFetch 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch)\n* [Jake Archibald: That's so fetch](https://jakearchibald.com/2015/thats-so-fetch/)\n* [Hacks Mozilla: This API is so Fetching](https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/)\n* [camsong: 传统Ajax 已死，Fetch 永生](https://github.com/camsong/blog/issues/2)\n","slug":"basic-fetch-api","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyid0005gbeh6pmgmo53","content":"<p>长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api <code>Fetch</code>来替换它。</p>\n<h3 id=\"XMLHttpRequest的缺陷\"><a href=\"#XMLHttpRequest的缺陷\" class=\"headerlink\" title=\"XMLHttpRequest的缺陷\"></a>XMLHttpRequest的缺陷</h3><p>先看一个典型的XHR例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">xhr.open(<span class=\"string\">'GET'</span>, url);</div><div class=\"line\">xhr.responseType = <span class=\"string\">'json'</span>;</div><div class=\"line\"></div><div class=\"line\">xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(xhr.response);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.send();</div></pre></td></tr></table></figure></p>\n<p>可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。</p>\n<a id=\"more\"></a>\n<h3 id=\"Fetch-Api的特点\"><a href=\"#Fetch-Api的特点\" class=\"headerlink\" title=\"Fetch Api的特点\"></a>Fetch Api的特点</h3><p>fetch api是基于<code>Promise</code>设计的，定义在BOM的<code>window</code>对象之中。建议阅读资料：</p>\n<ul>\n<li><a href=\"https://fetch.spec.whatwg.org/\" target=\"_blank\" rel=\"external\">Fetch Living Standard</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch\" target=\"_blank\" rel=\"external\">MDN: GlobalFetch 文档</a></li>\n<li><a href=\"http://caniuse.com/#search=fetch\" target=\"_blank\" rel=\"external\">caniuse 浏览器支持率</a></li>\n</ul>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-18%20%E4%B8%8B%E5%8D%8810.03.45.png\" alt=\"caniuse-fetch\"></p>\n<p>截止到2016年8月，Chrome43+，Firefox47+支持fetch api，对于低版本的浏览器，github上有许多<a href=\"https://github.com/camsong/fetch-ie8\" target=\"_blank\" rel=\"external\">polyfill</a>可以使其兼容。</p>\n<p>一个典型的fetch例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(url).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> response.json();</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>用ES6的箭头函数重构之后：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(url).then(r =&gt; r.json())</div><div class=\"line\">  .then(data =&gt; <span class=\"built_in\">console</span>.log(data))</div><div class=\"line\">  .catch(e =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>))</div></pre></td></tr></table></figure></p>\n<p>用还处于草案阶段的<a href=\"http://es6.ruanyifeng.com/#docs/async#async函数\" target=\"_blank\" rel=\"external\">ES7的async函数</a>再重构一下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">async</span>() =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> response = <span class=\"keyword\">await</span> fetch(url);</div><div class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> response.json();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>就可以把一个异步的请求代码结构写得看起来跟同步请求差不多了。</p>\n<p>由此可见，<code>Fetch</code>基于Promise实现，支持async/await，语法更简洁。</p>\n<h3 id=\"How-to-Use\"><a href=\"#How-to-Use\" class=\"headerlink\" title=\"How to Use\"></a>How to Use</h3><h4 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch()\"></a>fetch()</h4><p>语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(input, init).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123; ... &#125;);</div></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>input</code> :要获取的资源<ul>\n<li>字符串，资源的url</li>\n<li>一个<code>Request</code>对象（后面会介绍Request)</li>\n</ul>\n</li>\n<li><code>init</code> :可选，是请求的配置项<ul>\n<li>method: 请求方式，GET/POST/PUT/DELETE等等</li>\n<li>headers: 请求头，可能是<code>Headers 对象</code>或者 ByteString</li>\n<li>body: 请求的Body信息</li>\n<li>mode: 请求的模式，cors/no-cors/same-origin</li>\n<li>credentials: 请求的credentials，omit/same-origin/include</li>\n<li>cache: 请求的缓存模式， default/no-store/reload/ no-cache/force-cache/only-if-cached</li>\n</ul>\n</li>\n</ul>\n<p>返回值：返回一个<code>Promise对象</code></p>\n<p>Fetch引入了3个接口，它们分别是 <code>Headers</code>,<code>Request</code> 以及 <code>Response</code> 。</p>\n<h4 id=\"Headers\"><a href=\"#Headers\" class=\"headerlink\" title=\"Headers()\"></a>Headers()</h4><p>Headers()是一个可检索的多映射名值表，也可穿多维数组或者json</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reqHeaders = <span class=\"keyword\">new</span> Headers();</div><div class=\"line\">reqHeaders = <span class=\"keyword\">new</span> Headers(&#123;</div><div class=\"line\">  <span class=\"string\">\"Content-Length\"</span>: content.length.toString(),</div><div class=\"line\">&#125;);</div><div class=\"line\">reqHeaders.append(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/plain\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">\"Content-Type\"</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">\"Set-Cookie\"</span>)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>Headers()有一个<code>guard</code>属性来规定哪些参数是可写的。</p>\n<h4 id=\"Requset\"><a href=\"#Requset\" class=\"headerlink\" title=\"Requset()\"></a>Requset()</h4><p>语法，参数与fetch()类似：</p>\n<p><code>var myRequest = new Request(input, init);</code></p>\n<p>其中可选的init配置项比fetch()多了几项(redirect/integrity/referrer)</p>\n<h4 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response()\"></a>Response()</h4><p>在fetch()的回调中我们可以获得一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\" target=\"_blank\" rel=\"external\">Response实例</a>。Response有很多实用的只读属性，比如Response.ok/Response.type/Response.headers等等。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch\" target=\"_blank\" rel=\"external\">MDN: GlobalFetch 文档</a></li>\n<li><a href=\"https://jakearchibald.com/2015/thats-so-fetch/\" target=\"_blank\" rel=\"external\">Jake Archibald: That’s so fetch</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/\" target=\"_blank\" rel=\"external\">Hacks Mozilla: This API is so Fetching</a></li>\n<li><a href=\"https://github.com/camsong/blog/issues/2\" target=\"_blank\" rel=\"external\">camsong: 传统Ajax 已死，Fetch 永生</a></li>\n</ul>\n","excerpt":"<p>长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api <code>Fetch</code>来替换它。</p>\n<h3 id=\"XMLHttpRequest的缺陷\"><a href=\"#XMLHttpRequest的缺陷\" class=\"headerlink\" title=\"XMLHttpRequest的缺陷\"></a>XMLHttpRequest的缺陷</h3><p>先看一个典型的XHR例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">xhr.open(<span class=\"string\">'GET'</span>, url);</div><div class=\"line\">xhr.responseType = <span class=\"string\">'json'</span>;</div><div class=\"line\"></div><div class=\"line\">xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(xhr.response);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.send();</div></pre></td></tr></table></figure></p>\n<p>可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。</p>","more":"<h3 id=\"Fetch-Api的特点\"><a href=\"#Fetch-Api的特点\" class=\"headerlink\" title=\"Fetch Api的特点\"></a>Fetch Api的特点</h3><p>fetch api是基于<code>Promise</code>设计的，定义在BOM的<code>window</code>对象之中。建议阅读资料：</p>\n<ul>\n<li><a href=\"https://fetch.spec.whatwg.org/\">Fetch Living Standard</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch\">MDN: GlobalFetch 文档</a></li>\n<li><a href=\"http://caniuse.com/#search=fetch\">caniuse 浏览器支持率</a></li>\n</ul>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-18%20%E4%B8%8B%E5%8D%8810.03.45.png\" alt=\"caniuse-fetch\"></p>\n<p>截止到2016年8月，Chrome43+，Firefox47+支持fetch api，对于低版本的浏览器，github上有许多<a href=\"https://github.com/camsong/fetch-ie8\">polyfill</a>可以使其兼容。</p>\n<p>一个典型的fetch例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(url).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> response.json();</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>用ES6的箭头函数重构之后：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(url).then(r =&gt; r.json())</div><div class=\"line\">  .then(data =&gt; <span class=\"built_in\">console</span>.log(data))</div><div class=\"line\">  .catch(e =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>))</div></pre></td></tr></table></figure></p>\n<p>用还处于草案阶段的<a href=\"http://es6.ruanyifeng.com/#docs/async#async函数\">ES7的async函数</a>再重构一下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">async</span>() =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> response = <span class=\"keyword\">await</span> fetch(url);</div><div class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> response.json();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Booo\"</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>就可以把一个异步的请求代码结构写得看起来跟同步请求差不多了。</p>\n<p>由此可见，<code>Fetch</code>基于Promise实现，支持async/await，语法更简洁。</p>\n<h3 id=\"How-to-Use\"><a href=\"#How-to-Use\" class=\"headerlink\" title=\"How to Use\"></a>How to Use</h3><h4 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch()\"></a>fetch()</h4><p>语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(input, init).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123; ... &#125;);</div></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>input</code> :要获取的资源<ul>\n<li>字符串，资源的url</li>\n<li>一个<code>Request</code>对象（后面会介绍Request)</li>\n</ul>\n</li>\n<li><code>init</code> :可选，是请求的配置项<ul>\n<li>method: 请求方式，GET/POST/PUT/DELETE等等</li>\n<li>headers: 请求头，可能是<code>Headers 对象</code>或者 ByteString</li>\n<li>body: 请求的Body信息</li>\n<li>mode: 请求的模式，cors/no-cors/same-origin</li>\n<li>credentials: 请求的credentials，omit/same-origin/include</li>\n<li>cache: 请求的缓存模式， default/no-store/reload/ no-cache/force-cache/only-if-cached</li>\n</ul>\n</li>\n</ul>\n<p>返回值：返回一个<code>Promise对象</code></p>\n<p>Fetch引入了3个接口，它们分别是 <code>Headers</code>,<code>Request</code> 以及 <code>Response</code> 。</p>\n<h4 id=\"Headers\"><a href=\"#Headers\" class=\"headerlink\" title=\"Headers()\"></a>Headers()</h4><p>Headers()是一个可检索的多映射名值表，也可穿多维数组或者json</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reqHeaders = <span class=\"keyword\">new</span> Headers();</div><div class=\"line\">reqHeaders = <span class=\"keyword\">new</span> Headers(&#123;</div><div class=\"line\">  <span class=\"string\">\"Content-Length\"</span>: content.length.toString(),</div><div class=\"line\">&#125;);</div><div class=\"line\">reqHeaders.append(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/plain\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">\"Content-Type\"</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">\"Set-Cookie\"</span>)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>Headers()有一个<code>guard</code>属性来规定哪些参数是可写的。</p>\n<h4 id=\"Requset\"><a href=\"#Requset\" class=\"headerlink\" title=\"Requset()\"></a>Requset()</h4><p>语法，参数与fetch()类似：</p>\n<p><code>var myRequest = new Request(input, init);</code></p>\n<p>其中可选的init配置项比fetch()多了几项(redirect/integrity/referrer)</p>\n<h4 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response()\"></a>Response()</h4><p>在fetch()的回调中我们可以获得一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\">Response实例</a>。Response有很多实用的只读属性，比如Response.ok/Response.type/Response.headers等等。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch\">MDN: GlobalFetch 文档</a></li>\n<li><a href=\"https://jakearchibald.com/2015/thats-so-fetch/\">Jake Archibald: That’s so fetch</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/\">Hacks Mozilla: This API is so Fetching</a></li>\n<li><a href=\"https://github.com/camsong/blog/issues/2\">camsong: 传统Ajax 已死，Fetch 永生</a></li>\n</ul>"},{"layout":"post","title":"关于浏览器缓存","date":"2016-07-18T13:36:00.000Z","_content":"\n浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。\n\n浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置`meta标签`来实现。\n\n## 与缓存相关的首部字段\n\n![http首部字段](http://o7ts2uaks.bkt.clouddn.com/CACHE.png)\n\n<!--more-->\n\n![状态图](http://o7ts2uaks.bkt.clouddn.com/w704.jpg)\n### Pragma与Expires\n由上表可以看到，Pragma与Expires是http1.0中的内容，是早期的浏览器缓存策略，现在我们也会经常看到看到这两个字段，为的是http协议向下兼容。\nPragma属于通用首部字段，在请求和响应报文章都可以设置，一般要求Pragama指令设定在html文件中的`<meta>标签`\n\n`<meta http-equiv=\"Pragma\" content=\"no-cache\">`\n不过Pragma一般只有在设置于响应报文中时才会生效。\n\nExpires是响应头字段，用来启用缓存和规定缓存失效时间。Expires的值对应一个GMT时间，比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。\n\n如果在meta标签中设置expires只是能设置页面在IE浏览器中是否缓存（对页面资源无效）。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。需要注意的是，expires设置的缓存时间是相对服务器上时间而言的，如果客户端时间与服务器时间不一致，这个缓存也就没意义了。\n\n另外，同时设置Expires和Pragma的话，Pragma的优先级会更高。\n\n### Cache-Control\n\nCache-Control分别能在请求报文和响应报文中使用，来定义缓存有效时间，优先级高于Pragma与Expires。Cache-Control也修正了上述Expires时间差的问题。\n![cache-control可设置的值](http://ww3.sinaimg.cn/mw690/6941baebgw1eukzzwcvnij20gi089jvb.jpg)\n\n### Last-Modified\n\n浏览器第一次请求某URL时会返回200，内容是所请求的资源。服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。\n\n客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查“If-Modified-Since: GMT”，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可，内容为空，节省了传输数据量。\n\n### ETag\n\nHttp1.1中定义了实体首部字段`Etag`，即在服务器响应时给请求的URL做标记一个唯一标识符，在响应头中传给客户端。在下一次发请求时，客户端会带上Etag，服务器通过比较服务器上资源的Etag与客户端传过来的Etag来判断资源有没有被修改。若没被修改，则返回304.\n\n如果Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。\n\n## 缓存策略\n\n### Last-Modified和Etag → 304\n\n这两个字段经常在一起配合使用，来判断资源是否已被修改，确定读取本地缓存还是重新请求资源。ETag主要是用来解决Last-Modified无法解决的问题（文件修改频繁，服务器得到的时间不精确等等）。\n\n这两个字段的特点及应用场景在于，本地已有缓存，但是它们需要向服务器发送请求来确定本地缓存是否是最新的，若服务器认为本地缓存是最新的，可用，则返回304\n\n### Expires/Cache-Control → 200\n\n区别于304状态码，200意味着不向服务器发请求，直接启用本地缓存。即Expires/Cache-Control字段通过绝对时间/相对时间判断出本地缓存是有效的。\n\n思维导图如下（自己画的感觉很不美观 = =）\n\n![思维导图](http://o7ts2uaks.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%20%281%29.png)\n\n## 用户行为与缓存\n\n浏览器缓存也与用户行为有关，在地址栏按回车与直接F5是不一样的。\n\n![用户行为](http://ww4.sinaimg.cn/mw690/6941baebgw1eukzzr7rc2j20hg04kjsd.jpg)\n\n由图可知，当用户按F5进行刷新，Expires/Cache-Control会失效，浏览器将再次发送请求通过Last-Modified/ETag来判断缓存是否有效。当用户通过Ctrl+F5进行强制刷新时，所有字段都会失效，浏览器将重新请求获取资源。\n\n### 参考内容\n* [w3:HTTP1.1](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n* [vajoy:浅谈浏览器http的缓存机制](http://www.cnblogs.com/vajoy/p/5341664.html)\n* [鸟哥:浏览器缓存机制](http://www.laruence.com/2010/03/05/1332.html)\n* [eroswang:浏览器缓存详解](http://blog.csdn.net/eroswang/article/details/8302191)\n\n\n","source":"_posts/browser-cache-summary.md","raw":"---\nlayout: post\ntitle:  \"关于浏览器缓存\"\ndate:   2016-07-18 21:36\ncategories: http\n---\n\n浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。\n\n浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置`meta标签`来实现。\n\n## 与缓存相关的首部字段\n\n![http首部字段](http://o7ts2uaks.bkt.clouddn.com/CACHE.png)\n\n<!--more-->\n\n![状态图](http://o7ts2uaks.bkt.clouddn.com/w704.jpg)\n### Pragma与Expires\n由上表可以看到，Pragma与Expires是http1.0中的内容，是早期的浏览器缓存策略，现在我们也会经常看到看到这两个字段，为的是http协议向下兼容。\nPragma属于通用首部字段，在请求和响应报文章都可以设置，一般要求Pragama指令设定在html文件中的`<meta>标签`\n\n`<meta http-equiv=\"Pragma\" content=\"no-cache\">`\n不过Pragma一般只有在设置于响应报文中时才会生效。\n\nExpires是响应头字段，用来启用缓存和规定缓存失效时间。Expires的值对应一个GMT时间，比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。\n\n如果在meta标签中设置expires只是能设置页面在IE浏览器中是否缓存（对页面资源无效）。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。需要注意的是，expires设置的缓存时间是相对服务器上时间而言的，如果客户端时间与服务器时间不一致，这个缓存也就没意义了。\n\n另外，同时设置Expires和Pragma的话，Pragma的优先级会更高。\n\n### Cache-Control\n\nCache-Control分别能在请求报文和响应报文中使用，来定义缓存有效时间，优先级高于Pragma与Expires。Cache-Control也修正了上述Expires时间差的问题。\n![cache-control可设置的值](http://ww3.sinaimg.cn/mw690/6941baebgw1eukzzwcvnij20gi089jvb.jpg)\n\n### Last-Modified\n\n浏览器第一次请求某URL时会返回200，内容是所请求的资源。服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。\n\n客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查“If-Modified-Since: GMT”，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可，内容为空，节省了传输数据量。\n\n### ETag\n\nHttp1.1中定义了实体首部字段`Etag`，即在服务器响应时给请求的URL做标记一个唯一标识符，在响应头中传给客户端。在下一次发请求时，客户端会带上Etag，服务器通过比较服务器上资源的Etag与客户端传过来的Etag来判断资源有没有被修改。若没被修改，则返回304.\n\n如果Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。\n\n## 缓存策略\n\n### Last-Modified和Etag → 304\n\n这两个字段经常在一起配合使用，来判断资源是否已被修改，确定读取本地缓存还是重新请求资源。ETag主要是用来解决Last-Modified无法解决的问题（文件修改频繁，服务器得到的时间不精确等等）。\n\n这两个字段的特点及应用场景在于，本地已有缓存，但是它们需要向服务器发送请求来确定本地缓存是否是最新的，若服务器认为本地缓存是最新的，可用，则返回304\n\n### Expires/Cache-Control → 200\n\n区别于304状态码，200意味着不向服务器发请求，直接启用本地缓存。即Expires/Cache-Control字段通过绝对时间/相对时间判断出本地缓存是有效的。\n\n思维导图如下（自己画的感觉很不美观 = =）\n\n![思维导图](http://o7ts2uaks.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%20%281%29.png)\n\n## 用户行为与缓存\n\n浏览器缓存也与用户行为有关，在地址栏按回车与直接F5是不一样的。\n\n![用户行为](http://ww4.sinaimg.cn/mw690/6941baebgw1eukzzr7rc2j20hg04kjsd.jpg)\n\n由图可知，当用户按F5进行刷新，Expires/Cache-Control会失效，浏览器将再次发送请求通过Last-Modified/ETag来判断缓存是否有效。当用户通过Ctrl+F5进行强制刷新时，所有字段都会失效，浏览器将重新请求获取资源。\n\n### 参考内容\n* [w3:HTTP1.1](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n* [vajoy:浅谈浏览器http的缓存机制](http://www.cnblogs.com/vajoy/p/5341664.html)\n* [鸟哥:浏览器缓存机制](http://www.laruence.com/2010/03/05/1332.html)\n* [eroswang:浏览器缓存详解](http://blog.csdn.net/eroswang/article/details/8302191)\n\n\n","slug":"browser-cache-summary","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyig0006gbeh35200ek7","content":"<p>浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。</p>\n<p>浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置<code>meta标签</code>来实现。</p>\n<h2 id=\"与缓存相关的首部字段\"><a href=\"#与缓存相关的首部字段\" class=\"headerlink\" title=\"与缓存相关的首部字段\"></a>与缓存相关的首部字段</h2><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/CACHE.png\" alt=\"http首部字段\"></p>\n<a id=\"more\"></a>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/w704.jpg\" alt=\"状态图\"></p>\n<h3 id=\"Pragma与Expires\"><a href=\"#Pragma与Expires\" class=\"headerlink\" title=\"Pragma与Expires\"></a>Pragma与Expires</h3><p>由上表可以看到，Pragma与Expires是http1.0中的内容，是早期的浏览器缓存策略，现在我们也会经常看到看到这两个字段，为的是http协议向下兼容。<br>Pragma属于通用首部字段，在请求和响应报文章都可以设置，一般要求Pragama指令设定在html文件中的<code>&lt;meta&gt;标签</code></p>\n<p><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</code><br>不过Pragma一般只有在设置于响应报文中时才会生效。</p>\n<p>Expires是响应头字段，用来启用缓存和规定缓存失效时间。Expires的值对应一个GMT时间，比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。</p>\n<p>如果在meta标签中设置expires只是能设置页面在IE浏览器中是否缓存（对页面资源无效）。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。需要注意的是，expires设置的缓存时间是相对服务器上时间而言的，如果客户端时间与服务器时间不一致，这个缓存也就没意义了。</p>\n<p>另外，同时设置Expires和Pragma的话，Pragma的优先级会更高。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><p>Cache-Control分别能在请求报文和响应报文中使用，来定义缓存有效时间，优先级高于Pragma与Expires。Cache-Control也修正了上述Expires时间差的问题。<br><img src=\"http://ww3.sinaimg.cn/mw690/6941baebgw1eukzzwcvnij20gi089jvb.jpg\" alt=\"cache-control可设置的值\"></p>\n<h3 id=\"Last-Modified\"><a href=\"#Last-Modified\" class=\"headerlink\" title=\"Last-Modified\"></a>Last-Modified</h3><p>浏览器第一次请求某URL时会返回200，内容是所请求的资源。服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p>\n<p>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查“If-Modified-Since: GMT”，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可，内容为空，节省了传输数据量。</p>\n<h3 id=\"ETag\"><a href=\"#ETag\" class=\"headerlink\" title=\"ETag\"></a>ETag</h3><p>Http1.1中定义了实体首部字段<code>Etag</code>，即在服务器响应时给请求的URL做标记一个唯一标识符，在响应头中传给客户端。在下一次发请求时，客户端会带上Etag，服务器通过比较服务器上资源的Etag与客户端传过来的Etag来判断资源有没有被修改。若没被修改，则返回304.</p>\n<p>如果Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。</p>\n<h2 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h2><h3 id=\"Last-Modified和Etag-→-304\"><a href=\"#Last-Modified和Etag-→-304\" class=\"headerlink\" title=\"Last-Modified和Etag → 304\"></a>Last-Modified和Etag → 304</h3><p>这两个字段经常在一起配合使用，来判断资源是否已被修改，确定读取本地缓存还是重新请求资源。ETag主要是用来解决Last-Modified无法解决的问题（文件修改频繁，服务器得到的时间不精确等等）。</p>\n<p>这两个字段的特点及应用场景在于，本地已有缓存，但是它们需要向服务器发送请求来确定本地缓存是否是最新的，若服务器认为本地缓存是最新的，可用，则返回304</p>\n<h3 id=\"Expires-Cache-Control-→-200\"><a href=\"#Expires-Cache-Control-→-200\" class=\"headerlink\" title=\"Expires/Cache-Control → 200\"></a>Expires/Cache-Control → 200</h3><p>区别于304状态码，200意味着不向服务器发请求，直接启用本地缓存。即Expires/Cache-Control字段通过绝对时间/相对时间判断出本地缓存是有效的。</p>\n<p>思维导图如下（自己画的感觉很不美观 = =）</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%20%281%29.png\" alt=\"思维导图\"></p>\n<h2 id=\"用户行为与缓存\"><a href=\"#用户行为与缓存\" class=\"headerlink\" title=\"用户行为与缓存\"></a>用户行为与缓存</h2><p>浏览器缓存也与用户行为有关，在地址栏按回车与直接F5是不一样的。</p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/6941baebgw1eukzzr7rc2j20hg04kjsd.jpg\" alt=\"用户行为\"></p>\n<p>由图可知，当用户按F5进行刷新，Expires/Cache-Control会失效，浏览器将再次发送请求通过Last-Modified/ETag来判断缓存是否有效。当用户通过Ctrl+F5进行强制刷新时，所有字段都会失效，浏览器将重新请求获取资源。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"external\">w3:HTTP1.1</a></li>\n<li><a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"external\">vajoy:浅谈浏览器http的缓存机制</a></li>\n<li><a href=\"http://www.laruence.com/2010/03/05/1332.html\" target=\"_blank\" rel=\"external\">鸟哥:浏览器缓存机制</a></li>\n<li><a href=\"http://blog.csdn.net/eroswang/article/details/8302191\" target=\"_blank\" rel=\"external\">eroswang:浏览器缓存详解</a></li>\n</ul>\n","excerpt":"<p>浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。</p>\n<p>浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置<code>meta标签</code>来实现。</p>\n<h2 id=\"与缓存相关的首部字段\"><a href=\"#与缓存相关的首部字段\" class=\"headerlink\" title=\"与缓存相关的首部字段\"></a>与缓存相关的首部字段</h2><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/CACHE.png\" alt=\"http首部字段\"></p>","more":"<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/w704.jpg\" alt=\"状态图\"></p>\n<h3 id=\"Pragma与Expires\"><a href=\"#Pragma与Expires\" class=\"headerlink\" title=\"Pragma与Expires\"></a>Pragma与Expires</h3><p>由上表可以看到，Pragma与Expires是http1.0中的内容，是早期的浏览器缓存策略，现在我们也会经常看到看到这两个字段，为的是http协议向下兼容。<br>Pragma属于通用首部字段，在请求和响应报文章都可以设置，一般要求Pragama指令设定在html文件中的<code>&lt;meta&gt;标签</code></p>\n<p><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</code><br>不过Pragma一般只有在设置于响应报文中时才会生效。</p>\n<p>Expires是响应头字段，用来启用缓存和规定缓存失效时间。Expires的值对应一个GMT时间，比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。</p>\n<p>如果在meta标签中设置expires只是能设置页面在IE浏览器中是否缓存（对页面资源无效）。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。需要注意的是，expires设置的缓存时间是相对服务器上时间而言的，如果客户端时间与服务器时间不一致，这个缓存也就没意义了。</p>\n<p>另外，同时设置Expires和Pragma的话，Pragma的优先级会更高。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><p>Cache-Control分别能在请求报文和响应报文中使用，来定义缓存有效时间，优先级高于Pragma与Expires。Cache-Control也修正了上述Expires时间差的问题。<br><img src=\"http://ww3.sinaimg.cn/mw690/6941baebgw1eukzzwcvnij20gi089jvb.jpg\" alt=\"cache-control可设置的值\"></p>\n<h3 id=\"Last-Modified\"><a href=\"#Last-Modified\" class=\"headerlink\" title=\"Last-Modified\"></a>Last-Modified</h3><p>浏览器第一次请求某URL时会返回200，内容是所请求的资源。服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p>\n<p>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查“If-Modified-Since: GMT”，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可，内容为空，节省了传输数据量。</p>\n<h3 id=\"ETag\"><a href=\"#ETag\" class=\"headerlink\" title=\"ETag\"></a>ETag</h3><p>Http1.1中定义了实体首部字段<code>Etag</code>，即在服务器响应时给请求的URL做标记一个唯一标识符，在响应头中传给客户端。在下一次发请求时，客户端会带上Etag，服务器通过比较服务器上资源的Etag与客户端传过来的Etag来判断资源有没有被修改。若没被修改，则返回304.</p>\n<p>如果Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。</p>\n<h2 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h2><h3 id=\"Last-Modified和Etag-→-304\"><a href=\"#Last-Modified和Etag-→-304\" class=\"headerlink\" title=\"Last-Modified和Etag → 304\"></a>Last-Modified和Etag → 304</h3><p>这两个字段经常在一起配合使用，来判断资源是否已被修改，确定读取本地缓存还是重新请求资源。ETag主要是用来解决Last-Modified无法解决的问题（文件修改频繁，服务器得到的时间不精确等等）。</p>\n<p>这两个字段的特点及应用场景在于，本地已有缓存，但是它们需要向服务器发送请求来确定本地缓存是否是最新的，若服务器认为本地缓存是最新的，可用，则返回304</p>\n<h3 id=\"Expires-Cache-Control-→-200\"><a href=\"#Expires-Cache-Control-→-200\" class=\"headerlink\" title=\"Expires/Cache-Control → 200\"></a>Expires/Cache-Control → 200</h3><p>区别于304状态码，200意味着不向服务器发请求，直接启用本地缓存。即Expires/Cache-Control字段通过绝对时间/相对时间判断出本地缓存是有效的。</p>\n<p>思维导图如下（自己画的感觉很不美观 = =）</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%20%281%29.png\" alt=\"思维导图\"></p>\n<h2 id=\"用户行为与缓存\"><a href=\"#用户行为与缓存\" class=\"headerlink\" title=\"用户行为与缓存\"></a>用户行为与缓存</h2><p>浏览器缓存也与用户行为有关，在地址栏按回车与直接F5是不一样的。</p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/6941baebgw1eukzzr7rc2j20hg04kjsd.jpg\" alt=\"用户行为\"></p>\n<p>由图可知，当用户按F5进行刷新，Expires/Cache-Control会失效，浏览器将再次发送请求通过Last-Modified/ETag来判断缓存是否有效。当用户通过Ctrl+F5进行强制刷新时，所有字段都会失效，浏览器将重新请求获取资源。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">w3:HTTP1.1</a></li>\n<li><a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\">vajoy:浅谈浏览器http的缓存机制</a></li>\n<li><a href=\"http://www.laruence.com/2010/03/05/1332.html\">鸟哥:浏览器缓存机制</a></li>\n<li><a href=\"http://blog.csdn.net/eroswang/article/details/8302191\">eroswang:浏览器缓存详解</a></li>\n</ul>"},{"layout":"post","title":"由匿名函数展开的一系列知识点","date":"2016-11-23T14:00:00.000Z","_content":"\n![cover](/images/iife.png)\n\n### 起因\n最近在进行 [underscore.js 源码分析](https://github.com/MechanicianW/underscore-analysis)，也顺便看了些别的库的大致封装方式\nunderscore:\n\n```javascript\n(function() {\n  var root = this;\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n  // blabla\n}());\n```\n\n<!--more-->\n\n早期的 jQuery:\n\n```javascript\n(function( window, undefined ) {\nvar jQuery = (function() {console.log('hello');});\nwindow.jQuery = window.$ = jQuery;\nif ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n    define( \"jquery\", [], function () { return jQuery; } );\n}\n// blabla\n})( window );\n```\n\n这个封装和调用方式一看就是匿名函数嘛，可是匿名函数，然后呢？\n于是趁着下午比较闲翻开高程从匿名函数这个地方开始看，发现了一系列的知识点......\n大概脉络是: 函数定义方式 → 匿名函数的创建 → 匿名函数自执行还是IIFE？ → IIFE 的应用\n\n### 函数定义方式\n\n1. 函数声明     \n  ```\n  function foo () {}\n  ```\n  **函数声明提升** ：可以把函数声明放在调用它的语句后面\n\n2. 函数表达式\n  ```\n  var foo = function () {}\n  ```\n  也属于匿名函数\n\n3. 使用Function构造函数\n  ```\n  var foo = new Function ()\n  ```\n\n### 匿名函数的创建\n\n1. 上述 使用函数表达式创建\n\n2. `(function (x, y) {alert(x + y)})(2, 3)`\n  在第一个括号内创建匿名函数，第二个括号用于调用该匿名函数，并传入参数\n   - `function (x,y) {alert(x + y)}`部分为所声明的函数\n   - 然后用括号把函数声明包起来 `(function (x,y) {alert(x + y)})`\n   - 最后调用此函数 `(function (x, y) {alert(x + y)})(2, 3)`\n\n> 在这里我们也可以看到，创建匿名函数的方式有两种，第二种方式才会声明后立即执行，即不是所有的匿名函数都是可以立即执行的\n\n### “匿名函数自执行” vs  IIFE\n\n自执行，有的地方会写为自调用，是一个经常会听到的的概念，我们再深究一下它吧。所谓的“匿名函数自执行”指的是 `Self-executing anonymous function` ，经常与 `IIFE` 混淆， `Immediately-Invoked Function Expression` 即 **立即调用的函数表达式** ，含义上的辨析 [先戳一下中文wiki](https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F) 吧。\n\nIIFE 的具体的例子：\n\n```\n// 第一个例子\n(function (x) { return x + 1;}(2)) // => 3\n// 第二个例子\nvar result = function (x) { return x + 1; }(2); // => result 的值为3\n```\n\n把第一个例子敲到控制台中，我们可以看到这个 `()` 中的代码立即执行了，返回3。对于第二个例子，它实际上执行的是：\n\n```\nvar foo = function (x) {return x + 1;}\nvar result = foo(2)\n```\n\n这里有一个知识点： **对于函数类对象，不论是一个现场定义的匿名函数，还是一个之前定义的有名字的函数，它们在不加括号的时候都代表了这个函数对象本身，而加了括号就代表调用这个函数，也就是这个函数 return 的对象。**\n\n再回到匿名函数自执行与 IIFE 的辨析上，匿名函数自执行(Self-executing anonymous function)是一个不够准确的概念：\n\n```\n// 它是一个自执行的匿名函数，它必须用 arguments.callee() 来递归地调用自己\nvar foo = function() { arguments.callee(); };\n// 它是一个立即执行的匿名函数，只是立即执行了一段 code ，并不是调用自己\n(function () { /* code */ } ());\n```\n\n因此 `自执行` 意味着调用自己， `立即调用，立即执行` 强调的是定义函数的时候就直接执行了函数，与函数体内是否调用自身无关。只能说这是两个看起来有些类似的概念，但实际上所强调的内容完全不一样。IIFE 也可以调用自己，匿名函数可以立即执行。\n\n### IIFE 的应用\n\n立即调用的函数表达式的根本作用是 **创建一个独立的作用域**。\n\n1. 模拟块级作用域，在ES6之前 JavaScript 是没有块级作用域的。\n  在实际应用场景中，项目引用了很多不同的库 ，库与库之间是如何保证变量不被覆盖呢？\n\n  ```javascript\n  // libA.js\n  (function(){\n    var num = 1;\n  \t// blabla\n  })();\n\n\n  // libB.js\n  (function(){\n  \tvar num = 2;\n  \t// blabla\n  })();\n  ```\n\n  这样的话，就如同我们在前面看到的 jquery underscore 那样，使自身作用域独立，不会互相覆盖。\n\n2. 解决闭包的坑： **闭包只能取得包含函数中任何变量的最后一个值**\n  这次改造一下《高程三》中提到的例子作为参照吧：\n\n  ```javascript\n  function test () {\n    var result = new Array();\n    var foo = null;\n    for (var i = 0; i < 10; i++) {\n  \t  foo = function () {\n        console.log(i)\n      }\n      result.push(foo)\n    };\n    return result\n  }\n\n  var res = test()\n  for (var i =0,len = res.length; i < len; i++){\n    res[i]()\n  }\n  // 控制台中打出来的是10个10，而不是1，2，3...\n  // i 是贯穿整个作用域的，而不是给每个 foo 分配了一个 i\n  // test()执行完毕后才调用 console.log() 一定是发生在for循环已循环结束后，此时i值为10\n  ```\n\n  在线例子可以戳 [JSFiddle](https://jsfiddle.net/46x5s72a/)\n  这个坑该怎么处理呢？引入IIFE！下面代码是可用的，把 i 的值作为索引锁住了\n\n  ```javascript\n  // 解决思路是给每个foo函数创建一个独立的作用域\n  function test () {\n    var result = new Array();\n    var foo = null;\n    for (var i = 0; i < 10; i++) {\n      // 添加一个IIFE\n  \t  (function(index) {\n  \t    foo = function() {console.log(index);};\n        result.push(foo)\n  \t   })(i);\n      };\n      return result\n    }\n\n    var res = test()\n    for (var i =0,len = res.length; i < len; i++){\n      res[i]()\n    }\n  ```\n\n  ### 参考内容\n  * [汤姆大叔的博客:深入理解JavaScript系列（4）: 立即调用的函数表达式](http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html)\n  * [stackoverflow: What is the purpose of a self executing function in javascript](http://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript)\n  * [weizhifeng.net: JavaScript中的立即执行函数表达式](http://weizhifeng.net/immediately-invoked-function-expression.html)\n","source":"_posts/basic-review-from-anonymous-function-to-iife.md","raw":"---\nlayout: post\ntitle:  \"由匿名函数展开的一系列知识点\"\ndate:   2016-11-23 22:00\ncategories: front-end javascript\n---\n\n![cover](/images/iife.png)\n\n### 起因\n最近在进行 [underscore.js 源码分析](https://github.com/MechanicianW/underscore-analysis)，也顺便看了些别的库的大致封装方式\nunderscore:\n\n```javascript\n(function() {\n  var root = this;\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n  // blabla\n}());\n```\n\n<!--more-->\n\n早期的 jQuery:\n\n```javascript\n(function( window, undefined ) {\nvar jQuery = (function() {console.log('hello');});\nwindow.jQuery = window.$ = jQuery;\nif ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n    define( \"jquery\", [], function () { return jQuery; } );\n}\n// blabla\n})( window );\n```\n\n这个封装和调用方式一看就是匿名函数嘛，可是匿名函数，然后呢？\n于是趁着下午比较闲翻开高程从匿名函数这个地方开始看，发现了一系列的知识点......\n大概脉络是: 函数定义方式 → 匿名函数的创建 → 匿名函数自执行还是IIFE？ → IIFE 的应用\n\n### 函数定义方式\n\n1. 函数声明     \n  ```\n  function foo () {}\n  ```\n  **函数声明提升** ：可以把函数声明放在调用它的语句后面\n\n2. 函数表达式\n  ```\n  var foo = function () {}\n  ```\n  也属于匿名函数\n\n3. 使用Function构造函数\n  ```\n  var foo = new Function ()\n  ```\n\n### 匿名函数的创建\n\n1. 上述 使用函数表达式创建\n\n2. `(function (x, y) {alert(x + y)})(2, 3)`\n  在第一个括号内创建匿名函数，第二个括号用于调用该匿名函数，并传入参数\n   - `function (x,y) {alert(x + y)}`部分为所声明的函数\n   - 然后用括号把函数声明包起来 `(function (x,y) {alert(x + y)})`\n   - 最后调用此函数 `(function (x, y) {alert(x + y)})(2, 3)`\n\n> 在这里我们也可以看到，创建匿名函数的方式有两种，第二种方式才会声明后立即执行，即不是所有的匿名函数都是可以立即执行的\n\n### “匿名函数自执行” vs  IIFE\n\n自执行，有的地方会写为自调用，是一个经常会听到的的概念，我们再深究一下它吧。所谓的“匿名函数自执行”指的是 `Self-executing anonymous function` ，经常与 `IIFE` 混淆， `Immediately-Invoked Function Expression` 即 **立即调用的函数表达式** ，含义上的辨析 [先戳一下中文wiki](https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F) 吧。\n\nIIFE 的具体的例子：\n\n```\n// 第一个例子\n(function (x) { return x + 1;}(2)) // => 3\n// 第二个例子\nvar result = function (x) { return x + 1; }(2); // => result 的值为3\n```\n\n把第一个例子敲到控制台中，我们可以看到这个 `()` 中的代码立即执行了，返回3。对于第二个例子，它实际上执行的是：\n\n```\nvar foo = function (x) {return x + 1;}\nvar result = foo(2)\n```\n\n这里有一个知识点： **对于函数类对象，不论是一个现场定义的匿名函数，还是一个之前定义的有名字的函数，它们在不加括号的时候都代表了这个函数对象本身，而加了括号就代表调用这个函数，也就是这个函数 return 的对象。**\n\n再回到匿名函数自执行与 IIFE 的辨析上，匿名函数自执行(Self-executing anonymous function)是一个不够准确的概念：\n\n```\n// 它是一个自执行的匿名函数，它必须用 arguments.callee() 来递归地调用自己\nvar foo = function() { arguments.callee(); };\n// 它是一个立即执行的匿名函数，只是立即执行了一段 code ，并不是调用自己\n(function () { /* code */ } ());\n```\n\n因此 `自执行` 意味着调用自己， `立即调用，立即执行` 强调的是定义函数的时候就直接执行了函数，与函数体内是否调用自身无关。只能说这是两个看起来有些类似的概念，但实际上所强调的内容完全不一样。IIFE 也可以调用自己，匿名函数可以立即执行。\n\n### IIFE 的应用\n\n立即调用的函数表达式的根本作用是 **创建一个独立的作用域**。\n\n1. 模拟块级作用域，在ES6之前 JavaScript 是没有块级作用域的。\n  在实际应用场景中，项目引用了很多不同的库 ，库与库之间是如何保证变量不被覆盖呢？\n\n  ```javascript\n  // libA.js\n  (function(){\n    var num = 1;\n  \t// blabla\n  })();\n\n\n  // libB.js\n  (function(){\n  \tvar num = 2;\n  \t// blabla\n  })();\n  ```\n\n  这样的话，就如同我们在前面看到的 jquery underscore 那样，使自身作用域独立，不会互相覆盖。\n\n2. 解决闭包的坑： **闭包只能取得包含函数中任何变量的最后一个值**\n  这次改造一下《高程三》中提到的例子作为参照吧：\n\n  ```javascript\n  function test () {\n    var result = new Array();\n    var foo = null;\n    for (var i = 0; i < 10; i++) {\n  \t  foo = function () {\n        console.log(i)\n      }\n      result.push(foo)\n    };\n    return result\n  }\n\n  var res = test()\n  for (var i =0,len = res.length; i < len; i++){\n    res[i]()\n  }\n  // 控制台中打出来的是10个10，而不是1，2，3...\n  // i 是贯穿整个作用域的，而不是给每个 foo 分配了一个 i\n  // test()执行完毕后才调用 console.log() 一定是发生在for循环已循环结束后，此时i值为10\n  ```\n\n  在线例子可以戳 [JSFiddle](https://jsfiddle.net/46x5s72a/)\n  这个坑该怎么处理呢？引入IIFE！下面代码是可用的，把 i 的值作为索引锁住了\n\n  ```javascript\n  // 解决思路是给每个foo函数创建一个独立的作用域\n  function test () {\n    var result = new Array();\n    var foo = null;\n    for (var i = 0; i < 10; i++) {\n      // 添加一个IIFE\n  \t  (function(index) {\n  \t    foo = function() {console.log(index);};\n        result.push(foo)\n  \t   })(i);\n      };\n      return result\n    }\n\n    var res = test()\n    for (var i =0,len = res.length; i < len; i++){\n      res[i]()\n    }\n  ```\n\n  ### 参考内容\n  * [汤姆大叔的博客:深入理解JavaScript系列（4）: 立即调用的函数表达式](http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html)\n  * [stackoverflow: What is the purpose of a self executing function in javascript](http://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript)\n  * [weizhifeng.net: JavaScript中的立即执行函数表达式](http://weizhifeng.net/immediately-invoked-function-expression.html)\n","slug":"basic-review-from-anonymous-function-to-iife","published":1,"updated":"2017-11-19T06:50:35.000Z","_id":"cja54xyii0007gbehic4gndcd","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/iife.png\" alt=\"cover\"></p>\n<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>最近在进行 <a href=\"https://github.com/MechanicianW/underscore-analysis\" target=\"_blank\" rel=\"external\">underscore.js 源码分析</a>，也顺便看了些别的库的大致封装方式<br>underscore:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> root = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> _) <span class=\"keyword\">return</span> obj;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> _)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _(obj);</div><div class=\"line\">    <span class=\"keyword\">this</span>._wrapped = obj;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>早期的 jQuery:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window, undefined </span>) </span>&#123;</div><div class=\"line\"><span class=\"keyword\">var</span> jQuery = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);&#125;);</div><div class=\"line\"><span class=\"built_in\">window</span>.jQuery = <span class=\"built_in\">window</span>.$ = jQuery;</div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd &amp;&amp; define.amd.jQuery ) &#123;</div><div class=\"line\">    define( <span class=\"string\">\"jquery\"</span>, [], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> jQuery; &#125; );</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;)( <span class=\"built_in\">window</span> );</div></pre></td></tr></table></figure>\n<p>这个封装和调用方式一看就是匿名函数嘛，可是匿名函数，然后呢？<br>于是趁着下午比较闲翻开高程从匿名函数这个地方开始看，发现了一系列的知识点……<br>大概脉络是: 函数定义方式 → 匿名函数的创建 → 匿名函数自执行还是IIFE？ → IIFE 的应用</p>\n<h3 id=\"函数定义方式\"><a href=\"#函数定义方式\" class=\"headerlink\" title=\"函数定义方式\"></a>函数定义方式</h3><ol>\n<li><p>函数声明     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo () &#123;&#125;</div></pre></td></tr></table></figure>\n<p><strong>函数声明提升</strong> ：可以把函数声明放在调用它的语句后面</p>\n</li>\n<li><p>函数表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function () &#123;&#125;</div></pre></td></tr></table></figure>\n<p>也属于匿名函数</p>\n</li>\n<li><p>使用Function构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = new Function ()</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"匿名函数的创建\"><a href=\"#匿名函数的创建\" class=\"headerlink\" title=\"匿名函数的创建\"></a>匿名函数的创建</h3><ol>\n<li><p>上述 使用函数表达式创建</p>\n</li>\n<li><p><code>(function (x, y) {alert(x + y)})(2, 3)</code><br>在第一个括号内创建匿名函数，第二个括号用于调用该匿名函数，并传入参数</p>\n<ul>\n<li><code>function (x,y) {alert(x + y)}</code>部分为所声明的函数</li>\n<li>然后用括号把函数声明包起来 <code>(function (x,y) {alert(x + y)})</code></li>\n<li>最后调用此函数 <code>(function (x, y) {alert(x + y)})(2, 3)</code></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>在这里我们也可以看到，创建匿名函数的方式有两种，第二种方式才会声明后立即执行，即不是所有的匿名函数都是可以立即执行的</p>\n</blockquote>\n<h3 id=\"“匿名函数自执行”-vs-IIFE\"><a href=\"#“匿名函数自执行”-vs-IIFE\" class=\"headerlink\" title=\"“匿名函数自执行” vs  IIFE\"></a>“匿名函数自执行” vs  IIFE</h3><p>自执行，有的地方会写为自调用，是一个经常会听到的的概念，我们再深究一下它吧。所谓的“匿名函数自执行”指的是 <code>Self-executing anonymous function</code> ，经常与 <code>IIFE</code> 混淆， <code>Immediately-Invoked Function Expression</code> 即 <strong>立即调用的函数表达式</strong> ，含义上的辨析 <a href=\"https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F\" target=\"_blank\" rel=\"external\">先戳一下中文wiki</a> 吧。</p>\n<p>IIFE 的具体的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一个例子</div><div class=\"line\">(function (x) &#123; return x + 1;&#125;(2)) // =&gt; 3</div><div class=\"line\">// 第二个例子</div><div class=\"line\">var result = function (x) &#123; return x + 1; &#125;(2); // =&gt; result 的值为3</div></pre></td></tr></table></figure>\n<p>把第一个例子敲到控制台中，我们可以看到这个 <code>()</code> 中的代码立即执行了，返回3。对于第二个例子，它实际上执行的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function (x) &#123;return x + 1;&#125;</div><div class=\"line\">var result = foo(2)</div></pre></td></tr></table></figure>\n<p>这里有一个知识点： <strong>对于函数类对象，不论是一个现场定义的匿名函数，还是一个之前定义的有名字的函数，它们在不加括号的时候都代表了这个函数对象本身，而加了括号就代表调用这个函数，也就是这个函数 return 的对象。</strong></p>\n<p>再回到匿名函数自执行与 IIFE 的辨析上，匿名函数自执行(Self-executing anonymous function)是一个不够准确的概念：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 它是一个自执行的匿名函数，它必须用 arguments.callee() 来递归地调用自己</div><div class=\"line\">var foo = function() &#123; arguments.callee(); &#125;;</div><div class=\"line\">// 它是一个立即执行的匿名函数，只是立即执行了一段 code ，并不是调用自己</div><div class=\"line\">(function () &#123; /* code */ &#125; ());</div></pre></td></tr></table></figure>\n<p>因此 <code>自执行</code> 意味着调用自己， <code>立即调用，立即执行</code> 强调的是定义函数的时候就直接执行了函数，与函数体内是否调用自身无关。只能说这是两个看起来有些类似的概念，但实际上所强调的内容完全不一样。IIFE 也可以调用自己，匿名函数可以立即执行。</p>\n<h3 id=\"IIFE-的应用\"><a href=\"#IIFE-的应用\" class=\"headerlink\" title=\"IIFE 的应用\"></a>IIFE 的应用</h3><p>立即调用的函数表达式的根本作用是 <strong>创建一个独立的作用域</strong>。</p>\n<ol>\n<li><p>模拟块级作用域，在ES6之前 JavaScript 是没有块级作用域的。<br>在实际应用场景中，项目引用了很多不同的库 ，库与库之间是如何保证变量不被覆盖呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// libA.js</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> num = <span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// libB.js</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">2</span>;</div><div class=\"line\">\t<span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这样的话，就如同我们在前面看到的 jquery underscore 那样，使自身作用域独立，不会互相覆盖。</p>\n</li>\n<li><p>解决闭包的坑： <strong>闭包只能取得包含函数中任何变量的最后一个值</strong><br>这次改造一下《高程三》中提到的例子作为参照吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">  <span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">\t  foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(i)</div><div class=\"line\">    &#125;</div><div class=\"line\">    result.push(foo)</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> result</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> res = test()</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>,len = res.length; i &lt; len; i++)&#123;</div><div class=\"line\">  res[i]()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 控制台中打出来的是10个10，而不是1，2，3...</span></div><div class=\"line\"><span class=\"comment\">// i 是贯穿整个作用域的，而不是给每个 foo 分配了一个 i</span></div><div class=\"line\"><span class=\"comment\">// test()执行完毕后才调用 console.log() 一定是发生在for循环已循环结束后，此时i值为10</span></div></pre></td></tr></table></figure>\n<p>在线例子可以戳 <a href=\"https://jsfiddle.net/46x5s72a/\" target=\"_blank\" rel=\"external\">JSFiddle</a><br>这个坑该怎么处理呢？引入IIFE！下面代码是可用的，把 i 的值作为索引锁住了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 解决思路是给每个foo函数创建一个独立的作用域</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">  <span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">    <span class=\"comment\">// 添加一个IIFE</span></div><div class=\"line\">\t  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">\t    foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(index);&#125;;</div><div class=\"line\">      result.push(foo)</div><div class=\"line\">\t   &#125;)(i);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">return</span> result</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> res = test()</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>,len = res.length; i &lt; len; i++)&#123;</div><div class=\"line\">    res[i]()</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html\" target=\"_blank\" rel=\"external\">汤姆大叔的博客:深入理解JavaScript系列（4）: 立即调用的函数表达式</a></li>\n<li><a href=\"http://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript\" target=\"_blank\" rel=\"external\">stackoverflow: What is the purpose of a self executing function in javascript</a></li>\n<li><a href=\"http://weizhifeng.net/immediately-invoked-function-expression.html\" target=\"_blank\" rel=\"external\">weizhifeng.net: JavaScript中的立即执行函数表达式</a></li>\n</ul>\n</li>\n</ol>\n","excerpt":"<p><img src=\"/images/iife.png\" alt=\"cover\"></p>\n<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>最近在进行 <a href=\"https://github.com/MechanicianW/underscore-analysis\">underscore.js 源码分析</a>，也顺便看了些别的库的大致封装方式<br>underscore:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> root = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> _) <span class=\"keyword\">return</span> obj;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> _)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _(obj);</div><div class=\"line\">    <span class=\"keyword\">this</span>._wrapped = obj;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>","more":"<p>早期的 jQuery:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window, undefined </span>) </span>&#123;</div><div class=\"line\"><span class=\"keyword\">var</span> jQuery = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);&#125;);</div><div class=\"line\"><span class=\"built_in\">window</span>.jQuery = <span class=\"built_in\">window</span>.$ = jQuery;</div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd &amp;&amp; define.amd.jQuery ) &#123;</div><div class=\"line\">    define( <span class=\"string\">\"jquery\"</span>, [], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> jQuery; &#125; );</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;)( <span class=\"built_in\">window</span> );</div></pre></td></tr></table></figure>\n<p>这个封装和调用方式一看就是匿名函数嘛，可是匿名函数，然后呢？<br>于是趁着下午比较闲翻开高程从匿名函数这个地方开始看，发现了一系列的知识点……<br>大概脉络是: 函数定义方式 → 匿名函数的创建 → 匿名函数自执行还是IIFE？ → IIFE 的应用</p>\n<h3 id=\"函数定义方式\"><a href=\"#函数定义方式\" class=\"headerlink\" title=\"函数定义方式\"></a>函数定义方式</h3><ol>\n<li><p>函数声明     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo () &#123;&#125;</div></pre></td></tr></table></figure>\n<p><strong>函数声明提升</strong> ：可以把函数声明放在调用它的语句后面</p>\n</li>\n<li><p>函数表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function () &#123;&#125;</div></pre></td></tr></table></figure>\n<p>也属于匿名函数</p>\n</li>\n<li><p>使用Function构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = new Function ()</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"匿名函数的创建\"><a href=\"#匿名函数的创建\" class=\"headerlink\" title=\"匿名函数的创建\"></a>匿名函数的创建</h3><ol>\n<li><p>上述 使用函数表达式创建</p>\n</li>\n<li><p><code>(function (x, y) {alert(x + y)})(2, 3)</code><br>在第一个括号内创建匿名函数，第二个括号用于调用该匿名函数，并传入参数</p>\n<ul>\n<li><code>function (x,y) {alert(x + y)}</code>部分为所声明的函数</li>\n<li>然后用括号把函数声明包起来 <code>(function (x,y) {alert(x + y)})</code></li>\n<li>最后调用此函数 <code>(function (x, y) {alert(x + y)})(2, 3)</code></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>在这里我们也可以看到，创建匿名函数的方式有两种，第二种方式才会声明后立即执行，即不是所有的匿名函数都是可以立即执行的</p>\n</blockquote>\n<h3 id=\"“匿名函数自执行”-vs-IIFE\"><a href=\"#“匿名函数自执行”-vs-IIFE\" class=\"headerlink\" title=\"“匿名函数自执行” vs  IIFE\"></a>“匿名函数自执行” vs  IIFE</h3><p>自执行，有的地方会写为自调用，是一个经常会听到的的概念，我们再深究一下它吧。所谓的“匿名函数自执行”指的是 <code>Self-executing anonymous function</code> ，经常与 <code>IIFE</code> 混淆， <code>Immediately-Invoked Function Expression</code> 即 <strong>立即调用的函数表达式</strong> ，含义上的辨析 <a href=\"https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F\">先戳一下中文wiki</a> 吧。</p>\n<p>IIFE 的具体的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一个例子</div><div class=\"line\">(function (x) &#123; return x + 1;&#125;(2)) // =&gt; 3</div><div class=\"line\">// 第二个例子</div><div class=\"line\">var result = function (x) &#123; return x + 1; &#125;(2); // =&gt; result 的值为3</div></pre></td></tr></table></figure>\n<p>把第一个例子敲到控制台中，我们可以看到这个 <code>()</code> 中的代码立即执行了，返回3。对于第二个例子，它实际上执行的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function (x) &#123;return x + 1;&#125;</div><div class=\"line\">var result = foo(2)</div></pre></td></tr></table></figure>\n<p>这里有一个知识点： <strong>对于函数类对象，不论是一个现场定义的匿名函数，还是一个之前定义的有名字的函数，它们在不加括号的时候都代表了这个函数对象本身，而加了括号就代表调用这个函数，也就是这个函数 return 的对象。</strong></p>\n<p>再回到匿名函数自执行与 IIFE 的辨析上，匿名函数自执行(Self-executing anonymous function)是一个不够准确的概念：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 它是一个自执行的匿名函数，它必须用 arguments.callee() 来递归地调用自己</div><div class=\"line\">var foo = function() &#123; arguments.callee(); &#125;;</div><div class=\"line\">// 它是一个立即执行的匿名函数，只是立即执行了一段 code ，并不是调用自己</div><div class=\"line\">(function () &#123; /* code */ &#125; ());</div></pre></td></tr></table></figure>\n<p>因此 <code>自执行</code> 意味着调用自己， <code>立即调用，立即执行</code> 强调的是定义函数的时候就直接执行了函数，与函数体内是否调用自身无关。只能说这是两个看起来有些类似的概念，但实际上所强调的内容完全不一样。IIFE 也可以调用自己，匿名函数可以立即执行。</p>\n<h3 id=\"IIFE-的应用\"><a href=\"#IIFE-的应用\" class=\"headerlink\" title=\"IIFE 的应用\"></a>IIFE 的应用</h3><p>立即调用的函数表达式的根本作用是 <strong>创建一个独立的作用域</strong>。</p>\n<ol>\n<li><p>模拟块级作用域，在ES6之前 JavaScript 是没有块级作用域的。<br>在实际应用场景中，项目引用了很多不同的库 ，库与库之间是如何保证变量不被覆盖呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// libA.js</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> num = <span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// libB.js</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">2</span>;</div><div class=\"line\">\t<span class=\"comment\">// blabla</span></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这样的话，就如同我们在前面看到的 jquery underscore 那样，使自身作用域独立，不会互相覆盖。</p>\n</li>\n<li><p>解决闭包的坑： <strong>闭包只能取得包含函数中任何变量的最后一个值</strong><br>这次改造一下《高程三》中提到的例子作为参照吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">  <span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">\t  foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(i)</div><div class=\"line\">    &#125;</div><div class=\"line\">    result.push(foo)</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> result</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> res = test()</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>,len = res.length; i &lt; len; i++)&#123;</div><div class=\"line\">  res[i]()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 控制台中打出来的是10个10，而不是1，2，3...</span></div><div class=\"line\"><span class=\"comment\">// i 是贯穿整个作用域的，而不是给每个 foo 分配了一个 i</span></div><div class=\"line\"><span class=\"comment\">// test()执行完毕后才调用 console.log() 一定是发生在for循环已循环结束后，此时i值为10</span></div></pre></td></tr></table></figure>\n<p>在线例子可以戳 <a href=\"https://jsfiddle.net/46x5s72a/\">JSFiddle</a><br>这个坑该怎么处理呢？引入IIFE！下面代码是可用的，把 i 的值作为索引锁住了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 解决思路是给每个foo函数创建一个独立的作用域</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">  <span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">    <span class=\"comment\">// 添加一个IIFE</span></div><div class=\"line\">\t  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">\t    foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(index);&#125;;</div><div class=\"line\">      result.push(foo)</div><div class=\"line\">\t   &#125;)(i);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">return</span> result</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> res = test()</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>,len = res.length; i &lt; len; i++)&#123;</div><div class=\"line\">    res[i]()</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html\">汤姆大叔的博客:深入理解JavaScript系列（4）: 立即调用的函数表达式</a></li>\n<li><a href=\"http://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript\">stackoverflow: What is the purpose of a self executing function in javascript</a></li>\n<li><a href=\"http://weizhifeng.net/immediately-invoked-function-expression.html\">weizhifeng.net: JavaScript中的立即执行函数表达式</a></li>\n</ul>\n</li>\n</ol>"},{"layout":"post","title":"Cookie, LocalStorage 与 SessionStorage","date":"2016-03-10T07:02:00.000Z","_content":"有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。\n\n## 基本概念\n\n### Cookie\n\nCookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie\n\n### localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。\n\n<!--more-->\n\n### sessionStorage\n\nsessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。\n<table>\n    <tr>\n        <th>特性</th>\n        <th>Chorme</th>\n        <th>Firefox</th>\n        <th>IE</th>\n        <td>Opera</td>\n        <td>Safari</td>\n    </tr>\n    <tr>\n        <td>localStorage</td>\n        <td>4</td>\n        <td>3.5</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>sessionStorage</td>\n        <td>5</td>\n        <td>2</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n</table>\n\n## 共同点\n\n- 都是保存在浏览器端，而且同源。 \n- 三者都是键值对的集合。\n\n## 区别\n\n- cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据\n- 如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交\n- 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n- 数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。\n- 安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。\n- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。\n\n## 应用场景\n\n- 每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。\n- 由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。","source":"_posts/cookie-localstorage-session.md","raw":"---\nlayout: post\ntitle:  \"Cookie, LocalStorage 与 SessionStorage\"\ndate:   2016-03-10 15:02\ncategories: front-end javascript\n---\n有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。\n\n## 基本概念\n\n### Cookie\n\nCookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie\n\n### localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。\n\n<!--more-->\n\n### sessionStorage\n\nsessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。\n<table>\n    <tr>\n        <th>特性</th>\n        <th>Chorme</th>\n        <th>Firefox</th>\n        <th>IE</th>\n        <td>Opera</td>\n        <td>Safari</td>\n    </tr>\n    <tr>\n        <td>localStorage</td>\n        <td>4</td>\n        <td>3.5</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>sessionStorage</td>\n        <td>5</td>\n        <td>2</td>\n        <td>8</td>\n        <td>10.5</td>\n        <td>4</td>\n    </tr>\n</table>\n\n## 共同点\n\n- 都是保存在浏览器端，而且同源。 \n- 三者都是键值对的集合。\n\n## 区别\n\n- cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据\n- 如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交\n- 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n- 数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。\n- 安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。\n- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。\n\n## 应用场景\n\n- 每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。\n- 由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。","slug":"cookie-localstorage-session","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyiq0009gbeh4e817jo9","content":"<p>有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p>\n<a id=\"more\"></a>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<table><br>    <tr><br>        <th>特性</th><br>        <th>Chorme</th><br>        <th>Firefox</th><br>        <th>IE</th><br>        <td>Opera</td><br>        <td>Safari</td><br>    </tr><br>    <tr><br>        <td>localStorage</td><br>        <td>4</td><br>        <td>3.5</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br>    <tr><br>        <td>sessionStorage</td><br>        <td>5</td><br>        <td>2</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br></table>\n\n<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li>都是保存在浏览器端，而且同源。 </li>\n<li>三者都是键值对的集合。</li>\n</ul>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据</li>\n<li>如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交</li>\n<li>存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。</li>\n<li>安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。</li>\n<li>由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。</li>\n</ul>\n","excerpt":"<p>有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie</p>\n<h3 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p>","more":"<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<table><br>    <tr><br>        <th>特性</th><br>        <th>Chorme</th><br>        <th>Firefox</th><br>        <th>IE</th><br>        <td>Opera</td><br>        <td>Safari</td><br>    </tr><br>    <tr><br>        <td>localStorage</td><br>        <td>4</td><br>        <td>3.5</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br>    <tr><br>        <td>sessionStorage</td><br>        <td>5</td><br>        <td>2</td><br>        <td>8</td><br>        <td>10.5</td><br>        <td>4</td><br>    </tr><br></table>\n\n<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li>都是保存在浏览器端，而且同源。 </li>\n<li>三者都是键值对的集合。</li>\n</ul>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据</li>\n<li>如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交</li>\n<li>存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>数据生命期不同。sessionStorage会在会话结束后销毁；而localStorage会永久保存直到覆盖。cookie会在过期时间之后销毁。</li>\n<li>安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和cookie在所有同源窗口中都是共享的。</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>每个HTTP请求都会带着cookie的信息，若cookie中包含大量数据则浪费了过多带宽。大多数情况下，cookie都用来存储身份校验，会话，广告踪迹等token。</li>\n<li>由于locakStorage和sessionStorage所存储的数据是容易读取和更改的，所以它们更适合存储那些不明感的，与安全性无关的数据。</li>\n</ul>"},{"layout":"post","title":"You Don't Know setTimeout","date":"2017-06-04T13:15:00.000Z","_content":"\n![cover](/images/jstips-animation.gif)\n\n### 几个可能不知道的定时器⏲特性\n首先，**setTimeout()/setInterval()** 方法不是 ECMAScript 规范定义的内容，而是属于 BOM 提供的功能，也就是说定时器作为 BOM 对象和方法的一部分才能在浏览器中使用。\n\n需要注意的是 **setTimeout() 与 setInterval() 在触发周期的定义上完全不一样**，在下面例子 setTimeout() 代码中，要在前一个 callback 回调执行结束并延迟 10ms 以后才能再次执行 setTimeout()，即延迟是要求运行时(runtime) 处理请求所需的最小时间，但不是有所保证的时间。而 setInterval() 则是每隔 10ms 就执行一次 callback 回调，不会关注 callback 何时执行结束。\n\n<!--more-->\n\n```javascript\n// 由于触发周期定义不同，以下两个定时器有非常大的区别\n\n// 定义一个 timeout 定时器，每10毫秒重新调用自己\nsetTimeout(function repeatMe() {\n  // do something\n  setTimeout(repeatMe, 10);\n}, 10);\n\n// 定义一个 interval 定时器，每10毫秒触发一次\nsetInterval(function() {\n  // do something\n}, 10)\n```\n\n除此之外，在 [HTML spec](https://html.spec.whatwg.org/multipage/webappapis.html#timers) 中定义 **setTimeout 的最小延迟时间是4ms**，但通常认为浏览器可实现的定时器的最小延迟时间是10ms，即 setTimeout(fn, 0) 也是会延迟至少10ms，如果想实现 0 delay 的话可以通过 [window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) 实现。\n\n定时器还有一个小特性，在开发移动公告的滚动动画时发现，从动画所在的 tab 页切换到别的 tab 之后再切回，动画会完全乱掉，并不会按代码中所设置的延迟时间进行。这是为了减少背景 tab 页面的代码运行消耗（电量），**背景 tab 页面中定时器的间隔会增加到1000ms**，如果遇到需要解决这个问题的场景，可以通过 [HTML5 Web Workers](https://robertnyman.com/2010/03/25/using-html5-web-workers-to-have-background-computational-power/) 或者用 [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) 代替定时器来解决。\n\n最后，由于 webkit 中 timer 类的实现原理决定：**预期延时时间最小的任务最先被执行，同时，预期延时时间相同的两个任务，其执行顺序是按照注册的先后顺序执行。**\n\n```javascript\nvar start = new Date;\nsetTimeout(function(){\n  console.log('fn1');\n}, 20);\nsetTimeout(function(){\n  console.log('fn2');\n}, 30);\nsetTimeout(function(){\n  console.log('another fn2');\n}, 30);\nsetTimeout(function(){\n  console.log('fn3');\n}, 10);\nconsole.log('start while');\nwhile (new Date - start < 1000) {};\nconsole.log('end while');\n\n// 打印结果如下\n// start while\n// end while\n// fn3\n// fn1\n// fn2\n// another fn2\n```\n\n### Event Loop 相关概念\n浏览器让一个单线程共用于解释和执行 JavaScript，我们可以将它称为是“主线程”。其它的处理AJAX请求的线程、处理DOM事件的线程、定时器线程等等可以称为是“工作线程”。\n\nJavaScript 的单线程意味着只有一个 call stack，也意味着同一时间是能做一件事。\n\n![Event Loop](http://o7ts2uaks.bkt.clouddn.com/v2-25076e938167ad11c6a2a9ec099e0973_b.png)\n\n- 调用栈(call stack): 后进先出，函数被调用时会被加入到调用栈顶部，等执行结束再从顶部移除。\n\n- 堆(heap): 内存分配区\n\n- 消息队列(quene): 也叫任务队列。先进先出，一旦调用栈中的所有任务执行完毕，栈清空，就会读取消息队列。**消息/任务就是注册异步任务时添加的回调函数**。\n\n- 同步任务: 在主线程的调用栈排队执行的任务。\n\n- 异步任务: 主线程发起执行异步函数的请求，对应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到消息队列，主线程通过事件循环过程去取消息，然后执行回调。\n\n- 事件循环(event loop): 事件循环是指主线程重复从消息队列中取消息、执行的过程。**\n取一个消息并执行的过程叫做一次循环**。\n\n- Web APIs: 如 AJAX，定时器，DOM事件这些异步事务并不在 V8(JavaScript)运行环境中，是由浏览器提供的 Web API\n\n相关概念就是这些，http://latentflip.com/loupe/ 是一个可视化调用栈的网站，可以把自己的代码敲到里面运行来看 event loop 的具体动态。\n\n### 定时器和线程是如何工作的\n\n![timer](https://johnresig.com/files/Timers.png)\n\n以此图为例，来理解 JavaScript 中异步事件的执行。\n\n> 0ms: 启动即执行第一段 JavaScript 代码块，启动一个10ms延迟定时器(timeout)和10ms间隔定时器(interval)，延迟定时器是先于间隔定时器声明启动的。\n\n> 5ms: 鼠标单击，但是由于现在正在执行第一个代码块，调用栈不为空，单击事件的处理函数不能立即执行，只能在消息队列中进行排队\n\n> 10ms: 延迟定时器触发，间隔定时器触发，同理也都进行排队\n\n> 18ms: 第一段代码块执行结束，调用栈为空，此时有三个代码块在排队执行(click 事件处理函数，延迟定时器处理函数，间隔定时器第一次触发的处理函数)，按顺序此时主线程中执行 click 事件回调。消息队列中此时还有两个回调。\n\n> 20ms: 间隔定时器又触发了，由于间隔定时器第一次触发的处理函数仍在排队，浏览器不会对同一 interval 处理函数的多个实例同时进行排队，于是此次调用作废，消息队列不变，仍然还是那两个回调。\n\n> 28ms: click 事件回调函数执行完毕，按顺序，此时主线程中将执行延时定时器处理函数。消息队列中只有间隔定时器的第一次触发回调在排队。\n\n> 30ms: 间隔定时器再一次触发了，仍然因为第一次触发的回调仍在排队，此次调用作废。\n\n> 34ms: 延时定时器回调函数执行完毕。开始执行间隔定时器第一次触发的回调函数。此时消息队列为空。\n\n> 40ms: 间隔定时器再一次触发了，导致新的 interval 回调函数进入消息队列中排队。\n\n> 42ms: 间隔定时器第一次回调函数执行完毕，正在排队的回调开始执行。消息队列再次为空。\n\n> 47ms: 回调执行完毕，此时还没有到触发 interval 的时间，因此下一个 interval 回调可以等到触发事件立即执行。\n\n由此，我们可以知道：\n- 如果无法立即执行定时器，该定时器会被推迟到下一个可用的执行时间点上(验证了实际延迟时间必然会比指定的延迟时间更长)\n- 同一个 interval 执行程序的多个实例不能同时进行排队\n- 延迟时间足够长的话，很有可能会有两个 interval 回调会无延迟连续执行\n\n### setTimeout(fn, 0)\n\n由上述内容可知，setTimeout(fn, 0) 中的代码并不是为了 fn 立即执行，而是将 fn 插入到消息队列，使得待调用栈为空时将立即调用执行 fn，保证了 fn 的后执行。因此我们可以通过这一特性，**用 setTimeout(fn, 0) 调整事件的发生顺序**。\n\n```javascript\nvar input = document.getElementsByTagName('input[type=button]')[0];\ninput.onclick = function () {\n  setTimeout(function () {\n    input.value +=' input';\n  }, 0)\n};\ndocument.body.onclick = function () {\n  input.value += ' body'\n};\n// 模拟事件捕获，实现父元素的事件回调函数先发生\n```\n\n在《高性能JavaScript》中认为 **单个 JavaScript 操作花费的总时间不应该超过100毫秒**。否则用户会感到与界面失去联系。实际上，如果一段 js 代码的运行时间超过 500ms，Firefox 和 Opera 浏览器将弹出警告对话框，Safari 会默认终止运行时间超过500 ms 的脚本。因此我们需要定时器将计算量大耗时长的任务分割成不会让浏览器挂掉的碎片。\n\n```javascript\n\nvar div = document.getElementsByTagName('div')[0];\n// 会造成浏览器阻塞\nfor(var i=0xA00000;i<0xFFFFFF;i++) {\n  div.style.backgroundColor = '#'+i.toString(16);\n}\n// 分割成小的任务\nvar timer;\nvar i=0x100000;\nfunction func() {\n  timer = setTimeout(func, 0);\n  div.style.backgroundColor = '#'+i.toString(16);\n  if (i++ == 0xFFFFFF) clearInterval(timer);\n}\ntimer = setTimeout(func, 0);\n```\n\n### 定时器的其它应用\n\n这里就是说函数节流(throttle)与函数防抖(debounce)\n\n以 Underscore.js 中 debounce 的实现为例：\n\n```javascript\n/**\n * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        传入函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，调用触发于开始边界而不是结束边界\n * @return {function}             返回调用函数\n */\n_.debounce = function(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function() {\n    // 设置 last 为当前时间与上次触发的时间间隔\n    var last = _.now() - timestamp;\n\n    if (last < wait && last > 0) {\n      // 如果时间间隔小于所传入的 wait\n      // 还没到触发时间，继续设置定时器\n      timeout = setTimeout(later, wait - last);\n    } else {\n      // 到了触发时间，清空计时器，避免影响下次触发\n      timeout = null;\n      // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用\n      if (!immediate) {\n        // 执行 func\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function() {\n    context = this;\n    args = arguments;\n    // 每次触发之后 更新时间戳为此次触发时间\n    timestamp = _.now();\n    // 判断是否符合立即触发的条件\n    var callNow = immediate && !timeout;\n    // 如果延时不存在，重新设定延时\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      // 立即触发\n      result = func.apply(context, args);\n      context = args = null;\n    }\n    return result;\n  };\n};\n```\n\n需要注意的是，**管理多个定时器会产生许多问题，同时创建大量的定时器将会在浏览器中增加垃圾回收任务发生的可能性**。\n\n定时器是一个特殊的垃圾回收问题，这是由于它们是在 JavaScript 主线程之外的浏览器线程进行管理的。不同浏览器垃圾回收的周期不同，这也是通过定时器处理动画时，动画在有的浏览器上很流畅，有的浏览器上特别卡的原因之一。因此应该注意减少同时使用的定时器的数量或者使用中央定时器来管理多个回调。\n\n### 几个后续值得探究的问题\n\n- HTML5 Web Workers: HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中\n- requestAnimationFrame: 更适合动画使用的“定时循环器”\n- setImmediate: 一个比较新的定时器，setTimeout(0)的替代版\n- Node.js 中的 Event Loop\n\n### 参考内容\n\n- [Philip Roberts: What the heck is the event loop anyway](https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=669s)\n\n- [John Resig: How JavaScript Timers Work](https://johnresig.com/blog/how-javascript-timers-work/)\n\n- [AlloyTeam: 从 setTimeout 说起事件循环](http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/)\n\n- [阮一峰: JavaScript 运行机制详解——再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop)\n\n","source":"_posts/from-settimeout-to-event-loop.md","raw":"---\nlayout: post\ntitle:  \"You Don't Know setTimeout\"\ndate:   2017-06-04 21:15\ncategories: front-end javascript\n---\n\n![cover](/images/jstips-animation.gif)\n\n### 几个可能不知道的定时器⏲特性\n首先，**setTimeout()/setInterval()** 方法不是 ECMAScript 规范定义的内容，而是属于 BOM 提供的功能，也就是说定时器作为 BOM 对象和方法的一部分才能在浏览器中使用。\n\n需要注意的是 **setTimeout() 与 setInterval() 在触发周期的定义上完全不一样**，在下面例子 setTimeout() 代码中，要在前一个 callback 回调执行结束并延迟 10ms 以后才能再次执行 setTimeout()，即延迟是要求运行时(runtime) 处理请求所需的最小时间，但不是有所保证的时间。而 setInterval() 则是每隔 10ms 就执行一次 callback 回调，不会关注 callback 何时执行结束。\n\n<!--more-->\n\n```javascript\n// 由于触发周期定义不同，以下两个定时器有非常大的区别\n\n// 定义一个 timeout 定时器，每10毫秒重新调用自己\nsetTimeout(function repeatMe() {\n  // do something\n  setTimeout(repeatMe, 10);\n}, 10);\n\n// 定义一个 interval 定时器，每10毫秒触发一次\nsetInterval(function() {\n  // do something\n}, 10)\n```\n\n除此之外，在 [HTML spec](https://html.spec.whatwg.org/multipage/webappapis.html#timers) 中定义 **setTimeout 的最小延迟时间是4ms**，但通常认为浏览器可实现的定时器的最小延迟时间是10ms，即 setTimeout(fn, 0) 也是会延迟至少10ms，如果想实现 0 delay 的话可以通过 [window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) 实现。\n\n定时器还有一个小特性，在开发移动公告的滚动动画时发现，从动画所在的 tab 页切换到别的 tab 之后再切回，动画会完全乱掉，并不会按代码中所设置的延迟时间进行。这是为了减少背景 tab 页面的代码运行消耗（电量），**背景 tab 页面中定时器的间隔会增加到1000ms**，如果遇到需要解决这个问题的场景，可以通过 [HTML5 Web Workers](https://robertnyman.com/2010/03/25/using-html5-web-workers-to-have-background-computational-power/) 或者用 [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) 代替定时器来解决。\n\n最后，由于 webkit 中 timer 类的实现原理决定：**预期延时时间最小的任务最先被执行，同时，预期延时时间相同的两个任务，其执行顺序是按照注册的先后顺序执行。**\n\n```javascript\nvar start = new Date;\nsetTimeout(function(){\n  console.log('fn1');\n}, 20);\nsetTimeout(function(){\n  console.log('fn2');\n}, 30);\nsetTimeout(function(){\n  console.log('another fn2');\n}, 30);\nsetTimeout(function(){\n  console.log('fn3');\n}, 10);\nconsole.log('start while');\nwhile (new Date - start < 1000) {};\nconsole.log('end while');\n\n// 打印结果如下\n// start while\n// end while\n// fn3\n// fn1\n// fn2\n// another fn2\n```\n\n### Event Loop 相关概念\n浏览器让一个单线程共用于解释和执行 JavaScript，我们可以将它称为是“主线程”。其它的处理AJAX请求的线程、处理DOM事件的线程、定时器线程等等可以称为是“工作线程”。\n\nJavaScript 的单线程意味着只有一个 call stack，也意味着同一时间是能做一件事。\n\n![Event Loop](http://o7ts2uaks.bkt.clouddn.com/v2-25076e938167ad11c6a2a9ec099e0973_b.png)\n\n- 调用栈(call stack): 后进先出，函数被调用时会被加入到调用栈顶部，等执行结束再从顶部移除。\n\n- 堆(heap): 内存分配区\n\n- 消息队列(quene): 也叫任务队列。先进先出，一旦调用栈中的所有任务执行完毕，栈清空，就会读取消息队列。**消息/任务就是注册异步任务时添加的回调函数**。\n\n- 同步任务: 在主线程的调用栈排队执行的任务。\n\n- 异步任务: 主线程发起执行异步函数的请求，对应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到消息队列，主线程通过事件循环过程去取消息，然后执行回调。\n\n- 事件循环(event loop): 事件循环是指主线程重复从消息队列中取消息、执行的过程。**\n取一个消息并执行的过程叫做一次循环**。\n\n- Web APIs: 如 AJAX，定时器，DOM事件这些异步事务并不在 V8(JavaScript)运行环境中，是由浏览器提供的 Web API\n\n相关概念就是这些，http://latentflip.com/loupe/ 是一个可视化调用栈的网站，可以把自己的代码敲到里面运行来看 event loop 的具体动态。\n\n### 定时器和线程是如何工作的\n\n![timer](https://johnresig.com/files/Timers.png)\n\n以此图为例，来理解 JavaScript 中异步事件的执行。\n\n> 0ms: 启动即执行第一段 JavaScript 代码块，启动一个10ms延迟定时器(timeout)和10ms间隔定时器(interval)，延迟定时器是先于间隔定时器声明启动的。\n\n> 5ms: 鼠标单击，但是由于现在正在执行第一个代码块，调用栈不为空，单击事件的处理函数不能立即执行，只能在消息队列中进行排队\n\n> 10ms: 延迟定时器触发，间隔定时器触发，同理也都进行排队\n\n> 18ms: 第一段代码块执行结束，调用栈为空，此时有三个代码块在排队执行(click 事件处理函数，延迟定时器处理函数，间隔定时器第一次触发的处理函数)，按顺序此时主线程中执行 click 事件回调。消息队列中此时还有两个回调。\n\n> 20ms: 间隔定时器又触发了，由于间隔定时器第一次触发的处理函数仍在排队，浏览器不会对同一 interval 处理函数的多个实例同时进行排队，于是此次调用作废，消息队列不变，仍然还是那两个回调。\n\n> 28ms: click 事件回调函数执行完毕，按顺序，此时主线程中将执行延时定时器处理函数。消息队列中只有间隔定时器的第一次触发回调在排队。\n\n> 30ms: 间隔定时器再一次触发了，仍然因为第一次触发的回调仍在排队，此次调用作废。\n\n> 34ms: 延时定时器回调函数执行完毕。开始执行间隔定时器第一次触发的回调函数。此时消息队列为空。\n\n> 40ms: 间隔定时器再一次触发了，导致新的 interval 回调函数进入消息队列中排队。\n\n> 42ms: 间隔定时器第一次回调函数执行完毕，正在排队的回调开始执行。消息队列再次为空。\n\n> 47ms: 回调执行完毕，此时还没有到触发 interval 的时间，因此下一个 interval 回调可以等到触发事件立即执行。\n\n由此，我们可以知道：\n- 如果无法立即执行定时器，该定时器会被推迟到下一个可用的执行时间点上(验证了实际延迟时间必然会比指定的延迟时间更长)\n- 同一个 interval 执行程序的多个实例不能同时进行排队\n- 延迟时间足够长的话，很有可能会有两个 interval 回调会无延迟连续执行\n\n### setTimeout(fn, 0)\n\n由上述内容可知，setTimeout(fn, 0) 中的代码并不是为了 fn 立即执行，而是将 fn 插入到消息队列，使得待调用栈为空时将立即调用执行 fn，保证了 fn 的后执行。因此我们可以通过这一特性，**用 setTimeout(fn, 0) 调整事件的发生顺序**。\n\n```javascript\nvar input = document.getElementsByTagName('input[type=button]')[0];\ninput.onclick = function () {\n  setTimeout(function () {\n    input.value +=' input';\n  }, 0)\n};\ndocument.body.onclick = function () {\n  input.value += ' body'\n};\n// 模拟事件捕获，实现父元素的事件回调函数先发生\n```\n\n在《高性能JavaScript》中认为 **单个 JavaScript 操作花费的总时间不应该超过100毫秒**。否则用户会感到与界面失去联系。实际上，如果一段 js 代码的运行时间超过 500ms，Firefox 和 Opera 浏览器将弹出警告对话框，Safari 会默认终止运行时间超过500 ms 的脚本。因此我们需要定时器将计算量大耗时长的任务分割成不会让浏览器挂掉的碎片。\n\n```javascript\n\nvar div = document.getElementsByTagName('div')[0];\n// 会造成浏览器阻塞\nfor(var i=0xA00000;i<0xFFFFFF;i++) {\n  div.style.backgroundColor = '#'+i.toString(16);\n}\n// 分割成小的任务\nvar timer;\nvar i=0x100000;\nfunction func() {\n  timer = setTimeout(func, 0);\n  div.style.backgroundColor = '#'+i.toString(16);\n  if (i++ == 0xFFFFFF) clearInterval(timer);\n}\ntimer = setTimeout(func, 0);\n```\n\n### 定时器的其它应用\n\n这里就是说函数节流(throttle)与函数防抖(debounce)\n\n以 Underscore.js 中 debounce 的实现为例：\n\n```javascript\n/**\n * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        传入函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，调用触发于开始边界而不是结束边界\n * @return {function}             返回调用函数\n */\n_.debounce = function(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function() {\n    // 设置 last 为当前时间与上次触发的时间间隔\n    var last = _.now() - timestamp;\n\n    if (last < wait && last > 0) {\n      // 如果时间间隔小于所传入的 wait\n      // 还没到触发时间，继续设置定时器\n      timeout = setTimeout(later, wait - last);\n    } else {\n      // 到了触发时间，清空计时器，避免影响下次触发\n      timeout = null;\n      // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用\n      if (!immediate) {\n        // 执行 func\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function() {\n    context = this;\n    args = arguments;\n    // 每次触发之后 更新时间戳为此次触发时间\n    timestamp = _.now();\n    // 判断是否符合立即触发的条件\n    var callNow = immediate && !timeout;\n    // 如果延时不存在，重新设定延时\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      // 立即触发\n      result = func.apply(context, args);\n      context = args = null;\n    }\n    return result;\n  };\n};\n```\n\n需要注意的是，**管理多个定时器会产生许多问题，同时创建大量的定时器将会在浏览器中增加垃圾回收任务发生的可能性**。\n\n定时器是一个特殊的垃圾回收问题，这是由于它们是在 JavaScript 主线程之外的浏览器线程进行管理的。不同浏览器垃圾回收的周期不同，这也是通过定时器处理动画时，动画在有的浏览器上很流畅，有的浏览器上特别卡的原因之一。因此应该注意减少同时使用的定时器的数量或者使用中央定时器来管理多个回调。\n\n### 几个后续值得探究的问题\n\n- HTML5 Web Workers: HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中\n- requestAnimationFrame: 更适合动画使用的“定时循环器”\n- setImmediate: 一个比较新的定时器，setTimeout(0)的替代版\n- Node.js 中的 Event Loop\n\n### 参考内容\n\n- [Philip Roberts: What the heck is the event loop anyway](https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=669s)\n\n- [John Resig: How JavaScript Timers Work](https://johnresig.com/blog/how-javascript-timers-work/)\n\n- [AlloyTeam: 从 setTimeout 说起事件循环](http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/)\n\n- [阮一峰: JavaScript 运行机制详解——再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop)\n\n","slug":"from-settimeout-to-event-loop","published":1,"updated":"2017-11-19T06:49:28.000Z","_id":"cja54xyiu000bgbehy4do6g12","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/jstips-animation.gif\" alt=\"cover\"></p>\n<h3 id=\"几个可能不知道的定时器⏲特性\"><a href=\"#几个可能不知道的定时器⏲特性\" class=\"headerlink\" title=\"几个可能不知道的定时器⏲特性\"></a>几个可能不知道的定时器⏲特性</h3><p>首先，<strong>setTimeout()/setInterval()</strong> 方法不是 ECMAScript 规范定义的内容，而是属于 BOM 提供的功能，也就是说定时器作为 BOM 对象和方法的一部分才能在浏览器中使用。</p>\n<p>需要注意的是 <strong>setTimeout() 与 setInterval() 在触发周期的定义上完全不一样</strong>，在下面例子 setTimeout() 代码中，要在前一个 callback 回调执行结束并延迟 10ms 以后才能再次执行 setTimeout()，即延迟是要求运行时(runtime) 处理请求所需的最小时间，但不是有所保证的时间。而 setInterval() 则是每隔 10ms 就执行一次 callback 回调，不会关注 callback 何时执行结束。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于触发周期定义不同，以下两个定时器有非常大的区别</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个 timeout 定时器，每10毫秒重新调用自己</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeatMe</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">  setTimeout(repeatMe, <span class=\"number\">10</span>);</div><div class=\"line\">&#125;, <span class=\"number\">10</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个 interval 定时器，每10毫秒触发一次</span></div><div class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;, <span class=\"number\">10</span>)</div></pre></td></tr></table></figure>\n<p>除此之外，在 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#timers\" target=\"_blank\" rel=\"external\">HTML spec</a> 中定义 <strong>setTimeout 的最小延迟时间是4ms</strong>，但通常认为浏览器可实现的定时器的最小延迟时间是10ms，即 setTimeout(fn, 0) 也是会延迟至少10ms，如果想实现 0 delay 的话可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\" target=\"_blank\" rel=\"external\">window.postMessage</a> 实现。</p>\n<p>定时器还有一个小特性，在开发移动公告的滚动动画时发现，从动画所在的 tab 页切换到别的 tab 之后再切回，动画会完全乱掉，并不会按代码中所设置的延迟时间进行。这是为了减少背景 tab 页面的代码运行消耗（电量），<strong>背景 tab 页面中定时器的间隔会增加到1000ms</strong>，如果遇到需要解决这个问题的场景，可以通过 <a href=\"https://robertnyman.com/2010/03/25/using-html5-web-workers-to-have-background-computational-power/\" target=\"_blank\" rel=\"external\">HTML5 Web Workers</a> 或者用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\" target=\"_blank\" rel=\"external\">requestAnimationFrame</a> 代替定时器来解决。</p>\n<p>最后，由于 webkit 中 timer 类的实现原理决定：<strong>预期延时时间最小的任务最先被执行，同时，预期延时时间相同的两个任务，其执行顺序是按照注册的先后顺序执行。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn1'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">20</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn2'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">30</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'another fn2'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">30</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn3'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start while'</span>);</div><div class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span> - start &lt; <span class=\"number\">1000</span>) &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end while'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 打印结果如下</span></div><div class=\"line\"><span class=\"comment\">// start while</span></div><div class=\"line\"><span class=\"comment\">// end while</span></div><div class=\"line\"><span class=\"comment\">// fn3</span></div><div class=\"line\"><span class=\"comment\">// fn1</span></div><div class=\"line\"><span class=\"comment\">// fn2</span></div><div class=\"line\"><span class=\"comment\">// another fn2</span></div></pre></td></tr></table></figure>\n<h3 id=\"Event-Loop-相关概念\"><a href=\"#Event-Loop-相关概念\" class=\"headerlink\" title=\"Event Loop 相关概念\"></a>Event Loop 相关概念</h3><p>浏览器让一个单线程共用于解释和执行 JavaScript，我们可以将它称为是“主线程”。其它的处理AJAX请求的线程、处理DOM事件的线程、定时器线程等等可以称为是“工作线程”。</p>\n<p>JavaScript 的单线程意味着只有一个 call stack，也意味着同一时间是能做一件事。</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/v2-25076e938167ad11c6a2a9ec099e0973_b.png\" alt=\"Event Loop\"></p>\n<ul>\n<li><p>调用栈(call stack): 后进先出，函数被调用时会被加入到调用栈顶部，等执行结束再从顶部移除。</p>\n</li>\n<li><p>堆(heap): 内存分配区</p>\n</li>\n<li><p>消息队列(quene): 也叫任务队列。先进先出，一旦调用栈中的所有任务执行完毕，栈清空，就会读取消息队列。<strong>消息/任务就是注册异步任务时添加的回调函数</strong>。</p>\n</li>\n<li><p>同步任务: 在主线程的调用栈排队执行的任务。</p>\n</li>\n<li><p>异步任务: 主线程发起执行异步函数的请求，对应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到消息队列，主线程通过事件循环过程去取消息，然后执行回调。</p>\n</li>\n<li><p>事件循环(event loop): 事件循环是指主线程重复从消息队列中取消息、执行的过程。<strong><br>取一个消息并执行的过程叫做一次循环</strong>。</p>\n</li>\n<li><p>Web APIs: 如 AJAX，定时器，DOM事件这些异步事务并不在 V8(JavaScript)运行环境中，是由浏览器提供的 Web API</p>\n</li>\n</ul>\n<p>相关概念就是这些，<a href=\"http://latentflip.com/loupe/\" target=\"_blank\" rel=\"external\">http://latentflip.com/loupe/</a> 是一个可视化调用栈的网站，可以把自己的代码敲到里面运行来看 event loop 的具体动态。</p>\n<h3 id=\"定时器和线程是如何工作的\"><a href=\"#定时器和线程是如何工作的\" class=\"headerlink\" title=\"定时器和线程是如何工作的\"></a>定时器和线程是如何工作的</h3><p><img src=\"https://johnresig.com/files/Timers.png\" alt=\"timer\"></p>\n<p>以此图为例，来理解 JavaScript 中异步事件的执行。</p>\n<blockquote>\n<p>0ms: 启动即执行第一段 JavaScript 代码块，启动一个10ms延迟定时器(timeout)和10ms间隔定时器(interval)，延迟定时器是先于间隔定时器声明启动的。</p>\n<p>5ms: 鼠标单击，但是由于现在正在执行第一个代码块，调用栈不为空，单击事件的处理函数不能立即执行，只能在消息队列中进行排队</p>\n<p>10ms: 延迟定时器触发，间隔定时器触发，同理也都进行排队</p>\n<p>18ms: 第一段代码块执行结束，调用栈为空，此时有三个代码块在排队执行(click 事件处理函数，延迟定时器处理函数，间隔定时器第一次触发的处理函数)，按顺序此时主线程中执行 click 事件回调。消息队列中此时还有两个回调。</p>\n<p>20ms: 间隔定时器又触发了，由于间隔定时器第一次触发的处理函数仍在排队，浏览器不会对同一 interval 处理函数的多个实例同时进行排队，于是此次调用作废，消息队列不变，仍然还是那两个回调。</p>\n<p>28ms: click 事件回调函数执行完毕，按顺序，此时主线程中将执行延时定时器处理函数。消息队列中只有间隔定时器的第一次触发回调在排队。</p>\n<p>30ms: 间隔定时器再一次触发了，仍然因为第一次触发的回调仍在排队，此次调用作废。</p>\n<p>34ms: 延时定时器回调函数执行完毕。开始执行间隔定时器第一次触发的回调函数。此时消息队列为空。</p>\n<p>40ms: 间隔定时器再一次触发了，导致新的 interval 回调函数进入消息队列中排队。</p>\n<p>42ms: 间隔定时器第一次回调函数执行完毕，正在排队的回调开始执行。消息队列再次为空。</p>\n<p>47ms: 回调执行完毕，此时还没有到触发 interval 的时间，因此下一个 interval 回调可以等到触发事件立即执行。</p>\n</blockquote>\n<p>由此，我们可以知道：</p>\n<ul>\n<li>如果无法立即执行定时器，该定时器会被推迟到下一个可用的执行时间点上(验证了实际延迟时间必然会比指定的延迟时间更长)</li>\n<li>同一个 interval 执行程序的多个实例不能同时进行排队</li>\n<li>延迟时间足够长的话，很有可能会有两个 interval 回调会无延迟连续执行</li>\n</ul>\n<h3 id=\"setTimeout-fn-0\"><a href=\"#setTimeout-fn-0\" class=\"headerlink\" title=\"setTimeout(fn, 0)\"></a>setTimeout(fn, 0)</h3><p>由上述内容可知，setTimeout(fn, 0) 中的代码并不是为了 fn 立即执行，而是将 fn 插入到消息队列，使得待调用栈为空时将立即调用执行 fn，保证了 fn 的后执行。因此我们可以通过这一特性，<strong>用 setTimeout(fn, 0) 调整事件的发生顺序</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> input = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'input[type=button]'</span>)[<span class=\"number\">0</span>];</div><div class=\"line\">input.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    input.value +=<span class=\"string\">' input'</span>;</div><div class=\"line\">  &#125;, <span class=\"number\">0</span>)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  input.value += <span class=\"string\">' body'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 模拟事件捕获，实现父元素的事件回调函数先发生</span></div></pre></td></tr></table></figure>\n<p>在《高性能JavaScript》中认为 <strong>单个 JavaScript 操作花费的总时间不应该超过100毫秒</strong>。否则用户会感到与界面失去联系。实际上，如果一段 js 代码的运行时间超过 500ms，Firefox 和 Opera 浏览器将弹出警告对话框，Safari 会默认终止运行时间超过500 ms 的脚本。因此我们需要定时器将计算量大耗时长的任务分割成不会让浏览器挂掉的碎片。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'div'</span>)[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"comment\">// 会造成浏览器阻塞</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0xA00000</span>;i&lt;<span class=\"number\">0xFFFFFF</span>;i++) &#123;</div><div class=\"line\">  div.style.backgroundColor = <span class=\"string\">'#'</span>+i.toString(<span class=\"number\">16</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 分割成小的任务</span></div><div class=\"line\"><span class=\"keyword\">var</span> timer;</div><div class=\"line\"><span class=\"keyword\">var</span> i=<span class=\"number\">0x100000</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  timer = setTimeout(func, <span class=\"number\">0</span>);</div><div class=\"line\">  div.style.backgroundColor = <span class=\"string\">'#'</span>+i.toString(<span class=\"number\">16</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span> (i++ == <span class=\"number\">0xFFFFFF</span>) clearInterval(timer);</div><div class=\"line\">&#125;</div><div class=\"line\">timer = setTimeout(func, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"定时器的其它应用\"><a href=\"#定时器的其它应用\" class=\"headerlink\" title=\"定时器的其它应用\"></a>定时器的其它应用</h3><p>这里就是说函数节流(throttle)与函数防抖(debounce)</p>\n<p>以 Underscore.js 中 debounce 的实现为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</div><div class=\"line\"> *</div><div class=\"line\"> * @param  &#123;function&#125; func        传入函数</div><div class=\"line\"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</div><div class=\"line\"> * @param  &#123;boolean&#125;  immediate   设置为ture时，调用触发于开始边界而不是结束边界</div><div class=\"line\"> * @return &#123;function&#125;             返回调用函数</div><div class=\"line\"> */</div><div class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 设置 last 为当前时间与上次触发的时间间隔</span></div><div class=\"line\">    <span class=\"keyword\">var</span> last = _.now() - timestamp;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果时间间隔小于所传入的 wait</span></div><div class=\"line\">      <span class=\"comment\">// 还没到触发时间，继续设置定时器</span></div><div class=\"line\">      timeout = setTimeout(later, wait - last);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 到了触发时间，清空计时器，避免影响下次触发</span></div><div class=\"line\">      timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">      <span class=\"comment\">// 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!immediate) &#123;</div><div class=\"line\">        <span class=\"comment\">// 执行 func</span></div><div class=\"line\">        result = func.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">    <span class=\"comment\">// 每次触发之后 更新时间戳为此次触发时间</span></div><div class=\"line\">    timestamp = _.now();</div><div class=\"line\">    <span class=\"comment\">// 判断是否符合立即触发的条件</span></div><div class=\"line\">    <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</div><div class=\"line\">    <span class=\"comment\">// 如果延时不存在，重新设定延时</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!timeout) timeout = setTimeout(later, wait);</div><div class=\"line\">    <span class=\"keyword\">if</span> (callNow) &#123;</div><div class=\"line\">      <span class=\"comment\">// 立即触发</span></div><div class=\"line\">      result = func.apply(context, args);</div><div class=\"line\">      context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>需要注意的是，<strong>管理多个定时器会产生许多问题，同时创建大量的定时器将会在浏览器中增加垃圾回收任务发生的可能性</strong>。</p>\n<p>定时器是一个特殊的垃圾回收问题，这是由于它们是在 JavaScript 主线程之外的浏览器线程进行管理的。不同浏览器垃圾回收的周期不同，这也是通过定时器处理动画时，动画在有的浏览器上很流畅，有的浏览器上特别卡的原因之一。因此应该注意减少同时使用的定时器的数量或者使用中央定时器来管理多个回调。</p>\n<h3 id=\"几个后续值得探究的问题\"><a href=\"#几个后续值得探究的问题\" class=\"headerlink\" title=\"几个后续值得探究的问题\"></a>几个后续值得探究的问题</h3><ul>\n<li>HTML5 Web Workers: HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中</li>\n<li>requestAnimationFrame: 更适合动画使用的“定时循环器”</li>\n<li>setImmediate: 一个比较新的定时器，setTimeout(0)的替代版</li>\n<li>Node.js 中的 Event Loop</li>\n</ul>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=669s\" target=\"_blank\" rel=\"external\">Philip Roberts: What the heck is the event loop anyway</a></p>\n</li>\n<li><p><a href=\"https://johnresig.com/blog/how-javascript-timers-work/\" target=\"_blank\" rel=\"external\">John Resig: How JavaScript Timers Work</a></p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/\" target=\"_blank\" rel=\"external\">AlloyTeam: 从 setTimeout 说起事件循环</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop\" target=\"_blank\" rel=\"external\">阮一峰: JavaScript 运行机制详解——再谈Event Loop</a></p>\n</li>\n</ul>\n","excerpt":"<p><img src=\"/images/jstips-animation.gif\" alt=\"cover\"></p>\n<h3 id=\"几个可能不知道的定时器⏲特性\"><a href=\"#几个可能不知道的定时器⏲特性\" class=\"headerlink\" title=\"几个可能不知道的定时器⏲特性\"></a>几个可能不知道的定时器⏲特性</h3><p>首先，<strong>setTimeout()/setInterval()</strong> 方法不是 ECMAScript 规范定义的内容，而是属于 BOM 提供的功能，也就是说定时器作为 BOM 对象和方法的一部分才能在浏览器中使用。</p>\n<p>需要注意的是 <strong>setTimeout() 与 setInterval() 在触发周期的定义上完全不一样</strong>，在下面例子 setTimeout() 代码中，要在前一个 callback 回调执行结束并延迟 10ms 以后才能再次执行 setTimeout()，即延迟是要求运行时(runtime) 处理请求所需的最小时间，但不是有所保证的时间。而 setInterval() 则是每隔 10ms 就执行一次 callback 回调，不会关注 callback 何时执行结束。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于触发周期定义不同，以下两个定时器有非常大的区别</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个 timeout 定时器，每10毫秒重新调用自己</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeatMe</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">  setTimeout(repeatMe, <span class=\"number\">10</span>);</div><div class=\"line\">&#125;, <span class=\"number\">10</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个 interval 定时器，每10毫秒触发一次</span></div><div class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;, <span class=\"number\">10</span>)</div></pre></td></tr></table></figure>\n<p>除此之外，在 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#timers\">HTML spec</a> 中定义 <strong>setTimeout 的最小延迟时间是4ms</strong>，但通常认为浏览器可实现的定时器的最小延迟时间是10ms，即 setTimeout(fn, 0) 也是会延迟至少10ms，如果想实现 0 delay 的话可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\">window.postMessage</a> 实现。</p>\n<p>定时器还有一个小特性，在开发移动公告的滚动动画时发现，从动画所在的 tab 页切换到别的 tab 之后再切回，动画会完全乱掉，并不会按代码中所设置的延迟时间进行。这是为了减少背景 tab 页面的代码运行消耗（电量），<strong>背景 tab 页面中定时器的间隔会增加到1000ms</strong>，如果遇到需要解决这个问题的场景，可以通过 <a href=\"https://robertnyman.com/2010/03/25/using-html5-web-workers-to-have-background-computational-power/\">HTML5 Web Workers</a> 或者用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\">requestAnimationFrame</a> 代替定时器来解决。</p>\n<p>最后，由于 webkit 中 timer 类的实现原理决定：<strong>预期延时时间最小的任务最先被执行，同时，预期延时时间相同的两个任务，其执行顺序是按照注册的先后顺序执行。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn1'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">20</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn2'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">30</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'another fn2'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">30</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn3'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start while'</span>);</div><div class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span> - start &lt; <span class=\"number\">1000</span>) &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end while'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 打印结果如下</span></div><div class=\"line\"><span class=\"comment\">// start while</span></div><div class=\"line\"><span class=\"comment\">// end while</span></div><div class=\"line\"><span class=\"comment\">// fn3</span></div><div class=\"line\"><span class=\"comment\">// fn1</span></div><div class=\"line\"><span class=\"comment\">// fn2</span></div><div class=\"line\"><span class=\"comment\">// another fn2</span></div></pre></td></tr></table></figure>\n<h3 id=\"Event-Loop-相关概念\"><a href=\"#Event-Loop-相关概念\" class=\"headerlink\" title=\"Event Loop 相关概念\"></a>Event Loop 相关概念</h3><p>浏览器让一个单线程共用于解释和执行 JavaScript，我们可以将它称为是“主线程”。其它的处理AJAX请求的线程、处理DOM事件的线程、定时器线程等等可以称为是“工作线程”。</p>\n<p>JavaScript 的单线程意味着只有一个 call stack，也意味着同一时间是能做一件事。</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/v2-25076e938167ad11c6a2a9ec099e0973_b.png\" alt=\"Event Loop\"></p>\n<ul>\n<li><p>调用栈(call stack): 后进先出，函数被调用时会被加入到调用栈顶部，等执行结束再从顶部移除。</p>\n</li>\n<li><p>堆(heap): 内存分配区</p>\n</li>\n<li><p>消息队列(quene): 也叫任务队列。先进先出，一旦调用栈中的所有任务执行完毕，栈清空，就会读取消息队列。<strong>消息/任务就是注册异步任务时添加的回调函数</strong>。</p>\n</li>\n<li><p>同步任务: 在主线程的调用栈排队执行的任务。</p>\n</li>\n<li><p>异步任务: 主线程发起执行异步函数的请求，对应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到消息队列，主线程通过事件循环过程去取消息，然后执行回调。</p>\n</li>\n<li><p>事件循环(event loop): 事件循环是指主线程重复从消息队列中取消息、执行的过程。<strong><br>取一个消息并执行的过程叫做一次循环</strong>。</p>\n</li>\n<li><p>Web APIs: 如 AJAX，定时器，DOM事件这些异步事务并不在 V8(JavaScript)运行环境中，是由浏览器提供的 Web API</p>\n</li>\n</ul>\n<p>相关概念就是这些，<a href=\"http://latentflip.com/loupe/\">http://latentflip.com/loupe/</a> 是一个可视化调用栈的网站，可以把自己的代码敲到里面运行来看 event loop 的具体动态。</p>\n<h3 id=\"定时器和线程是如何工作的\"><a href=\"#定时器和线程是如何工作的\" class=\"headerlink\" title=\"定时器和线程是如何工作的\"></a>定时器和线程是如何工作的</h3><p><img src=\"https://johnresig.com/files/Timers.png\" alt=\"timer\"></p>\n<p>以此图为例，来理解 JavaScript 中异步事件的执行。</p>\n<blockquote>\n<p>0ms: 启动即执行第一段 JavaScript 代码块，启动一个10ms延迟定时器(timeout)和10ms间隔定时器(interval)，延迟定时器是先于间隔定时器声明启动的。</p>\n<p>5ms: 鼠标单击，但是由于现在正在执行第一个代码块，调用栈不为空，单击事件的处理函数不能立即执行，只能在消息队列中进行排队</p>\n<p>10ms: 延迟定时器触发，间隔定时器触发，同理也都进行排队</p>\n<p>18ms: 第一段代码块执行结束，调用栈为空，此时有三个代码块在排队执行(click 事件处理函数，延迟定时器处理函数，间隔定时器第一次触发的处理函数)，按顺序此时主线程中执行 click 事件回调。消息队列中此时还有两个回调。</p>\n<p>20ms: 间隔定时器又触发了，由于间隔定时器第一次触发的处理函数仍在排队，浏览器不会对同一 interval 处理函数的多个实例同时进行排队，于是此次调用作废，消息队列不变，仍然还是那两个回调。</p>\n<p>28ms: click 事件回调函数执行完毕，按顺序，此时主线程中将执行延时定时器处理函数。消息队列中只有间隔定时器的第一次触发回调在排队。</p>\n<p>30ms: 间隔定时器再一次触发了，仍然因为第一次触发的回调仍在排队，此次调用作废。</p>\n<p>34ms: 延时定时器回调函数执行完毕。开始执行间隔定时器第一次触发的回调函数。此时消息队列为空。</p>\n<p>40ms: 间隔定时器再一次触发了，导致新的 interval 回调函数进入消息队列中排队。</p>\n<p>42ms: 间隔定时器第一次回调函数执行完毕，正在排队的回调开始执行。消息队列再次为空。</p>\n<p>47ms: 回调执行完毕，此时还没有到触发 interval 的时间，因此下一个 interval 回调可以等到触发事件立即执行。</p>\n</blockquote>\n<p>由此，我们可以知道：</p>\n<ul>\n<li>如果无法立即执行定时器，该定时器会被推迟到下一个可用的执行时间点上(验证了实际延迟时间必然会比指定的延迟时间更长)</li>\n<li>同一个 interval 执行程序的多个实例不能同时进行排队</li>\n<li>延迟时间足够长的话，很有可能会有两个 interval 回调会无延迟连续执行</li>\n</ul>\n<h3 id=\"setTimeout-fn-0\"><a href=\"#setTimeout-fn-0\" class=\"headerlink\" title=\"setTimeout(fn, 0)\"></a>setTimeout(fn, 0)</h3><p>由上述内容可知，setTimeout(fn, 0) 中的代码并不是为了 fn 立即执行，而是将 fn 插入到消息队列，使得待调用栈为空时将立即调用执行 fn，保证了 fn 的后执行。因此我们可以通过这一特性，<strong>用 setTimeout(fn, 0) 调整事件的发生顺序</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> input = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'input[type=button]'</span>)[<span class=\"number\">0</span>];</div><div class=\"line\">input.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    input.value +=<span class=\"string\">' input'</span>;</div><div class=\"line\">  &#125;, <span class=\"number\">0</span>)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  input.value += <span class=\"string\">' body'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 模拟事件捕获，实现父元素的事件回调函数先发生</span></div></pre></td></tr></table></figure>\n<p>在《高性能JavaScript》中认为 <strong>单个 JavaScript 操作花费的总时间不应该超过100毫秒</strong>。否则用户会感到与界面失去联系。实际上，如果一段 js 代码的运行时间超过 500ms，Firefox 和 Opera 浏览器将弹出警告对话框，Safari 会默认终止运行时间超过500 ms 的脚本。因此我们需要定时器将计算量大耗时长的任务分割成不会让浏览器挂掉的碎片。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'div'</span>)[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"comment\">// 会造成浏览器阻塞</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0xA00000</span>;i&lt;<span class=\"number\">0xFFFFFF</span>;i++) &#123;</div><div class=\"line\">  div.style.backgroundColor = <span class=\"string\">'#'</span>+i.toString(<span class=\"number\">16</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 分割成小的任务</span></div><div class=\"line\"><span class=\"keyword\">var</span> timer;</div><div class=\"line\"><span class=\"keyword\">var</span> i=<span class=\"number\">0x100000</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  timer = setTimeout(func, <span class=\"number\">0</span>);</div><div class=\"line\">  div.style.backgroundColor = <span class=\"string\">'#'</span>+i.toString(<span class=\"number\">16</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span> (i++ == <span class=\"number\">0xFFFFFF</span>) clearInterval(timer);</div><div class=\"line\">&#125;</div><div class=\"line\">timer = setTimeout(func, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"定时器的其它应用\"><a href=\"#定时器的其它应用\" class=\"headerlink\" title=\"定时器的其它应用\"></a>定时器的其它应用</h3><p>这里就是说函数节流(throttle)与函数防抖(debounce)</p>\n<p>以 Underscore.js 中 debounce 的实现为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</div><div class=\"line\"> *</div><div class=\"line\"> * @param  &#123;function&#125; func        传入函数</div><div class=\"line\"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</div><div class=\"line\"> * @param  &#123;boolean&#125;  immediate   设置为ture时，调用触发于开始边界而不是结束边界</div><div class=\"line\"> * @return &#123;function&#125;             返回调用函数</div><div class=\"line\"> */</span></div><div class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 设置 last 为当前时间与上次触发的时间间隔</span></div><div class=\"line\">    <span class=\"keyword\">var</span> last = _.now() - timestamp;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果时间间隔小于所传入的 wait</span></div><div class=\"line\">      <span class=\"comment\">// 还没到触发时间，继续设置定时器</span></div><div class=\"line\">      timeout = setTimeout(later, wait - last);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 到了触发时间，清空计时器，避免影响下次触发</span></div><div class=\"line\">      timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">      <span class=\"comment\">// 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!immediate) &#123;</div><div class=\"line\">        <span class=\"comment\">// 执行 func</span></div><div class=\"line\">        result = func.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">    <span class=\"comment\">// 每次触发之后 更新时间戳为此次触发时间</span></div><div class=\"line\">    timestamp = _.now();</div><div class=\"line\">    <span class=\"comment\">// 判断是否符合立即触发的条件</span></div><div class=\"line\">    <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</div><div class=\"line\">    <span class=\"comment\">// 如果延时不存在，重新设定延时</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!timeout) timeout = setTimeout(later, wait);</div><div class=\"line\">    <span class=\"keyword\">if</span> (callNow) &#123;</div><div class=\"line\">      <span class=\"comment\">// 立即触发</span></div><div class=\"line\">      result = func.apply(context, args);</div><div class=\"line\">      context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>需要注意的是，<strong>管理多个定时器会产生许多问题，同时创建大量的定时器将会在浏览器中增加垃圾回收任务发生的可能性</strong>。</p>\n<p>定时器是一个特殊的垃圾回收问题，这是由于它们是在 JavaScript 主线程之外的浏览器线程进行管理的。不同浏览器垃圾回收的周期不同，这也是通过定时器处理动画时，动画在有的浏览器上很流畅，有的浏览器上特别卡的原因之一。因此应该注意减少同时使用的定时器的数量或者使用中央定时器来管理多个回调。</p>\n<h3 id=\"几个后续值得探究的问题\"><a href=\"#几个后续值得探究的问题\" class=\"headerlink\" title=\"几个后续值得探究的问题\"></a>几个后续值得探究的问题</h3><ul>\n<li>HTML5 Web Workers: HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中</li>\n<li>requestAnimationFrame: 更适合动画使用的“定时循环器”</li>\n<li>setImmediate: 一个比较新的定时器，setTimeout(0)的替代版</li>\n<li>Node.js 中的 Event Loop</li>\n</ul>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=669s\">Philip Roberts: What the heck is the event loop anyway</a></p>\n</li>\n<li><p><a href=\"https://johnresig.com/blog/how-javascript-timers-work/\">John Resig: How JavaScript Timers Work</a></p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/\">AlloyTeam: 从 setTimeout 说起事件循环</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop\">阮一峰: JavaScript 运行机制详解——再谈Event Loop</a></p>\n</li>\n</ul>"},{"layout":"post","title":"避免脏pr：使用git rebase避免无谓的merge","date":"2016-06-09T03:51:00.000Z","_content":"\n### 问题复现与解决\n\n在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:\n\n![commit history](http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg)\n\n事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。\n\n想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。\n\n<!--more-->\n\n```\ngit fetch origin master\n# git merge origin/master # 不要这么干\ngit rebase origin/master\n```\n\n```\n# git pull origin master # 不要这么干\ngit pull --rebase\n```\n\n主要是因为`git pull`这一git命令实际执行了`git fetch`和`git merge FETCH_HEAD`两条指令。因此不要直接使用`git pull`来更新代码。`git pull --rebase `指令的意思是：\n\n1. 把本地repo自从上次pull之后的变更暂存起来\n2. 回到上次pull时的情况\n3. 套用远端的变更\n4. 套用第一步中暂存的本地变更\n\n### 关于git rebase\n`git rebase`和`git merge`做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。\n假设合并前是这样：\n\n>D---E master\n     /\nA---B---C---F origin/master\n\n使用merge合并后：\n\n>D--------E  \n     /          \\\nA---B---C---F----G   master, origin/master\n\n适应rebase合并后：\n\n>A---B---C---F---D'---E'   master, origin/master\n\n由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。\n\n### A rebase-based workflow\n1.新建分支\n\n> git checkout master\n  git pull    #更新master\n  git checkout master -b test   #从master创建feature分支\n  git push -u origin test:test\n  \\#把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支\n\n2.更新分支\n\n从master更新\n\n> git pull --rebase origin master #此方法不会更新本地master分支\n\n从test更新\n\n> git pull --rebase #需先设置追踪分支\n\n3.完成后回到主分支\n\n> git checkout master\n  git pull     #这里不会导致出现merge commit\n  git rebase test     #把commits拉取到主分支\n  git push\n\n### 处理脏pr\n这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。\n\n> git fetch origin master:new-feature\n  git checkout new-feature\n  git cherry-pick COMMIT_HASH_1\n  git cherry-pick COMMIT_HASH_2\n  ...\n  git cherry-pick COMMIT_HASH_N\n  \ncherry-pick命令\"复制\"一个提交节点并在当前分支做一次完全一样的新提交。\n注意cherry-pick的顺序应是commit **从旧到新** 的顺序，否则会一直出现无数冲突。\n\n### 参考内容\n* [RandyFay:A Rebase Workflow for Git](https://randyfay.com/node/91)\n* [stackoverflow:When do you use git rebase instead of git merge?](http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge)\n* [stackoverflow:git workflow and rebase vs merge questions](http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions)\n* [git-recipes:代码合并:Merge、Rebase的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n* [WEB研究所:git 实践之避免 merge](https://www.web-tinker.com/article/21112.html)\n\n\n\n\n\n\n\n","source":"_posts/git-rebase-workflow.md","raw":"---\nlayout: post\ntitle:  \"避免脏pr：使用git rebase避免无谓的merge\"\ndate:   2016-06-09 11:51\ncategories: git\n---\n\n### 问题复现与解决\n\n在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:\n\n![commit history](http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg)\n\n事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。\n\n想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。\n\n<!--more-->\n\n```\ngit fetch origin master\n# git merge origin/master # 不要这么干\ngit rebase origin/master\n```\n\n```\n# git pull origin master # 不要这么干\ngit pull --rebase\n```\n\n主要是因为`git pull`这一git命令实际执行了`git fetch`和`git merge FETCH_HEAD`两条指令。因此不要直接使用`git pull`来更新代码。`git pull --rebase `指令的意思是：\n\n1. 把本地repo自从上次pull之后的变更暂存起来\n2. 回到上次pull时的情况\n3. 套用远端的变更\n4. 套用第一步中暂存的本地变更\n\n### 关于git rebase\n`git rebase`和`git merge`做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。\n假设合并前是这样：\n\n>D---E master\n     /\nA---B---C---F origin/master\n\n使用merge合并后：\n\n>D--------E  \n     /          \\\nA---B---C---F----G   master, origin/master\n\n适应rebase合并后：\n\n>A---B---C---F---D'---E'   master, origin/master\n\n由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。\n\n### A rebase-based workflow\n1.新建分支\n\n> git checkout master\n  git pull    #更新master\n  git checkout master -b test   #从master创建feature分支\n  git push -u origin test:test\n  \\#把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支\n\n2.更新分支\n\n从master更新\n\n> git pull --rebase origin master #此方法不会更新本地master分支\n\n从test更新\n\n> git pull --rebase #需先设置追踪分支\n\n3.完成后回到主分支\n\n> git checkout master\n  git pull     #这里不会导致出现merge commit\n  git rebase test     #把commits拉取到主分支\n  git push\n\n### 处理脏pr\n这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。\n\n> git fetch origin master:new-feature\n  git checkout new-feature\n  git cherry-pick COMMIT_HASH_1\n  git cherry-pick COMMIT_HASH_2\n  ...\n  git cherry-pick COMMIT_HASH_N\n  \ncherry-pick命令\"复制\"一个提交节点并在当前分支做一次完全一样的新提交。\n注意cherry-pick的顺序应是commit **从旧到新** 的顺序，否则会一直出现无数冲突。\n\n### 参考内容\n* [RandyFay:A Rebase Workflow for Git](https://randyfay.com/node/91)\n* [stackoverflow:When do you use git rebase instead of git merge?](http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge)\n* [stackoverflow:git workflow and rebase vs merge questions](http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions)\n* [git-recipes:代码合并:Merge、Rebase的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n* [WEB研究所:git 实践之避免 merge](https://www.web-tinker.com/article/21112.html)\n\n\n\n\n\n\n\n","slug":"git-rebase-workflow","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyix000egbeh6m2rdqbd","content":"<h3 id=\"问题复现与解决\"><a href=\"#问题复现与解决\" class=\"headerlink\" title=\"问题复现与解决\"></a>问题复现与解决</h3><p>在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg\" alt=\"commit history\"></p>\n<p>事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。</p>\n<p>想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git fetch origin master</div><div class=\"line\"># git merge origin/master # 不要这么干</div><div class=\"line\">git rebase origin/master</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># git pull origin master # 不要这么干</div><div class=\"line\">git pull --rebase</div></pre></td></tr></table></figure>\n<p>主要是因为<code>git pull</code>这一git命令实际执行了<code>git fetch</code>和<code>git merge FETCH_HEAD</code>两条指令。因此不要直接使用<code>git pull</code>来更新代码。<code>git pull --rebase</code>指令的意思是：</p>\n<ol>\n<li>把本地repo自从上次pull之后的变更暂存起来</li>\n<li>回到上次pull时的情况</li>\n<li>套用远端的变更</li>\n<li>套用第一步中暂存的本地变更</li>\n</ol>\n<h3 id=\"关于git-rebase\"><a href=\"#关于git-rebase\" class=\"headerlink\" title=\"关于git rebase\"></a>关于git rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。<br>假设合并前是这样：</p>\n<blockquote>\n<p>D—E master<br>     /<br>A—B—C—F origin/master</p>\n</blockquote>\n<p>使用merge合并后：</p>\n<blockquote>\n<p>D——–E<br>     /          \\<br>A—B—C—F—-G   master, origin/master</p>\n</blockquote>\n<p>适应rebase合并后：</p>\n<blockquote>\n<p>A—B—C—F—D’—E’   master, origin/master</p>\n</blockquote>\n<p>由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。</p>\n<h3 id=\"A-rebase-based-workflow\"><a href=\"#A-rebase-based-workflow\" class=\"headerlink\" title=\"A rebase-based workflow\"></a>A rebase-based workflow</h3><p>1.新建分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull    #更新master<br>  git checkout master -b test   #从master创建feature分支<br>  git push -u origin test:test<br>  #把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支</p>\n</blockquote>\n<p>2.更新分支</p>\n<p>从master更新</p>\n<blockquote>\n<p>git pull –rebase origin master #此方法不会更新本地master分支</p>\n</blockquote>\n<p>从test更新</p>\n<blockquote>\n<p>git pull –rebase #需先设置追踪分支</p>\n</blockquote>\n<p>3.完成后回到主分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull     #这里不会导致出现merge commit<br>  git rebase test     #把commits拉取到主分支<br>  git push</p>\n</blockquote>\n<h3 id=\"处理脏pr\"><a href=\"#处理脏pr\" class=\"headerlink\" title=\"处理脏pr\"></a>处理脏pr</h3><p>这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。</p>\n<blockquote>\n<p>git fetch origin master:new-feature<br>  git checkout new-feature<br>  git cherry-pick COMMIT_HASH_1<br>  git cherry-pick COMMIT_HASH_2<br>  …<br>  git cherry-pick COMMIT_HASH_N</p>\n</blockquote>\n<p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br>注意cherry-pick的顺序应是commit <strong>从旧到新</strong> 的顺序，否则会一直出现无数冲突。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://randyfay.com/node/91\" target=\"_blank\" rel=\"external\">RandyFay:A Rebase Workflow for Git</a></li>\n<li><a href=\"http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge\" target=\"_blank\" rel=\"external\">stackoverflow:When do you use git rebase instead of git merge?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions\" target=\"_blank\" rel=\"external\">stackoverflow:git workflow and rebase vs merge questions</a></li>\n<li><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\" target=\"_blank\" rel=\"external\">git-recipes:代码合并:Merge、Rebase的选择</a></li>\n<li><a href=\"https://www.web-tinker.com/article/21112.html\" target=\"_blank\" rel=\"external\">WEB研究所:git 实践之避免 merge</a></li>\n</ul>\n","excerpt":"<h3 id=\"问题复现与解决\"><a href=\"#问题复现与解决\" class=\"headerlink\" title=\"问题复现与解决\"></a>问题复现与解决</h3><p>在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg\" alt=\"commit history\"></p>\n<p>事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。</p>\n<p>想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git fetch origin master</div><div class=\"line\"># git merge origin/master # 不要这么干</div><div class=\"line\">git rebase origin/master</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># git pull origin master # 不要这么干</div><div class=\"line\">git pull --rebase</div></pre></td></tr></table></figure>\n<p>主要是因为<code>git pull</code>这一git命令实际执行了<code>git fetch</code>和<code>git merge FETCH_HEAD</code>两条指令。因此不要直接使用<code>git pull</code>来更新代码。<code>git pull --rebase</code>指令的意思是：</p>\n<ol>\n<li>把本地repo自从上次pull之后的变更暂存起来</li>\n<li>回到上次pull时的情况</li>\n<li>套用远端的变更</li>\n<li>套用第一步中暂存的本地变更</li>\n</ol>\n<h3 id=\"关于git-rebase\"><a href=\"#关于git-rebase\" class=\"headerlink\" title=\"关于git rebase\"></a>关于git rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事是一样的，都是把一个分支合并到另一个分支，只是方式不同，我们应该在不同情况下做出更合理的选择。我们做一下对比。<br>假设合并前是这样：</p>\n<blockquote>\n<p>D—E master<br>     /<br>A—B—C—F origin/master</p>\n</blockquote>\n<p>使用merge合并后：</p>\n<blockquote>\n<p>D——–E<br>     /          \\<br>A—B—C—F—-G   master, origin/master</p>\n</blockquote>\n<p>适应rebase合并后：</p>\n<blockquote>\n<p>A—B—C—F—D’—E’   master, origin/master</p>\n</blockquote>\n<p>由此可见，使用rebase其实是重写了提交记录，并使我们的项目历史会非常整洁，它不想git merge那样引入不必要的合并提交，rebase使得项目历史呈线性，便于通过git log查看项目历史。</p>\n<h3 id=\"A-rebase-based-workflow\"><a href=\"#A-rebase-based-workflow\" class=\"headerlink\" title=\"A rebase-based workflow\"></a>A rebase-based workflow</h3><p>1.新建分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull    #更新master<br>  git checkout master -b test   #从master创建feature分支<br>  git push -u origin test:test<br>  #把分支push到远程，本地分支名在前，-u是–set-upstream-to 的简写，设置追踪分支</p>\n</blockquote>\n<p>2.更新分支</p>\n<p>从master更新</p>\n<blockquote>\n<p>git pull –rebase origin master #此方法不会更新本地master分支</p>\n</blockquote>\n<p>从test更新</p>\n<blockquote>\n<p>git pull –rebase #需先设置追踪分支</p>\n</blockquote>\n<p>3.完成后回到主分支</p>\n<blockquote>\n<p>git checkout master<br>  git pull     #这里不会导致出现merge commit<br>  git rebase test     #把commits拉取到主分支<br>  git push</p>\n</blockquote>\n<h3 id=\"处理脏pr\"><a href=\"#处理脏pr\" class=\"headerlink\" title=\"处理脏pr\"></a>处理脏pr</h3><p>这里只介绍一个比较好理解的方法，从主分支上新建一个干净的分支，然后把需要搞干净的pr中所有非merge的commit都cherry-pick到新分支。</p>\n<blockquote>\n<p>git fetch origin master:new-feature<br>  git checkout new-feature<br>  git cherry-pick COMMIT_HASH_1<br>  git cherry-pick COMMIT_HASH_2<br>  …<br>  git cherry-pick COMMIT_HASH_N</p>\n</blockquote>\n<p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br>注意cherry-pick的顺序应是commit <strong>从旧到新</strong> 的顺序，否则会一直出现无数冲突。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://randyfay.com/node/91\">RandyFay:A Rebase Workflow for Git</a></li>\n<li><a href=\"http://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge\">stackoverflow:When do you use git rebase instead of git merge?</a></li>\n<li><a href=\"http://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions\">stackoverflow:git workflow and rebase vs merge questions</a></li>\n<li><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\">git-recipes:代码合并:Merge、Rebase的选择</a></li>\n<li><a href=\"https://www.web-tinker.com/article/21112.html\">WEB研究所:git 实践之避免 merge</a></li>\n</ul>"},{"layout":"post","title":"阅读《高性能JavaScript》(上)","date":"2016-09-26T15:22:00.000Z","_content":"\n![cover](https://img1.doubanio.com/lpic/s28879959.jpg)\n\n这篇只包含前四章节。\n\n## 1.加载与执行\n\n浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。\n\n减少脚本执行对性能影响的方法：\n\n- 把所有 `<script>` 标签尽可能放到 `<body>` 标签底部。\n- 合并脚本，减少HTTP请求带来的额外性能开销。\n- 无阻塞下载执行JavaScript脚本：\n  - `<script>` 的 `defer` 属性可以使脚本下载后先不执行，老版本浏览器不支持\n  - 书中未提到的 HTML5 `async` 属性可以使脚本异步加载执行\n  - 使用XHR对象动态加载脚本\n\n<!--more-->\n\n![js-load](http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/image003.jpg)\n\n这部分的知识是刚接触JavaScript时就看过的，[IBM开发者的文章](http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html)介绍的很详尽。\n\n---------------------------------------\n\n## 2.数据存取\n\n本章主要讲通过改变数据的存取位置来提高读写性能，其中又详细讲解了作用域链，原型链的工作原理，干货不少。\n\n首先要了解，一共有四种基本的数据存取位置：字面量，本地（局部）变量，数组元素，对象成员。其中字面量和局部变量的存取很快，数组元素和对象成员相对较慢，尤其是在老版本浏览器。\n\n#### 作用域与作用域链\n\n每一个JavaScript函数都可以表示为一个对象，Function对象既有可编程访问的属性，又有**仅供JavaScript引擎存取的内部属性**，其中一个内部属性是`[[scope]]`。\n\n作用域链是`[[scope]]`所包含的函数被创建的作用域中对象的集合，作用域链决定了哪些数据可被函数访问以及查找数据的顺序。\n\n1. 执行函数时会创建一个 `execution context 执行上下文` ，它是一个内部对象，函数每次执行时对应的执行上下文都是不一样的。函数执行完毕，执行上下文就被销毁。\n2. `执行上下文` 被创建时，它的作用域链就初始为执行函数的 `[[scope]]` 属性中的对象。这些值按顺序被复制到作用域链中，这一过程完成，即创建好了“活动对象”。\n3. 活动对象是函数运行时的变量对象，包含所有局部变量，命名参数集合以及 `this`。然后活动对象会被推入作用域链的最前端。\n\n在函数执行过程中，每遇到一个变量都会在搜索其作用域链，从头部（即活动对象）搜索直到找到标识符，**正是这个搜索过程影响了性能**。\n\n在执行环境的作用域链中，一个标识符所在的位置越深，读写速度越慢。所以**读写局部变量最快，全局变量最慢。全局变量总是在作用域链的最末端**。\n\n**经验：如果一个跨作用域的值在函数中被引用一次以上，那就把它存储在局部变量里。**\n\n#### 两种改变作用域链的情况\n\n有两个语句可以在执行时*临时*改变作用域链：`with语句`与`try-catch中的catch子句`。\n\n`with语句` 有性能问题，应避免使用。它是创建了一个包含参数制定对象属性的新对象，并把它推入作用域链最前端，使得局部变量位置变深读写变慢。\n\n`try-catch的catch子句`在执行中是把捕捉到的错误对象推入作用域链首位，也会造成同上的性能问题。解决办法是，在子句中把错误委托给一个函数来处理：\n\n```javascript\ntry {\n  methodThatMightCauseAnError()\n} catch (e) {\n  handle(e)  // 委托给错误处理函数\n}\n```\n\n#### 闭包，作用域与内存\n\n有了先前理论的了解，我们就可以理解一下与闭包有关的性能问题。\n\n```javascript\nfunction assignEvents () {\n  var id = 'xdi9952'\n  document.getElementById('save-btn').onclick = function (event) {\n    saveDocument(id)\n  }\n}\n```\n\n![clourse](http://hi.csdn.net/attachment/201005/28/0_1275041109tO2h.gif)\n\n闭包函数在执行时，它的作用域链与属性 `[[scope]]` 中所引用的两个相同的作用域链对象一起被初始化，作用域链首位是闭包函数的活动对象，然后是外部函数的活动对象，最后是全局对象。闭包函数执行时用到的`id`和`saveDocument`在作用域链第一位之后，这就是使用闭包需要关注的性能点。\n\n#### 对象成员，原型与原型链\n\n前文提到的，**访问对象成员的速度慢于访问字面量和局部变量** ，原因是什么？\n\n脚本引擎在读取对象属性时，也会按顺序检索。具体可参考[这篇博文](www.cnblogs.com/snandy/archive/2012/09/01/2664134.html)。\n\n- - -\n\n## 3.DOM编程 生来缓慢，我很抱歉\n\nJS引擎和DOM引擎是分开的，所以脚本中对DOM的访问非常耗费性能。最坏的情况是在循环中访问或者修改DOM，此时应该把DOM缓存在局部变量中。\n\n#### HTML集合\n\n需要区分一下HTML集合和数组,使用jQuery选择器或者DOM节点引用的，返回的都是`HTML集合`：\n\n- `document.getElementById('one')`\n- `$('#one')`\n\n之前在lodash文档里也发现Collection和Array是分开的栏目，当时没当回事儿，现在想想其实是我压根就没有`HTML集合`的概念，HTML集合并不是数组，也没有数组可用的方法（etc.`slice()`），只是提供了length属性并且可通过数字索引来访问集合中的元素。\n\n**HTML集合是低效之源** ，集合是实时性的，一直保持着与文档的连接，任何操作和访问都会重复DOM操作。在相同的内容和数量下，遍历一个数组的速度明显快于遍历一个HTML集合。因此也更不应该遍历或循环HTML集合。如果非要进行这种操作的话，建议：\n- 不要在循环的条件控制语句中读取 length 属性（这个无论是集合还是数组都通用）\n- 把集合转为数组再操作\n  ```javascript\n  function toArray (coll) {\n    for (var i = 0, a = [], len = coll.length; i<len; i++) {\n      a[i] = coll[i]\n    }\n    return a\n  }\n  ```\n- 访问集合时使用局部变量，把length缓存在循环外部，把需要多次读取的元素存在局部变量中\n\n#### querySelectorAll()\n\n关于选择器API，建议使用 `document.querySelectorAll()` 的原生DOM方法来获取元素列表。\n\n与`getElementById`等api不同，`querySelectorAll()` 仅返回一个 NodeList 而非HTML集合，因此这些返回的节点集不会对应实时的文档结构，在遍历节点时可以比较放心地使用该方法。\n\n#### 重绘与重排\n\n[此博文：《网页性能管理详解》](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)中也详细介绍了关于浏览器重排与重绘相关的知识。\n\n调用一下方法时会 **强制浏览器刷新队列并触发重排** ：\n\n> offsetTop/offsetLeft/offsetWidth/offsetHeight\n> scrollTop/scrollLeft/scrollWidth/scrollHeight\n> clientTop/clientLeft/clientWidth/clientHeight\n> getComputedStyle()\n\n因此如果需要多次查询布局信息如`offsetTop`时，应把其缓存起来。\n\n减少重排的方法有三种，使元素脱离文档流(`display:none`)，在文档之外创建并更新一个文档片段并附加到原始列表(`document.createDocumentFragment`)，克隆节点(`cloneNode`)。\n\n比较推荐的是第二个方案，所产生的DOM遍历和重排次数最少：\n\n```javascript\nvar fragment = document.createDocumentFragment()\nappendDataToElement(fragment, data)\ndocument.getElementById('mylist').appendChild(fragment)\n```\n\n#### 事件委托\n\n每绑定一个事件处理器都是有代价的，要么加重了页面负担，要么增加了运行期的执行时间。所以我们需要使用事件委托来减少事件处理器的数量，而不是给每个元素都绑上事件处理器。\n\n关于事件委托也是一个坑，先参考一下[stackoverflow: What is DOM Event delegation](http://stackoverflow.com/questions/1687296/what-is-dom-event-delegation)，后续再参考高程研究一波。\n\n## 4.算法和流程控制\n\n也是很涨姿势的一章。\n\n#### 循环语句\n\nECMA-262 标准中一共有四种循环类型，`for循环`，`while循环`，`do-while循环`，`for-in循环`。前三种循环类型性能所差无几，只有`for-in`比其它几种明显要慢，**除了明确需要迭代一个属性数量未知的对象，否则应避免使用for-in循环** 。\n\n改善循环性能的切入点有两种：\n\n- 减少迭代工作量\n  - 减少对象成员及数组项的查找次数：如上一章所提到的，把数组的length存到局部变量中\n\n    ```javascript\n    for (var i=0, len=items.length; i < len; i++) {\n      process(items[i])\n    }\n    ```\n\n  - 采用倒序循环：在每次循环中减少了一次查找属性，减少了控制条件中的一次数值比较\n\n    ```javascript\n    for (var i=items.length;i--; ) {\n      process(items[i])\n    }\n    ```\n\n- 减少迭代次数\n  - 一个涨姿势的概念 [达夫设备（Duff's Device）](http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420163.html) 适合迭代次数超过1000的场景(虽然现在应该不会再引用这种方法，但是switch-case的思想可以借鉴)\n\n除了上述四种基本的循环类型，数组后续还引入了基于函数的迭代方法`forEach()`，但是在所有情况下，基于循环的迭代比基于函数的迭代快8倍。\n\n#### 条件语句\n\n`if-else`与`switch`比较之下，条件数量较小时使用`if-else`，较多时使用`switch`\n\n优化`if-else`的方法一是确保最可能出现的条件放在首位，二是把`if-else`组织成嵌套的`if-else`语句。\n\n#### 递归\n\n这里更涨姿势了，不过描述的内容和场景目前基本没遇到过，不会把那么大的数据量放在前端处理，用Node写服务器端的话可能会遇到。先记住这几个结论吧：\n\n> 浏览器的调用栈大小限制了递归算法在 JavaScript 中的应用，栈溢出错误会导致其它代码中断运行。\n> 如果遇到栈溢出错误，可以把方法改成迭代算法。\n","source":"_posts/high-performance-javascript-a.md","raw":"---\nlayout: post\ntitle:  \"阅读《高性能JavaScript》(上)\"\ndate:   2016-09-26 23:22\ncategories: javascript\n---\n\n![cover](https://img1.doubanio.com/lpic/s28879959.jpg)\n\n这篇只包含前四章节。\n\n## 1.加载与执行\n\n浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。\n\n减少脚本执行对性能影响的方法：\n\n- 把所有 `<script>` 标签尽可能放到 `<body>` 标签底部。\n- 合并脚本，减少HTTP请求带来的额外性能开销。\n- 无阻塞下载执行JavaScript脚本：\n  - `<script>` 的 `defer` 属性可以使脚本下载后先不执行，老版本浏览器不支持\n  - 书中未提到的 HTML5 `async` 属性可以使脚本异步加载执行\n  - 使用XHR对象动态加载脚本\n\n<!--more-->\n\n![js-load](http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/image003.jpg)\n\n这部分的知识是刚接触JavaScript时就看过的，[IBM开发者的文章](http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html)介绍的很详尽。\n\n---------------------------------------\n\n## 2.数据存取\n\n本章主要讲通过改变数据的存取位置来提高读写性能，其中又详细讲解了作用域链，原型链的工作原理，干货不少。\n\n首先要了解，一共有四种基本的数据存取位置：字面量，本地（局部）变量，数组元素，对象成员。其中字面量和局部变量的存取很快，数组元素和对象成员相对较慢，尤其是在老版本浏览器。\n\n#### 作用域与作用域链\n\n每一个JavaScript函数都可以表示为一个对象，Function对象既有可编程访问的属性，又有**仅供JavaScript引擎存取的内部属性**，其中一个内部属性是`[[scope]]`。\n\n作用域链是`[[scope]]`所包含的函数被创建的作用域中对象的集合，作用域链决定了哪些数据可被函数访问以及查找数据的顺序。\n\n1. 执行函数时会创建一个 `execution context 执行上下文` ，它是一个内部对象，函数每次执行时对应的执行上下文都是不一样的。函数执行完毕，执行上下文就被销毁。\n2. `执行上下文` 被创建时，它的作用域链就初始为执行函数的 `[[scope]]` 属性中的对象。这些值按顺序被复制到作用域链中，这一过程完成，即创建好了“活动对象”。\n3. 活动对象是函数运行时的变量对象，包含所有局部变量，命名参数集合以及 `this`。然后活动对象会被推入作用域链的最前端。\n\n在函数执行过程中，每遇到一个变量都会在搜索其作用域链，从头部（即活动对象）搜索直到找到标识符，**正是这个搜索过程影响了性能**。\n\n在执行环境的作用域链中，一个标识符所在的位置越深，读写速度越慢。所以**读写局部变量最快，全局变量最慢。全局变量总是在作用域链的最末端**。\n\n**经验：如果一个跨作用域的值在函数中被引用一次以上，那就把它存储在局部变量里。**\n\n#### 两种改变作用域链的情况\n\n有两个语句可以在执行时*临时*改变作用域链：`with语句`与`try-catch中的catch子句`。\n\n`with语句` 有性能问题，应避免使用。它是创建了一个包含参数制定对象属性的新对象，并把它推入作用域链最前端，使得局部变量位置变深读写变慢。\n\n`try-catch的catch子句`在执行中是把捕捉到的错误对象推入作用域链首位，也会造成同上的性能问题。解决办法是，在子句中把错误委托给一个函数来处理：\n\n```javascript\ntry {\n  methodThatMightCauseAnError()\n} catch (e) {\n  handle(e)  // 委托给错误处理函数\n}\n```\n\n#### 闭包，作用域与内存\n\n有了先前理论的了解，我们就可以理解一下与闭包有关的性能问题。\n\n```javascript\nfunction assignEvents () {\n  var id = 'xdi9952'\n  document.getElementById('save-btn').onclick = function (event) {\n    saveDocument(id)\n  }\n}\n```\n\n![clourse](http://hi.csdn.net/attachment/201005/28/0_1275041109tO2h.gif)\n\n闭包函数在执行时，它的作用域链与属性 `[[scope]]` 中所引用的两个相同的作用域链对象一起被初始化，作用域链首位是闭包函数的活动对象，然后是外部函数的活动对象，最后是全局对象。闭包函数执行时用到的`id`和`saveDocument`在作用域链第一位之后，这就是使用闭包需要关注的性能点。\n\n#### 对象成员，原型与原型链\n\n前文提到的，**访问对象成员的速度慢于访问字面量和局部变量** ，原因是什么？\n\n脚本引擎在读取对象属性时，也会按顺序检索。具体可参考[这篇博文](www.cnblogs.com/snandy/archive/2012/09/01/2664134.html)。\n\n- - -\n\n## 3.DOM编程 生来缓慢，我很抱歉\n\nJS引擎和DOM引擎是分开的，所以脚本中对DOM的访问非常耗费性能。最坏的情况是在循环中访问或者修改DOM，此时应该把DOM缓存在局部变量中。\n\n#### HTML集合\n\n需要区分一下HTML集合和数组,使用jQuery选择器或者DOM节点引用的，返回的都是`HTML集合`：\n\n- `document.getElementById('one')`\n- `$('#one')`\n\n之前在lodash文档里也发现Collection和Array是分开的栏目，当时没当回事儿，现在想想其实是我压根就没有`HTML集合`的概念，HTML集合并不是数组，也没有数组可用的方法（etc.`slice()`），只是提供了length属性并且可通过数字索引来访问集合中的元素。\n\n**HTML集合是低效之源** ，集合是实时性的，一直保持着与文档的连接，任何操作和访问都会重复DOM操作。在相同的内容和数量下，遍历一个数组的速度明显快于遍历一个HTML集合。因此也更不应该遍历或循环HTML集合。如果非要进行这种操作的话，建议：\n- 不要在循环的条件控制语句中读取 length 属性（这个无论是集合还是数组都通用）\n- 把集合转为数组再操作\n  ```javascript\n  function toArray (coll) {\n    for (var i = 0, a = [], len = coll.length; i<len; i++) {\n      a[i] = coll[i]\n    }\n    return a\n  }\n  ```\n- 访问集合时使用局部变量，把length缓存在循环外部，把需要多次读取的元素存在局部变量中\n\n#### querySelectorAll()\n\n关于选择器API，建议使用 `document.querySelectorAll()` 的原生DOM方法来获取元素列表。\n\n与`getElementById`等api不同，`querySelectorAll()` 仅返回一个 NodeList 而非HTML集合，因此这些返回的节点集不会对应实时的文档结构，在遍历节点时可以比较放心地使用该方法。\n\n#### 重绘与重排\n\n[此博文：《网页性能管理详解》](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)中也详细介绍了关于浏览器重排与重绘相关的知识。\n\n调用一下方法时会 **强制浏览器刷新队列并触发重排** ：\n\n> offsetTop/offsetLeft/offsetWidth/offsetHeight\n> scrollTop/scrollLeft/scrollWidth/scrollHeight\n> clientTop/clientLeft/clientWidth/clientHeight\n> getComputedStyle()\n\n因此如果需要多次查询布局信息如`offsetTop`时，应把其缓存起来。\n\n减少重排的方法有三种，使元素脱离文档流(`display:none`)，在文档之外创建并更新一个文档片段并附加到原始列表(`document.createDocumentFragment`)，克隆节点(`cloneNode`)。\n\n比较推荐的是第二个方案，所产生的DOM遍历和重排次数最少：\n\n```javascript\nvar fragment = document.createDocumentFragment()\nappendDataToElement(fragment, data)\ndocument.getElementById('mylist').appendChild(fragment)\n```\n\n#### 事件委托\n\n每绑定一个事件处理器都是有代价的，要么加重了页面负担，要么增加了运行期的执行时间。所以我们需要使用事件委托来减少事件处理器的数量，而不是给每个元素都绑上事件处理器。\n\n关于事件委托也是一个坑，先参考一下[stackoverflow: What is DOM Event delegation](http://stackoverflow.com/questions/1687296/what-is-dom-event-delegation)，后续再参考高程研究一波。\n\n## 4.算法和流程控制\n\n也是很涨姿势的一章。\n\n#### 循环语句\n\nECMA-262 标准中一共有四种循环类型，`for循环`，`while循环`，`do-while循环`，`for-in循环`。前三种循环类型性能所差无几，只有`for-in`比其它几种明显要慢，**除了明确需要迭代一个属性数量未知的对象，否则应避免使用for-in循环** 。\n\n改善循环性能的切入点有两种：\n\n- 减少迭代工作量\n  - 减少对象成员及数组项的查找次数：如上一章所提到的，把数组的length存到局部变量中\n\n    ```javascript\n    for (var i=0, len=items.length; i < len; i++) {\n      process(items[i])\n    }\n    ```\n\n  - 采用倒序循环：在每次循环中减少了一次查找属性，减少了控制条件中的一次数值比较\n\n    ```javascript\n    for (var i=items.length;i--; ) {\n      process(items[i])\n    }\n    ```\n\n- 减少迭代次数\n  - 一个涨姿势的概念 [达夫设备（Duff's Device）](http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420163.html) 适合迭代次数超过1000的场景(虽然现在应该不会再引用这种方法，但是switch-case的思想可以借鉴)\n\n除了上述四种基本的循环类型，数组后续还引入了基于函数的迭代方法`forEach()`，但是在所有情况下，基于循环的迭代比基于函数的迭代快8倍。\n\n#### 条件语句\n\n`if-else`与`switch`比较之下，条件数量较小时使用`if-else`，较多时使用`switch`\n\n优化`if-else`的方法一是确保最可能出现的条件放在首位，二是把`if-else`组织成嵌套的`if-else`语句。\n\n#### 递归\n\n这里更涨姿势了，不过描述的内容和场景目前基本没遇到过，不会把那么大的数据量放在前端处理，用Node写服务器端的话可能会遇到。先记住这几个结论吧：\n\n> 浏览器的调用栈大小限制了递归算法在 JavaScript 中的应用，栈溢出错误会导致其它代码中断运行。\n> 如果遇到栈溢出错误，可以把方法改成迭代算法。\n","slug":"high-performance-javascript-a","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyiz000ggbeh0u7od6ax","content":"<p><img src=\"https://img1.doubanio.com/lpic/s28879959.jpg\" alt=\"cover\"></p>\n<p>这篇只包含前四章节。</p>\n<h2 id=\"1-加载与执行\"><a href=\"#1-加载与执行\" class=\"headerlink\" title=\"1.加载与执行\"></a>1.加载与执行</h2><p>浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。</p>\n<p>减少脚本执行对性能影响的方法：</p>\n<ul>\n<li>把所有 <code>&lt;script&gt;</code> 标签尽可能放到 <code>&lt;body&gt;</code> 标签底部。</li>\n<li>合并脚本，减少HTTP请求带来的额外性能开销。</li>\n<li>无阻塞下载执行JavaScript脚本：<ul>\n<li><code>&lt;script&gt;</code> 的 <code>defer</code> 属性可以使脚本下载后先不执行，老版本浏览器不支持</li>\n<li>书中未提到的 HTML5 <code>async</code> 属性可以使脚本异步加载执行</li>\n<li>使用XHR对象动态加载脚本</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p><img src=\"http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/image003.jpg\" alt=\"js-load\"></p>\n<p>这部分的知识是刚接触JavaScript时就看过的，<a href=\"http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html\" target=\"_blank\" rel=\"external\">IBM开发者的文章</a>介绍的很详尽。</p>\n<hr>\n<h2 id=\"2-数据存取\"><a href=\"#2-数据存取\" class=\"headerlink\" title=\"2.数据存取\"></a>2.数据存取</h2><p>本章主要讲通过改变数据的存取位置来提高读写性能，其中又详细讲解了作用域链，原型链的工作原理，干货不少。</p>\n<p>首先要了解，一共有四种基本的数据存取位置：字面量，本地（局部）变量，数组元素，对象成员。其中字面量和局部变量的存取很快，数组元素和对象成员相对较慢，尤其是在老版本浏览器。</p>\n<h4 id=\"作用域与作用域链\"><a href=\"#作用域与作用域链\" class=\"headerlink\" title=\"作用域与作用域链\"></a>作用域与作用域链</h4><p>每一个JavaScript函数都可以表示为一个对象，Function对象既有可编程访问的属性，又有<strong>仅供JavaScript引擎存取的内部属性</strong>，其中一个内部属性是<code>[[scope]]</code>。</p>\n<p>作用域链是<code>[[scope]]</code>所包含的函数被创建的作用域中对象的集合，作用域链决定了哪些数据可被函数访问以及查找数据的顺序。</p>\n<ol>\n<li>执行函数时会创建一个 <code>execution context 执行上下文</code> ，它是一个内部对象，函数每次执行时对应的执行上下文都是不一样的。函数执行完毕，执行上下文就被销毁。</li>\n<li><code>执行上下文</code> 被创建时，它的作用域链就初始为执行函数的 <code>[[scope]]</code> 属性中的对象。这些值按顺序被复制到作用域链中，这一过程完成，即创建好了“活动对象”。</li>\n<li>活动对象是函数运行时的变量对象，包含所有局部变量，命名参数集合以及 <code>this</code>。然后活动对象会被推入作用域链的最前端。</li>\n</ol>\n<p>在函数执行过程中，每遇到一个变量都会在搜索其作用域链，从头部（即活动对象）搜索直到找到标识符，<strong>正是这个搜索过程影响了性能</strong>。</p>\n<p>在执行环境的作用域链中，一个标识符所在的位置越深，读写速度越慢。所以<strong>读写局部变量最快，全局变量最慢。全局变量总是在作用域链的最末端</strong>。</p>\n<p><strong>经验：如果一个跨作用域的值在函数中被引用一次以上，那就把它存储在局部变量里。</strong></p>\n<h4 id=\"两种改变作用域链的情况\"><a href=\"#两种改变作用域链的情况\" class=\"headerlink\" title=\"两种改变作用域链的情况\"></a>两种改变作用域链的情况</h4><p>有两个语句可以在执行时<em>临时</em>改变作用域链：<code>with语句</code>与<code>try-catch中的catch子句</code>。</p>\n<p><code>with语句</code> 有性能问题，应避免使用。它是创建了一个包含参数制定对象属性的新对象，并把它推入作用域链最前端，使得局部变量位置变深读写变慢。</p>\n<p><code>try-catch的catch子句</code>在执行中是把捕捉到的错误对象推入作用域链首位，也会造成同上的性能问题。解决办法是，在子句中把错误委托给一个函数来处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  methodThatMightCauseAnError()</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">  handle(e)  <span class=\"comment\">// 委托给错误处理函数</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"闭包，作用域与内存\"><a href=\"#闭包，作用域与内存\" class=\"headerlink\" title=\"闭包，作用域与内存\"></a>闭包，作用域与内存</h4><p>有了先前理论的了解，我们就可以理解一下与闭包有关的性能问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assignEvents</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">'xdi9952'</span></div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'save-btn'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">    saveDocument(id)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://hi.csdn.net/attachment/201005/28/0_1275041109tO2h.gif\" alt=\"clourse\"></p>\n<p>闭包函数在执行时，它的作用域链与属性 <code>[[scope]]</code> 中所引用的两个相同的作用域链对象一起被初始化，作用域链首位是闭包函数的活动对象，然后是外部函数的活动对象，最后是全局对象。闭包函数执行时用到的<code>id</code>和<code>saveDocument</code>在作用域链第一位之后，这就是使用闭包需要关注的性能点。</p>\n<h4 id=\"对象成员，原型与原型链\"><a href=\"#对象成员，原型与原型链\" class=\"headerlink\" title=\"对象成员，原型与原型链\"></a>对象成员，原型与原型链</h4><p>前文提到的，<strong>访问对象成员的速度慢于访问字面量和局部变量</strong> ，原因是什么？</p>\n<p>脚本引擎在读取对象属性时，也会按顺序检索。具体可参考<a href=\"www.cnblogs.com/snandy/archive/2012/09/01/2664134.html\">这篇博文</a>。</p>\n<hr>\n<h2 id=\"3-DOM编程-生来缓慢，我很抱歉\"><a href=\"#3-DOM编程-生来缓慢，我很抱歉\" class=\"headerlink\" title=\"3.DOM编程 生来缓慢，我很抱歉\"></a>3.DOM编程 生来缓慢，我很抱歉</h2><p>JS引擎和DOM引擎是分开的，所以脚本中对DOM的访问非常耗费性能。最坏的情况是在循环中访问或者修改DOM，此时应该把DOM缓存在局部变量中。</p>\n<h4 id=\"HTML集合\"><a href=\"#HTML集合\" class=\"headerlink\" title=\"HTML集合\"></a>HTML集合</h4><p>需要区分一下HTML集合和数组,使用jQuery选择器或者DOM节点引用的，返回的都是<code>HTML集合</code>：</p>\n<ul>\n<li><code>document.getElementById(&#39;one&#39;)</code></li>\n<li><code>$(&#39;#one&#39;)</code></li>\n</ul>\n<p>之前在lodash文档里也发现Collection和Array是分开的栏目，当时没当回事儿，现在想想其实是我压根就没有<code>HTML集合</code>的概念，HTML集合并不是数组，也没有数组可用的方法（etc.<code>slice()</code>），只是提供了length属性并且可通过数字索引来访问集合中的元素。</p>\n<p><strong>HTML集合是低效之源</strong> ，集合是实时性的，一直保持着与文档的连接，任何操作和访问都会重复DOM操作。在相同的内容和数量下，遍历一个数组的速度明显快于遍历一个HTML集合。因此也更不应该遍历或循环HTML集合。如果非要进行这种操作的话，建议：</p>\n<ul>\n<li>不要在循环的条件控制语句中读取 length 属性（这个无论是集合还是数组都通用）</li>\n<li><p>把集合转为数组再操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toArray</span> (<span class=\"params\">coll</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, a = [], len = coll.length; i&lt;len; i++) &#123;</div><div class=\"line\">    a[i] = coll[i]</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> a</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>访问集合时使用局部变量，把length缓存在循环外部，把需要多次读取的元素存在局部变量中</p>\n</li>\n</ul>\n<h4 id=\"querySelectorAll\"><a href=\"#querySelectorAll\" class=\"headerlink\" title=\"querySelectorAll()\"></a>querySelectorAll()</h4><p>关于选择器API，建议使用 <code>document.querySelectorAll()</code> 的原生DOM方法来获取元素列表。</p>\n<p>与<code>getElementById</code>等api不同，<code>querySelectorAll()</code> 仅返回一个 NodeList 而非HTML集合，因此这些返回的节点集不会对应实时的文档结构，在遍历节点时可以比较放心地使用该方法。</p>\n<h4 id=\"重绘与重排\"><a href=\"#重绘与重排\" class=\"headerlink\" title=\"重绘与重排\"></a>重绘与重排</h4><p><a href=\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\" target=\"_blank\" rel=\"external\">此博文：《网页性能管理详解》</a>中也详细介绍了关于浏览器重排与重绘相关的知识。</p>\n<p>调用一下方法时会 <strong>强制浏览器刷新队列并触发重排</strong> ：</p>\n<blockquote>\n<p>offsetTop/offsetLeft/offsetWidth/offsetHeight<br>scrollTop/scrollLeft/scrollWidth/scrollHeight<br>clientTop/clientLeft/clientWidth/clientHeight<br>getComputedStyle()</p>\n</blockquote>\n<p>因此如果需要多次查询布局信息如<code>offsetTop</code>时，应把其缓存起来。</p>\n<p>减少重排的方法有三种，使元素脱离文档流(<code>display:none</code>)，在文档之外创建并更新一个文档片段并附加到原始列表(<code>document.createDocumentFragment</code>)，克隆节点(<code>cloneNode</code>)。</p>\n<p>比较推荐的是第二个方案，所产生的DOM遍历和重排次数最少：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment()</div><div class=\"line\">appendDataToElement(fragment, data)</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>).appendChild(fragment)</div></pre></td></tr></table></figure>\n<h4 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h4><p>每绑定一个事件处理器都是有代价的，要么加重了页面负担，要么增加了运行期的执行时间。所以我们需要使用事件委托来减少事件处理器的数量，而不是给每个元素都绑上事件处理器。</p>\n<p>关于事件委托也是一个坑，先参考一下<a href=\"http://stackoverflow.com/questions/1687296/what-is-dom-event-delegation\" target=\"_blank\" rel=\"external\">stackoverflow: What is DOM Event delegation</a>，后续再参考高程研究一波。</p>\n<h2 id=\"4-算法和流程控制\"><a href=\"#4-算法和流程控制\" class=\"headerlink\" title=\"4.算法和流程控制\"></a>4.算法和流程控制</h2><p>也是很涨姿势的一章。</p>\n<h4 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h4><p>ECMA-262 标准中一共有四种循环类型，<code>for循环</code>，<code>while循环</code>，<code>do-while循环</code>，<code>for-in循环</code>。前三种循环类型性能所差无几，只有<code>for-in</code>比其它几种明显要慢，<strong>除了明确需要迭代一个属性数量未知的对象，否则应避免使用for-in循环</strong> 。</p>\n<p>改善循环性能的切入点有两种：</p>\n<ul>\n<li><p>减少迭代工作量</p>\n<ul>\n<li><p>减少对象成员及数组项的查找次数：如上一章所提到的，把数组的length存到局部变量中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>, len=items.length; i &lt; len; i++) &#123;</div><div class=\"line\">  process(items[i])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>采用倒序循环：在每次循环中减少了一次查找属性，减少了控制条件中的一次数值比较</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=items.length;i--; ) &#123;</div><div class=\"line\">  process(items[i])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>减少迭代次数</p>\n<ul>\n<li>一个涨姿势的概念 <a href=\"http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420163.html\" target=\"_blank\" rel=\"external\">达夫设备（Duff’s Device）</a> 适合迭代次数超过1000的场景(虽然现在应该不会再引用这种方法，但是switch-case的思想可以借鉴)</li>\n</ul>\n</li>\n</ul>\n<p>除了上述四种基本的循环类型，数组后续还引入了基于函数的迭代方法<code>forEach()</code>，但是在所有情况下，基于循环的迭代比基于函数的迭代快8倍。</p>\n<h4 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h4><p><code>if-else</code>与<code>switch</code>比较之下，条件数量较小时使用<code>if-else</code>，较多时使用<code>switch</code></p>\n<p>优化<code>if-else</code>的方法一是确保最可能出现的条件放在首位，二是把<code>if-else</code>组织成嵌套的<code>if-else</code>语句。</p>\n<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><p>这里更涨姿势了，不过描述的内容和场景目前基本没遇到过，不会把那么大的数据量放在前端处理，用Node写服务器端的话可能会遇到。先记住这几个结论吧：</p>\n<blockquote>\n<p>浏览器的调用栈大小限制了递归算法在 JavaScript 中的应用，栈溢出错误会导致其它代码中断运行。<br>如果遇到栈溢出错误，可以把方法改成迭代算法。</p>\n</blockquote>\n","excerpt":"<p><img src=\"https://img1.doubanio.com/lpic/s28879959.jpg\" alt=\"cover\"></p>\n<p>这篇只包含前四章节。</p>\n<h2 id=\"1-加载与执行\"><a href=\"#1-加载与执行\" class=\"headerlink\" title=\"1.加载与执行\"></a>1.加载与执行</h2><p>浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。</p>\n<p>减少脚本执行对性能影响的方法：</p>\n<ul>\n<li>把所有 <code>&lt;script&gt;</code> 标签尽可能放到 <code>&lt;body&gt;</code> 标签底部。</li>\n<li>合并脚本，减少HTTP请求带来的额外性能开销。</li>\n<li>无阻塞下载执行JavaScript脚本：<ul>\n<li><code>&lt;script&gt;</code> 的 <code>defer</code> 属性可以使脚本下载后先不执行，老版本浏览器不支持</li>\n<li>书中未提到的 HTML5 <code>async</code> 属性可以使脚本异步加载执行</li>\n<li>使用XHR对象动态加载脚本</li>\n</ul>\n</li>\n</ul>","more":"<p><img src=\"http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/image003.jpg\" alt=\"js-load\"></p>\n<p>这部分的知识是刚接触JavaScript时就看过的，<a href=\"http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html\">IBM开发者的文章</a>介绍的很详尽。</p>\n<hr>\n<h2 id=\"2-数据存取\"><a href=\"#2-数据存取\" class=\"headerlink\" title=\"2.数据存取\"></a>2.数据存取</h2><p>本章主要讲通过改变数据的存取位置来提高读写性能，其中又详细讲解了作用域链，原型链的工作原理，干货不少。</p>\n<p>首先要了解，一共有四种基本的数据存取位置：字面量，本地（局部）变量，数组元素，对象成员。其中字面量和局部变量的存取很快，数组元素和对象成员相对较慢，尤其是在老版本浏览器。</p>\n<h4 id=\"作用域与作用域链\"><a href=\"#作用域与作用域链\" class=\"headerlink\" title=\"作用域与作用域链\"></a>作用域与作用域链</h4><p>每一个JavaScript函数都可以表示为一个对象，Function对象既有可编程访问的属性，又有<strong>仅供JavaScript引擎存取的内部属性</strong>，其中一个内部属性是<code>[[scope]]</code>。</p>\n<p>作用域链是<code>[[scope]]</code>所包含的函数被创建的作用域中对象的集合，作用域链决定了哪些数据可被函数访问以及查找数据的顺序。</p>\n<ol>\n<li>执行函数时会创建一个 <code>execution context 执行上下文</code> ，它是一个内部对象，函数每次执行时对应的执行上下文都是不一样的。函数执行完毕，执行上下文就被销毁。</li>\n<li><code>执行上下文</code> 被创建时，它的作用域链就初始为执行函数的 <code>[[scope]]</code> 属性中的对象。这些值按顺序被复制到作用域链中，这一过程完成，即创建好了“活动对象”。</li>\n<li>活动对象是函数运行时的变量对象，包含所有局部变量，命名参数集合以及 <code>this</code>。然后活动对象会被推入作用域链的最前端。</li>\n</ol>\n<p>在函数执行过程中，每遇到一个变量都会在搜索其作用域链，从头部（即活动对象）搜索直到找到标识符，<strong>正是这个搜索过程影响了性能</strong>。</p>\n<p>在执行环境的作用域链中，一个标识符所在的位置越深，读写速度越慢。所以<strong>读写局部变量最快，全局变量最慢。全局变量总是在作用域链的最末端</strong>。</p>\n<p><strong>经验：如果一个跨作用域的值在函数中被引用一次以上，那就把它存储在局部变量里。</strong></p>\n<h4 id=\"两种改变作用域链的情况\"><a href=\"#两种改变作用域链的情况\" class=\"headerlink\" title=\"两种改变作用域链的情况\"></a>两种改变作用域链的情况</h4><p>有两个语句可以在执行时<em>临时</em>改变作用域链：<code>with语句</code>与<code>try-catch中的catch子句</code>。</p>\n<p><code>with语句</code> 有性能问题，应避免使用。它是创建了一个包含参数制定对象属性的新对象，并把它推入作用域链最前端，使得局部变量位置变深读写变慢。</p>\n<p><code>try-catch的catch子句</code>在执行中是把捕捉到的错误对象推入作用域链首位，也会造成同上的性能问题。解决办法是，在子句中把错误委托给一个函数来处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  methodThatMightCauseAnError()</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">  handle(e)  <span class=\"comment\">// 委托给错误处理函数</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"闭包，作用域与内存\"><a href=\"#闭包，作用域与内存\" class=\"headerlink\" title=\"闭包，作用域与内存\"></a>闭包，作用域与内存</h4><p>有了先前理论的了解，我们就可以理解一下与闭包有关的性能问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assignEvents</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">'xdi9952'</span></div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'save-btn'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">    saveDocument(id)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://hi.csdn.net/attachment/201005/28/0_1275041109tO2h.gif\" alt=\"clourse\"></p>\n<p>闭包函数在执行时，它的作用域链与属性 <code>[[scope]]</code> 中所引用的两个相同的作用域链对象一起被初始化，作用域链首位是闭包函数的活动对象，然后是外部函数的活动对象，最后是全局对象。闭包函数执行时用到的<code>id</code>和<code>saveDocument</code>在作用域链第一位之后，这就是使用闭包需要关注的性能点。</p>\n<h4 id=\"对象成员，原型与原型链\"><a href=\"#对象成员，原型与原型链\" class=\"headerlink\" title=\"对象成员，原型与原型链\"></a>对象成员，原型与原型链</h4><p>前文提到的，<strong>访问对象成员的速度慢于访问字面量和局部变量</strong> ，原因是什么？</p>\n<p>脚本引擎在读取对象属性时，也会按顺序检索。具体可参考<a href=\"www.cnblogs.com/snandy/archive/2012/09/01/2664134.html\">这篇博文</a>。</p>\n<hr>\n<h2 id=\"3-DOM编程-生来缓慢，我很抱歉\"><a href=\"#3-DOM编程-生来缓慢，我很抱歉\" class=\"headerlink\" title=\"3.DOM编程 生来缓慢，我很抱歉\"></a>3.DOM编程 生来缓慢，我很抱歉</h2><p>JS引擎和DOM引擎是分开的，所以脚本中对DOM的访问非常耗费性能。最坏的情况是在循环中访问或者修改DOM，此时应该把DOM缓存在局部变量中。</p>\n<h4 id=\"HTML集合\"><a href=\"#HTML集合\" class=\"headerlink\" title=\"HTML集合\"></a>HTML集合</h4><p>需要区分一下HTML集合和数组,使用jQuery选择器或者DOM节点引用的，返回的都是<code>HTML集合</code>：</p>\n<ul>\n<li><code>document.getElementById(&#39;one&#39;)</code></li>\n<li><code>$(&#39;#one&#39;)</code></li>\n</ul>\n<p>之前在lodash文档里也发现Collection和Array是分开的栏目，当时没当回事儿，现在想想其实是我压根就没有<code>HTML集合</code>的概念，HTML集合并不是数组，也没有数组可用的方法（etc.<code>slice()</code>），只是提供了length属性并且可通过数字索引来访问集合中的元素。</p>\n<p><strong>HTML集合是低效之源</strong> ，集合是实时性的，一直保持着与文档的连接，任何操作和访问都会重复DOM操作。在相同的内容和数量下，遍历一个数组的速度明显快于遍历一个HTML集合。因此也更不应该遍历或循环HTML集合。如果非要进行这种操作的话，建议：</p>\n<ul>\n<li>不要在循环的条件控制语句中读取 length 属性（这个无论是集合还是数组都通用）</li>\n<li><p>把集合转为数组再操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toArray</span> (<span class=\"params\">coll</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, a = [], len = coll.length; i&lt;len; i++) &#123;</div><div class=\"line\">    a[i] = coll[i]</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> a</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>访问集合时使用局部变量，把length缓存在循环外部，把需要多次读取的元素存在局部变量中</p>\n</li>\n</ul>\n<h4 id=\"querySelectorAll\"><a href=\"#querySelectorAll\" class=\"headerlink\" title=\"querySelectorAll()\"></a>querySelectorAll()</h4><p>关于选择器API，建议使用 <code>document.querySelectorAll()</code> 的原生DOM方法来获取元素列表。</p>\n<p>与<code>getElementById</code>等api不同，<code>querySelectorAll()</code> 仅返回一个 NodeList 而非HTML集合，因此这些返回的节点集不会对应实时的文档结构，在遍历节点时可以比较放心地使用该方法。</p>\n<h4 id=\"重绘与重排\"><a href=\"#重绘与重排\" class=\"headerlink\" title=\"重绘与重排\"></a>重绘与重排</h4><p><a href=\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\">此博文：《网页性能管理详解》</a>中也详细介绍了关于浏览器重排与重绘相关的知识。</p>\n<p>调用一下方法时会 <strong>强制浏览器刷新队列并触发重排</strong> ：</p>\n<blockquote>\n<p>offsetTop/offsetLeft/offsetWidth/offsetHeight<br>scrollTop/scrollLeft/scrollWidth/scrollHeight<br>clientTop/clientLeft/clientWidth/clientHeight<br>getComputedStyle()</p>\n</blockquote>\n<p>因此如果需要多次查询布局信息如<code>offsetTop</code>时，应把其缓存起来。</p>\n<p>减少重排的方法有三种，使元素脱离文档流(<code>display:none</code>)，在文档之外创建并更新一个文档片段并附加到原始列表(<code>document.createDocumentFragment</code>)，克隆节点(<code>cloneNode</code>)。</p>\n<p>比较推荐的是第二个方案，所产生的DOM遍历和重排次数最少：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment()</div><div class=\"line\">appendDataToElement(fragment, data)</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>).appendChild(fragment)</div></pre></td></tr></table></figure>\n<h4 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h4><p>每绑定一个事件处理器都是有代价的，要么加重了页面负担，要么增加了运行期的执行时间。所以我们需要使用事件委托来减少事件处理器的数量，而不是给每个元素都绑上事件处理器。</p>\n<p>关于事件委托也是一个坑，先参考一下<a href=\"http://stackoverflow.com/questions/1687296/what-is-dom-event-delegation\">stackoverflow: What is DOM Event delegation</a>，后续再参考高程研究一波。</p>\n<h2 id=\"4-算法和流程控制\"><a href=\"#4-算法和流程控制\" class=\"headerlink\" title=\"4.算法和流程控制\"></a>4.算法和流程控制</h2><p>也是很涨姿势的一章。</p>\n<h4 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h4><p>ECMA-262 标准中一共有四种循环类型，<code>for循环</code>，<code>while循环</code>，<code>do-while循环</code>，<code>for-in循环</code>。前三种循环类型性能所差无几，只有<code>for-in</code>比其它几种明显要慢，<strong>除了明确需要迭代一个属性数量未知的对象，否则应避免使用for-in循环</strong> 。</p>\n<p>改善循环性能的切入点有两种：</p>\n<ul>\n<li><p>减少迭代工作量</p>\n<ul>\n<li><p>减少对象成员及数组项的查找次数：如上一章所提到的，把数组的length存到局部变量中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>, len=items.length; i &lt; len; i++) &#123;</div><div class=\"line\">  process(items[i])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>采用倒序循环：在每次循环中减少了一次查找属性，减少了控制条件中的一次数值比较</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=items.length;i--; ) &#123;</div><div class=\"line\">  process(items[i])</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>减少迭代次数</p>\n<ul>\n<li>一个涨姿势的概念 <a href=\"http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420163.html\">达夫设备（Duff’s Device）</a> 适合迭代次数超过1000的场景(虽然现在应该不会再引用这种方法，但是switch-case的思想可以借鉴)</li>\n</ul>\n</li>\n</ul>\n<p>除了上述四种基本的循环类型，数组后续还引入了基于函数的迭代方法<code>forEach()</code>，但是在所有情况下，基于循环的迭代比基于函数的迭代快8倍。</p>\n<h4 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h4><p><code>if-else</code>与<code>switch</code>比较之下，条件数量较小时使用<code>if-else</code>，较多时使用<code>switch</code></p>\n<p>优化<code>if-else</code>的方法一是确保最可能出现的条件放在首位，二是把<code>if-else</code>组织成嵌套的<code>if-else</code>语句。</p>\n<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><p>这里更涨姿势了，不过描述的内容和场景目前基本没遇到过，不会把那么大的数据量放在前端处理，用Node写服务器端的话可能会遇到。先记住这几个结论吧：</p>\n<blockquote>\n<p>浏览器的调用栈大小限制了递归算法在 JavaScript 中的应用，栈溢出错误会导致其它代码中断运行。<br>如果遇到栈溢出错误，可以把方法改成迭代算法。</p>\n</blockquote>"},{"layout":"post","title":"阅读《高性能JavaScript》(下)","date":"2016-10-03T08:43:00.000Z","_content":"\n![cover](/images/javascript-is-fast.png)\n\n接[前四节的总结](http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/)\n\n## 5.字符串和正则表达式\n\n#### 字符串构建原理\n\n`str += 'one' + 'two'`\n\n这行代码运行时会经历四个步骤：\n\n> 1.在内存中创建一个临时字符串\n> 2.链接后的字符串 'onetwo' 被赋值给该临时字符串\n> 3.临时字符串与 str 当前值连接\n> 4.结果赋给 str\n\n<!--more-->\n\n过程中产生的临时字符串造成了较大的性能开销，应当避免在字符串构建过程中创建临时字符串：\n\n`str = str + 'one' + 'two'`\n\n由于IE之外的浏览器会给表达式左侧字符串分配更多内存，然后把第二个字符串拷贝到最左侧字符串的末尾，因此如果在循环中，基础字符串位于最左端，就可以避免重复拷贝一个逐渐变大的基础字符串。\n\n除此之外，使用数组项合并的方法（`Array.prototype.join`）比其它字符串连接方法更慢，`String.prototype.concat` 也比简单的 `+` 和 `+=`更慢，构建大字符串时会造成灾难性的性能问题。\n\n在此也拓展一个vajoy大大提到的知识点， **字符串方法是如何调用的？**\n\n字符串（String）类型属于基本类型，它不是对象，那我们是怎么调用它的 `concat`、`substring` 等字符串属性方法呢？\n\n在 JavaScript 的世界中万物皆对象\n\n```javascript\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\ns1.color = \"red\";\nalert(s1.color);  // undefined\n```\n\n其实在每次调用 s1 的属性方法时，后台都会默默地先执行 ` s1=new String('some text')` ，从而让我们可以顺着原型链调用到String对象的属性（比如第二行调用了 `substring`）。\n\n在调用完毕后，后台会再默默销毁掉这个先前创建的包装对象，因此在第三行代码执行完毕之后， `s1`即被销毁，最后 alert 的结果是 `undefined`\n\n> “引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。” ——《高程三》\n\n#### 正则表达式优化\n\n本节内容最重要的是理解 **回溯** ：\n\n>回溯法采用试错的思想，它尝试分步的去解决一个问题。\n\n>在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。\n\n>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n>1.找到一个可能存在的正确的答案\n\n>2.在尝试了所有可能的分步方法后宣告该问题没有答案\n\n>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。\n\n\n回溯是正则表达式匹配过程中的基础部分，使用不当也会造成非常大的计算消耗。提高效率的方法：\n\n1. 加快匹配失败的过程：正则表达式慢的原因通常是匹配失败的过程慢：\n\n   ```javascript\n   var str = 'eABC21323AB213',\n       r1 = /\\bAB/.test(str),   //匹配失败的过程较长\n       r2 = /^AB/.test(str);    //匹配失败的过程很短\n   ```\n\n2.  减少分支条件，具体化量词：\n\n    ```javascript\n    var str = 'cat 1990';  //需匹配：19XX年出生的猫或蝙蝠\n    var r1 = /(cat|bat)\\s\\d{4}/.test(str);  //不推荐\n    var r1 = /[bc]at\\s19\\d{2}/.test(str);  //推荐，减少分支，具体化量词\n    ```\n\n3. 使用非捕获组，在不需要反向引用的时候\n\n4. 只捕获感兴趣的文本以减少后处理：如果需要引用匹配的一部分，应该先捕获那些片段，再用反向引用来处理\n\n5. 拆开复杂的表达式：避免在一个正则表达式中处理太多任务。复杂的搜索问题需要条件逻辑，拆分成两个或多个正则表达式更容易解决，通常也会更高效\n\n## 6.快速响应的用户界面\n\n有一次和一位月饼厂的安卓开发聊天，她说她最近跟合作的前端沟通很费劲，她一直想弄明白浏览器UI线程是不是单线程，可是那个前端也不明白这个概念，由此引出了对一些前端开发人员业务知识薄弱的吐槽。听的时候我也没法做任何反应，我也并不清楚这个概念 = =\n\n好在这一章节就围绕浏览器的UI线程展开的，依然是干货很多让人“知其所以然”。\n\n#### 浏览器UI线程\n\n> 大多数浏览器让一个单线程共用于执行 JavaScript 和更新用户界面，每个时刻只能执行其中一种操作，这意味着当 JavaScript 代码正在执行时用户界面无法响应输入，反之亦然。\n\n好像是很容易理解的，但还是深入了解一下 wikipedia 中 `线程` 的定义：\n\n> 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n\n再看一下什么是 `进程`：\n\n> 进程（英语：process），是计算机中已运行程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。\n\n> 用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。\n进程需要一些资源才能完成工作，如CPU使用时间、内存、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。\n\n然而常规浏览器并不会只有一个线程在运作，主要线程可归类为：\n\n![common thread](http://images2015.cnblogs.com/blog/561179/201601/561179-20160103131737151-1750514444.jpg)\n\n基础知识补到这里，半路出家的程序员心好累。\n\n**UI线程的工作基于一个简单的队列系统** ，任务会保存到队列中直到线程空闲，一旦空闲队列中的下一个任务就被重新提取出来并运行。先看一个简单的交互例子来理解UI线程的队列系统：\n\n```javascript\n<html>\n  <head>\n    <title>Browser UI Thread Example</title>\n  </head>\n  <body>\n    <button onclick=\"handleClick()\">Click Me</button>\n    <script type=\"text/javascript\">\n      function handleClick(){\n        var div = document.createElement(\"div\");\n        div.innerHTML = \"Clicked!\";\n        document.body.appendChild(div);\n      }\n    </script>\n  </body>\n</html>\n```\n\n按钮上绑定了一个点击事件，点击后会调用 `handleClick()` 函数。\n\n![thread](http://hi.csdn.net/attachment/201005/31/0_12752710809o5M.gif)\n\n1. 按钮被点击，触发UI线程创建两个任务并添加到队列中。\n\n   - 更新按钮UI\n   - 执行 JavaScript 即执行 `handleClick()` 函数段代码\n\n2. 执行 JavaScript 过程中创建了新的 div 元素并附加在 body 后，又触发了一次UI更新\n\n大多数浏览器在 JavaScript 运行时会停止吧新任务加入 UI 线程的队列中，因此如果用户试图在任务运行期间与页面交互，不仅没有即时的 UI 更新，可能连 UI 更新任务都不会加入到队列中。\n\n> 当脚本执行时，UI 不随用户交互而更新，执行时间段内用户交互行为所引发的 JavaScript 任务会被加入队列中，并在最初的 JavaScript 任务完成后一次执行。而这段时间里由交互行为引发的 UI 更新会被自动跳过。因此在一个脚本运行期间点击一个按钮，将无法看到它被按下的样式，尽管它的 onclick 事件处理器会被执行。\n\n#### 使用定时器进行优化\n\n**单个 JavaScript 操作花费的总时间不应该超过100毫秒。否则用户会感到与界面失去联系。**\n\n有一些复杂的任务无法在100毫秒内执行完毕则需要停止 JavaScript 的执行，让出线程控制权使得 UI 可以更新。因此我们需要使用定时器进行优化。\n\n创建一个定时器会造成 UI 线程暂停，也会重置所有相关的浏览器限制，包括长时间运行脚本定时器和调用栈。这使得定时器成为长时间运行 JavaScript 代码理想的跨浏览器解决方案。\n\n```javascript\nvar button = document.getElementById(\"my-button\");\nbutton.onclick = function(){\n  oneMethod();\n  setTimeout(function(){\n    document.getElementById(\"notice\").style.color = \"red\";\n  }, 250);\n};\n```\n\n需要注意 `setTimeout()` 和 `setInterval()` 函数中的第二个参数表示任务何时被添加到 UI 队列，而不是一定会在这段时间后执行。定时器代码只有在创建它的函数执行完成之后才有可能被执行。如果调用setTimeout()的函数又调用了其他任务，耗时超过定时器延时，定时器代码将立即被执行，它与主调函数之间没有可察觉的延迟。\n\n同时需要注意的是定时器的精度问题： **定时器延迟通常并不精准，不可用于测量实际时间。所以延迟的最小值建议为25毫秒，以免加上误差延时实际上变得更小，不够进行UI刷新。**\n\n我以前还想过用定时器来 console.log 打印出来运行耗费时间来进行优化测试之类的，这样看来还是 too naive ，所以该怎么记录代码的运行时间？\n\n```javascript\nvar start = +new Date(),\nstop;\nsomeLongProcess();\nstop = +new Date();\nif(stop-start < 50){\n  alert(\"Just about right.\");\n} else {\n  alert(\"Taking too long.\");\n}\n\n```\n\n我们也可以利用类似思路，把需要长时间运行的脚本切割成小任务来执行：\n\n```javascript\nfunction timedProcessArray(items, process, callback){\n  var todo = items.concat(); //create a clone of the original\n  setTimeout(function(){\n    var start = +new Date();\n    do {\n      process(todo.shift());\n    } while (todo.length > 0 && (+new Date() - start < 50));\n    // 检查是否仍有任务需执行\n    if (todo.length > 0){\n      setTimeout(arguments.callee, 25);\n    } else {\n      callback(items);\n    }\n  }, 25);\n}\n```\n\n克隆需执行的任务数组来进行操作，每次取一项并从数组中移除这项(array.shift())，如果此时程序所耗费时间少于50毫秒，那就见缝插针地继续指向任务项，否则就先停止执行代码，25毫秒后继续。\n\n定时器很好用，但是滥用也同样会导致性能问题。\n\n在上面定时器的例子中，我想到了另一个通过定时器来实现的优化点：`函数节流 throttele` 与 `函数防抖 debounce`。\n\n#### Throttle and Debounce\n\n> Throttle 和 Debounce 函数都可以限定函数的执行时间点，在 `window.onresize` 事件中：\n使用 `throttle(action, time)` 可以让 `action` 在 `time` 时间内一定执行且只执行一次;\n使用 `debounce(action, time)` 函数可以让 `action` 在 `resize` 停止 `time` 时间之后执行。\n\n函数节流与防抖都是避免了连续触发事件而导致浏览器崩溃，简单的封装实现：\n\n```javascript\nvar throttle = function (action, time) {\n    var startTime = new Date();\n    return function () {\n        var ctx = this;\n        var currentTime = new Date();\n        if (currentTime - startTime > time) {\n            action.apply(ctx);\n            startTime = currentTime;\n        }\n    };\n};\nwindow.addEventListener('resize', throttle(function () {\n    console.log('resize event')\n}, 1000));\n```\n\n即事件连续触发时，`throttle(action, time)` 中的 `action` 会每隔 `time` 时间就触发一次。\n\n```javascript\nvar debounce = function (action, time) {\n    var timer;\n    return function () {\n        var ctx = this;\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(function () {\n            action.apply(this);\n        }, time);\n    };\n};\nwindow.addEventListener('resize', debounce(function (){\n    console.log('resize');\n}, 1000));\n```\n\n即事件连续触发时，`debounce(action, time)` 中的 `action` 并不会立即执行；当第二次触发 `window.onresize` 事件时，如果两次事件发生的间隔小于 `time`，则仍然不执行 `action`，只有两次间隔大于 `time` 才会执行 `action`。\n\n更多内容可以阅读 [《浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异》](https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs)，文中用电梯策略来讲解节流与防抖的区别，以及在 Underscore.js 中的实现，非常值得一看。\n\n## 7.Ajax\n\n这一节内容比较杂，并且一些内容和优化建议现在并不实用了，大概参考一下吧。\n\n#### GET 与 POST 的区别\n\n> GET 请求是幂等的，经 GET 请求的数据会被缓存起来，对于少量数据而言 GET 请求往服务器只发送一个数据包，POST 请求发送两个数据包，一个装载头信息一个装载 POST 正文。只有当请求的 URL 加上参数的长度接近或超过2048个字符时才使用 POST 获取数据。\n\n这是书中给的信息，然而是不准确的。\n\n实际上，**URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。**，区别主要在语义上，POST 请求并不是明文因而相对更安全，以及书中提到的数据包数量的区别。\n\n更多详细内容可参考 [《浅谈HTTP中Get与Post的区别》](http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)\n\n## 8.编程实践\n\n- 避免双重求值\n  - 避免以 `new Function()` 的形式来创建函数\n  - 避免用 `setTimeout/setInterval` 执行字符串，可改为传入函数\n\n- 使用 Object/Array 直接量可以加快运行并且也节省了代码\n- 用速度最快的部分（位操作，原生 JavaScript）\n\n后面两章没有太多可参考的新内容，都比较过时，就不记录了~ done!\n","source":"_posts/high-performance-javascript-b.md","raw":"---\nlayout: post\ntitle:  \"阅读《高性能JavaScript》(下)\"\ndate:   2016-10-03 16:43\ncategories: javascript\n---\n\n![cover](/images/javascript-is-fast.png)\n\n接[前四节的总结](http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/)\n\n## 5.字符串和正则表达式\n\n#### 字符串构建原理\n\n`str += 'one' + 'two'`\n\n这行代码运行时会经历四个步骤：\n\n> 1.在内存中创建一个临时字符串\n> 2.链接后的字符串 'onetwo' 被赋值给该临时字符串\n> 3.临时字符串与 str 当前值连接\n> 4.结果赋给 str\n\n<!--more-->\n\n过程中产生的临时字符串造成了较大的性能开销，应当避免在字符串构建过程中创建临时字符串：\n\n`str = str + 'one' + 'two'`\n\n由于IE之外的浏览器会给表达式左侧字符串分配更多内存，然后把第二个字符串拷贝到最左侧字符串的末尾，因此如果在循环中，基础字符串位于最左端，就可以避免重复拷贝一个逐渐变大的基础字符串。\n\n除此之外，使用数组项合并的方法（`Array.prototype.join`）比其它字符串连接方法更慢，`String.prototype.concat` 也比简单的 `+` 和 `+=`更慢，构建大字符串时会造成灾难性的性能问题。\n\n在此也拓展一个vajoy大大提到的知识点， **字符串方法是如何调用的？**\n\n字符串（String）类型属于基本类型，它不是对象，那我们是怎么调用它的 `concat`、`substring` 等字符串属性方法呢？\n\n在 JavaScript 的世界中万物皆对象\n\n```javascript\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\ns1.color = \"red\";\nalert(s1.color);  // undefined\n```\n\n其实在每次调用 s1 的属性方法时，后台都会默默地先执行 ` s1=new String('some text')` ，从而让我们可以顺着原型链调用到String对象的属性（比如第二行调用了 `substring`）。\n\n在调用完毕后，后台会再默默销毁掉这个先前创建的包装对象，因此在第三行代码执行完毕之后， `s1`即被销毁，最后 alert 的结果是 `undefined`\n\n> “引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。” ——《高程三》\n\n#### 正则表达式优化\n\n本节内容最重要的是理解 **回溯** ：\n\n>回溯法采用试错的思想，它尝试分步的去解决一个问题。\n\n>在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。\n\n>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n>1.找到一个可能存在的正确的答案\n\n>2.在尝试了所有可能的分步方法后宣告该问题没有答案\n\n>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。\n\n\n回溯是正则表达式匹配过程中的基础部分，使用不当也会造成非常大的计算消耗。提高效率的方法：\n\n1. 加快匹配失败的过程：正则表达式慢的原因通常是匹配失败的过程慢：\n\n   ```javascript\n   var str = 'eABC21323AB213',\n       r1 = /\\bAB/.test(str),   //匹配失败的过程较长\n       r2 = /^AB/.test(str);    //匹配失败的过程很短\n   ```\n\n2.  减少分支条件，具体化量词：\n\n    ```javascript\n    var str = 'cat 1990';  //需匹配：19XX年出生的猫或蝙蝠\n    var r1 = /(cat|bat)\\s\\d{4}/.test(str);  //不推荐\n    var r1 = /[bc]at\\s19\\d{2}/.test(str);  //推荐，减少分支，具体化量词\n    ```\n\n3. 使用非捕获组，在不需要反向引用的时候\n\n4. 只捕获感兴趣的文本以减少后处理：如果需要引用匹配的一部分，应该先捕获那些片段，再用反向引用来处理\n\n5. 拆开复杂的表达式：避免在一个正则表达式中处理太多任务。复杂的搜索问题需要条件逻辑，拆分成两个或多个正则表达式更容易解决，通常也会更高效\n\n## 6.快速响应的用户界面\n\n有一次和一位月饼厂的安卓开发聊天，她说她最近跟合作的前端沟通很费劲，她一直想弄明白浏览器UI线程是不是单线程，可是那个前端也不明白这个概念，由此引出了对一些前端开发人员业务知识薄弱的吐槽。听的时候我也没法做任何反应，我也并不清楚这个概念 = =\n\n好在这一章节就围绕浏览器的UI线程展开的，依然是干货很多让人“知其所以然”。\n\n#### 浏览器UI线程\n\n> 大多数浏览器让一个单线程共用于执行 JavaScript 和更新用户界面，每个时刻只能执行其中一种操作，这意味着当 JavaScript 代码正在执行时用户界面无法响应输入，反之亦然。\n\n好像是很容易理解的，但还是深入了解一下 wikipedia 中 `线程` 的定义：\n\n> 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n\n再看一下什么是 `进程`：\n\n> 进程（英语：process），是计算机中已运行程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。\n\n> 用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。\n进程需要一些资源才能完成工作，如CPU使用时间、内存、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。\n\n然而常规浏览器并不会只有一个线程在运作，主要线程可归类为：\n\n![common thread](http://images2015.cnblogs.com/blog/561179/201601/561179-20160103131737151-1750514444.jpg)\n\n基础知识补到这里，半路出家的程序员心好累。\n\n**UI线程的工作基于一个简单的队列系统** ，任务会保存到队列中直到线程空闲，一旦空闲队列中的下一个任务就被重新提取出来并运行。先看一个简单的交互例子来理解UI线程的队列系统：\n\n```javascript\n<html>\n  <head>\n    <title>Browser UI Thread Example</title>\n  </head>\n  <body>\n    <button onclick=\"handleClick()\">Click Me</button>\n    <script type=\"text/javascript\">\n      function handleClick(){\n        var div = document.createElement(\"div\");\n        div.innerHTML = \"Clicked!\";\n        document.body.appendChild(div);\n      }\n    </script>\n  </body>\n</html>\n```\n\n按钮上绑定了一个点击事件，点击后会调用 `handleClick()` 函数。\n\n![thread](http://hi.csdn.net/attachment/201005/31/0_12752710809o5M.gif)\n\n1. 按钮被点击，触发UI线程创建两个任务并添加到队列中。\n\n   - 更新按钮UI\n   - 执行 JavaScript 即执行 `handleClick()` 函数段代码\n\n2. 执行 JavaScript 过程中创建了新的 div 元素并附加在 body 后，又触发了一次UI更新\n\n大多数浏览器在 JavaScript 运行时会停止吧新任务加入 UI 线程的队列中，因此如果用户试图在任务运行期间与页面交互，不仅没有即时的 UI 更新，可能连 UI 更新任务都不会加入到队列中。\n\n> 当脚本执行时，UI 不随用户交互而更新，执行时间段内用户交互行为所引发的 JavaScript 任务会被加入队列中，并在最初的 JavaScript 任务完成后一次执行。而这段时间里由交互行为引发的 UI 更新会被自动跳过。因此在一个脚本运行期间点击一个按钮，将无法看到它被按下的样式，尽管它的 onclick 事件处理器会被执行。\n\n#### 使用定时器进行优化\n\n**单个 JavaScript 操作花费的总时间不应该超过100毫秒。否则用户会感到与界面失去联系。**\n\n有一些复杂的任务无法在100毫秒内执行完毕则需要停止 JavaScript 的执行，让出线程控制权使得 UI 可以更新。因此我们需要使用定时器进行优化。\n\n创建一个定时器会造成 UI 线程暂停，也会重置所有相关的浏览器限制，包括长时间运行脚本定时器和调用栈。这使得定时器成为长时间运行 JavaScript 代码理想的跨浏览器解决方案。\n\n```javascript\nvar button = document.getElementById(\"my-button\");\nbutton.onclick = function(){\n  oneMethod();\n  setTimeout(function(){\n    document.getElementById(\"notice\").style.color = \"red\";\n  }, 250);\n};\n```\n\n需要注意 `setTimeout()` 和 `setInterval()` 函数中的第二个参数表示任务何时被添加到 UI 队列，而不是一定会在这段时间后执行。定时器代码只有在创建它的函数执行完成之后才有可能被执行。如果调用setTimeout()的函数又调用了其他任务，耗时超过定时器延时，定时器代码将立即被执行，它与主调函数之间没有可察觉的延迟。\n\n同时需要注意的是定时器的精度问题： **定时器延迟通常并不精准，不可用于测量实际时间。所以延迟的最小值建议为25毫秒，以免加上误差延时实际上变得更小，不够进行UI刷新。**\n\n我以前还想过用定时器来 console.log 打印出来运行耗费时间来进行优化测试之类的，这样看来还是 too naive ，所以该怎么记录代码的运行时间？\n\n```javascript\nvar start = +new Date(),\nstop;\nsomeLongProcess();\nstop = +new Date();\nif(stop-start < 50){\n  alert(\"Just about right.\");\n} else {\n  alert(\"Taking too long.\");\n}\n\n```\n\n我们也可以利用类似思路，把需要长时间运行的脚本切割成小任务来执行：\n\n```javascript\nfunction timedProcessArray(items, process, callback){\n  var todo = items.concat(); //create a clone of the original\n  setTimeout(function(){\n    var start = +new Date();\n    do {\n      process(todo.shift());\n    } while (todo.length > 0 && (+new Date() - start < 50));\n    // 检查是否仍有任务需执行\n    if (todo.length > 0){\n      setTimeout(arguments.callee, 25);\n    } else {\n      callback(items);\n    }\n  }, 25);\n}\n```\n\n克隆需执行的任务数组来进行操作，每次取一项并从数组中移除这项(array.shift())，如果此时程序所耗费时间少于50毫秒，那就见缝插针地继续指向任务项，否则就先停止执行代码，25毫秒后继续。\n\n定时器很好用，但是滥用也同样会导致性能问题。\n\n在上面定时器的例子中，我想到了另一个通过定时器来实现的优化点：`函数节流 throttele` 与 `函数防抖 debounce`。\n\n#### Throttle and Debounce\n\n> Throttle 和 Debounce 函数都可以限定函数的执行时间点，在 `window.onresize` 事件中：\n使用 `throttle(action, time)` 可以让 `action` 在 `time` 时间内一定执行且只执行一次;\n使用 `debounce(action, time)` 函数可以让 `action` 在 `resize` 停止 `time` 时间之后执行。\n\n函数节流与防抖都是避免了连续触发事件而导致浏览器崩溃，简单的封装实现：\n\n```javascript\nvar throttle = function (action, time) {\n    var startTime = new Date();\n    return function () {\n        var ctx = this;\n        var currentTime = new Date();\n        if (currentTime - startTime > time) {\n            action.apply(ctx);\n            startTime = currentTime;\n        }\n    };\n};\nwindow.addEventListener('resize', throttle(function () {\n    console.log('resize event')\n}, 1000));\n```\n\n即事件连续触发时，`throttle(action, time)` 中的 `action` 会每隔 `time` 时间就触发一次。\n\n```javascript\nvar debounce = function (action, time) {\n    var timer;\n    return function () {\n        var ctx = this;\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(function () {\n            action.apply(this);\n        }, time);\n    };\n};\nwindow.addEventListener('resize', debounce(function (){\n    console.log('resize');\n}, 1000));\n```\n\n即事件连续触发时，`debounce(action, time)` 中的 `action` 并不会立即执行；当第二次触发 `window.onresize` 事件时，如果两次事件发生的间隔小于 `time`，则仍然不执行 `action`，只有两次间隔大于 `time` 才会执行 `action`。\n\n更多内容可以阅读 [《浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异》](https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs)，文中用电梯策略来讲解节流与防抖的区别，以及在 Underscore.js 中的实现，非常值得一看。\n\n## 7.Ajax\n\n这一节内容比较杂，并且一些内容和优化建议现在并不实用了，大概参考一下吧。\n\n#### GET 与 POST 的区别\n\n> GET 请求是幂等的，经 GET 请求的数据会被缓存起来，对于少量数据而言 GET 请求往服务器只发送一个数据包，POST 请求发送两个数据包，一个装载头信息一个装载 POST 正文。只有当请求的 URL 加上参数的长度接近或超过2048个字符时才使用 POST 获取数据。\n\n这是书中给的信息，然而是不准确的。\n\n实际上，**URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。**，区别主要在语义上，POST 请求并不是明文因而相对更安全，以及书中提到的数据包数量的区别。\n\n更多详细内容可参考 [《浅谈HTTP中Get与Post的区别》](http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)\n\n## 8.编程实践\n\n- 避免双重求值\n  - 避免以 `new Function()` 的形式来创建函数\n  - 避免用 `setTimeout/setInterval` 执行字符串，可改为传入函数\n\n- 使用 Object/Array 直接量可以加快运行并且也节省了代码\n- 用速度最快的部分（位操作，原生 JavaScript）\n\n后面两章没有太多可参考的新内容，都比较过时，就不记录了~ done!\n","slug":"high-performance-javascript-b","published":1,"updated":"2017-11-19T06:52:03.000Z","_id":"cja54xyj2000jgbehrdeduzop","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/javascript-is-fast.png\" alt=\"cover\"></p>\n<p>接<a href=\"http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/\">前四节的总结</a></p>\n<h2 id=\"5-字符串和正则表达式\"><a href=\"#5-字符串和正则表达式\" class=\"headerlink\" title=\"5.字符串和正则表达式\"></a>5.字符串和正则表达式</h2><h4 id=\"字符串构建原理\"><a href=\"#字符串构建原理\" class=\"headerlink\" title=\"字符串构建原理\"></a>字符串构建原理</h4><p><code>str += &#39;one&#39; + &#39;two&#39;</code></p>\n<p>这行代码运行时会经历四个步骤：</p>\n<blockquote>\n<p>1.在内存中创建一个临时字符串<br>2.链接后的字符串 ‘onetwo’ 被赋值给该临时字符串<br>3.临时字符串与 str 当前值连接<br>4.结果赋给 str</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>过程中产生的临时字符串造成了较大的性能开销，应当避免在字符串构建过程中创建临时字符串：</p>\n<p><code>str = str + &#39;one&#39; + &#39;two&#39;</code></p>\n<p>由于IE之外的浏览器会给表达式左侧字符串分配更多内存，然后把第二个字符串拷贝到最左侧字符串的末尾，因此如果在循环中，基础字符串位于最左端，就可以避免重复拷贝一个逐渐变大的基础字符串。</p>\n<p>除此之外，使用数组项合并的方法（<code>Array.prototype.join</code>）比其它字符串连接方法更慢，<code>String.prototype.concat</code> 也比简单的 <code>+</code> 和 <code>+=</code>更慢，构建大字符串时会造成灾难性的性能问题。</p>\n<p>在此也拓展一个vajoy大大提到的知识点， <strong>字符串方法是如何调用的？</strong></p>\n<p>字符串（String）类型属于基本类型，它不是对象，那我们是怎么调用它的 <code>concat</code>、<code>substring</code> 等字符串属性方法呢？</p>\n<p>在 JavaScript 的世界中万物皆对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"some text\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</div><div class=\"line\">s1.color = <span class=\"string\">\"red\"</span>;</div><div class=\"line\">alert(s1.color);  <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>其实在每次调用 s1 的属性方法时，后台都会默默地先执行 <code>s1=new String(&#39;some text&#39;)</code> ，从而让我们可以顺着原型链调用到String对象的属性（比如第二行调用了 <code>substring</code>）。</p>\n<p>在调用完毕后，后台会再默默销毁掉这个先前创建的包装对象，因此在第三行代码执行完毕之后， <code>s1</code>即被销毁，最后 alert 的结果是 <code>undefined</code></p>\n<blockquote>\n<p>“引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。” ——《高程三》</p>\n</blockquote>\n<h4 id=\"正则表达式优化\"><a href=\"#正则表达式优化\" class=\"headerlink\" title=\"正则表达式优化\"></a>正则表达式优化</h4><p>本节内容最重要的是理解 <strong>回溯</strong> ：</p>\n<blockquote>\n<p>回溯法采用试错的思想，它尝试分步的去解决一个问题。</p>\n<p>在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</p>\n<p>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>\n<p>1.找到一个可能存在的正确的答案</p>\n<p>2.在尝试了所有可能的分步方法后宣告该问题没有答案</p>\n<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>\n</blockquote>\n<p>回溯是正则表达式匹配过程中的基础部分，使用不当也会造成非常大的计算消耗。提高效率的方法：</p>\n<ol>\n<li><p>加快匹配失败的过程：正则表达式慢的原因通常是匹配失败的过程慢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'eABC21323AB213'</span>,</div><div class=\"line\">    r1 = <span class=\"regexp\">/\\bAB/</span>.test(str),   <span class=\"comment\">//匹配失败的过程较长</span></div><div class=\"line\">    r2 = <span class=\"regexp\">/^AB/</span>.test(str);    <span class=\"comment\">//匹配失败的过程很短</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>减少分支条件，具体化量词：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'cat 1990'</span>;  <span class=\"comment\">//需匹配：19XX年出生的猫或蝙蝠</span></div><div class=\"line\"><span class=\"keyword\">var</span> r1 = <span class=\"regexp\">/(cat|bat)\\s\\d&#123;4&#125;/</span>.test(str);  <span class=\"comment\">//不推荐</span></div><div class=\"line\"><span class=\"keyword\">var</span> r1 = <span class=\"regexp\">/[bc]at\\s19\\d&#123;2&#125;/</span>.test(str);  <span class=\"comment\">//推荐，减少分支，具体化量词</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用非捕获组，在不需要反向引用的时候</p>\n</li>\n<li><p>只捕获感兴趣的文本以减少后处理：如果需要引用匹配的一部分，应该先捕获那些片段，再用反向引用来处理</p>\n</li>\n<li><p>拆开复杂的表达式：避免在一个正则表达式中处理太多任务。复杂的搜索问题需要条件逻辑，拆分成两个或多个正则表达式更容易解决，通常也会更高效</p>\n</li>\n</ol>\n<h2 id=\"6-快速响应的用户界面\"><a href=\"#6-快速响应的用户界面\" class=\"headerlink\" title=\"6.快速响应的用户界面\"></a>6.快速响应的用户界面</h2><p>有一次和一位月饼厂的安卓开发聊天，她说她最近跟合作的前端沟通很费劲，她一直想弄明白浏览器UI线程是不是单线程，可是那个前端也不明白这个概念，由此引出了对一些前端开发人员业务知识薄弱的吐槽。听的时候我也没法做任何反应，我也并不清楚这个概念 = =</p>\n<p>好在这一章节就围绕浏览器的UI线程展开的，依然是干货很多让人“知其所以然”。</p>\n<h4 id=\"浏览器UI线程\"><a href=\"#浏览器UI线程\" class=\"headerlink\" title=\"浏览器UI线程\"></a>浏览器UI线程</h4><blockquote>\n<p>大多数浏览器让一个单线程共用于执行 JavaScript 和更新用户界面，每个时刻只能执行其中一种操作，这意味着当 JavaScript 代码正在执行时用户界面无法响应输入，反之亦然。</p>\n</blockquote>\n<p>好像是很容易理解的，但还是深入了解一下 wikipedia 中 <code>线程</code> 的定义：</p>\n<blockquote>\n<p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>\n</blockquote>\n<p>再看一下什么是 <code>进程</code>：</p>\n<blockquote>\n<p>进程（英语：process），是计算机中已运行程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p>\n<p>用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。<br>进程需要一些资源才能完成工作，如CPU使用时间、内存、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。</p>\n</blockquote>\n<p>然而常规浏览器并不会只有一个线程在运作，主要线程可归类为：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/561179/201601/561179-20160103131737151-1750514444.jpg\" alt=\"common thread\"></p>\n<p>基础知识补到这里，半路出家的程序员心好累。</p>\n<p><strong>UI线程的工作基于一个简单的队列系统</strong> ，任务会保存到队列中直到线程空闲，一旦空闲队列中的下一个任务就被重新提取出来并运行。先看一个简单的交互例子来理解UI线程的队列系统：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">    &lt;title&gt;Browser UI Thread Example&lt;/title&gt;</div><div class=\"line\">  &lt;/head&gt;</div><div class=\"line\">  &lt;body&gt;</div><div class=\"line\">    &lt;button onclick=\"handleClick()\"&gt;Click Me&lt;/button&gt;</div><div class=\"line\">    &lt;script type=\"text/javascript\"&gt;</div><div class=\"line\">      function handleClick()&#123;</div><div class=\"line\">        var div = document.createElement(\"div\");</div><div class=\"line\">        div.innerHTML = \"Clicked!\";</div><div class=\"line\">        document.body.appendChild(div);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &lt;/script&gt;</div><div class=\"line\">  &lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>按钮上绑定了一个点击事件，点击后会调用 <code>handleClick()</code> 函数。</p>\n<p><img src=\"http://hi.csdn.net/attachment/201005/31/0_12752710809o5M.gif\" alt=\"thread\"></p>\n<ol>\n<li><p>按钮被点击，触发UI线程创建两个任务并添加到队列中。</p>\n<ul>\n<li>更新按钮UI</li>\n<li>执行 JavaScript 即执行 <code>handleClick()</code> 函数段代码</li>\n</ul>\n</li>\n<li><p>执行 JavaScript 过程中创建了新的 div 元素并附加在 body 后，又触发了一次UI更新</p>\n</li>\n</ol>\n<p>大多数浏览器在 JavaScript 运行时会停止吧新任务加入 UI 线程的队列中，因此如果用户试图在任务运行期间与页面交互，不仅没有即时的 UI 更新，可能连 UI 更新任务都不会加入到队列中。</p>\n<blockquote>\n<p>当脚本执行时，UI 不随用户交互而更新，执行时间段内用户交互行为所引发的 JavaScript 任务会被加入队列中，并在最初的 JavaScript 任务完成后一次执行。而这段时间里由交互行为引发的 UI 更新会被自动跳过。因此在一个脚本运行期间点击一个按钮，将无法看到它被按下的样式，尽管它的 onclick 事件处理器会被执行。</p>\n</blockquote>\n<h4 id=\"使用定时器进行优化\"><a href=\"#使用定时器进行优化\" class=\"headerlink\" title=\"使用定时器进行优化\"></a>使用定时器进行优化</h4><p><strong>单个 JavaScript 操作花费的总时间不应该超过100毫秒。否则用户会感到与界面失去联系。</strong></p>\n<p>有一些复杂的任务无法在100毫秒内执行完毕则需要停止 JavaScript 的执行，让出线程控制权使得 UI 可以更新。因此我们需要使用定时器进行优化。</p>\n<p>创建一个定时器会造成 UI 线程暂停，也会重置所有相关的浏览器限制，包括长时间运行脚本定时器和调用栈。这使得定时器成为长时间运行 JavaScript 代码理想的跨浏览器解决方案。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"my-button\"</span>);</div><div class=\"line\">button.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  oneMethod();</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"notice\"</span>).style.color = <span class=\"string\">\"red\"</span>;</div><div class=\"line\">  &#125;, <span class=\"number\">250</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>需要注意 <code>setTimeout()</code> 和 <code>setInterval()</code> 函数中的第二个参数表示任务何时被添加到 UI 队列，而不是一定会在这段时间后执行。定时器代码只有在创建它的函数执行完成之后才有可能被执行。如果调用setTimeout()的函数又调用了其他任务，耗时超过定时器延时，定时器代码将立即被执行，它与主调函数之间没有可察觉的延迟。</p>\n<p>同时需要注意的是定时器的精度问题： <strong>定时器延迟通常并不精准，不可用于测量实际时间。所以延迟的最小值建议为25毫秒，以免加上误差延时实际上变得更小，不够进行UI刷新。</strong></p>\n<p>我以前还想过用定时器来 console.log 打印出来运行耗费时间来进行优化测试之类的，这样看来还是 too naive ，所以该怎么记录代码的运行时间？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> start = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</div><div class=\"line\">stop;</div><div class=\"line\">someLongProcess();</div><div class=\"line\">stop = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">if</span>(stop-start &lt; <span class=\"number\">50</span>)&#123;</div><div class=\"line\">  alert(<span class=\"string\">\"Just about right.\"</span>);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  alert(<span class=\"string\">\"Taking too long.\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们也可以利用类似思路，把需要长时间运行的脚本切割成小任务来执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timedProcessArray</span>(<span class=\"params\">items, process, callback</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> todo = items.concat(); <span class=\"comment\">//create a clone of the original</span></div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> start = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">    <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">      process(todo.shift());</div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (todo.length &gt; <span class=\"number\">0</span> &amp;&amp; (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - start &lt; <span class=\"number\">50</span>));</div><div class=\"line\">    <span class=\"comment\">// 检查是否仍有任务需执行</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (todo.length &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">      setTimeout(<span class=\"built_in\">arguments</span>.callee, <span class=\"number\">25</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      callback(items);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"number\">25</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>克隆需执行的任务数组来进行操作，每次取一项并从数组中移除这项(array.shift())，如果此时程序所耗费时间少于50毫秒，那就见缝插针地继续指向任务项，否则就先停止执行代码，25毫秒后继续。</p>\n<p>定时器很好用，但是滥用也同样会导致性能问题。</p>\n<p>在上面定时器的例子中，我想到了另一个通过定时器来实现的优化点：<code>函数节流 throttele</code> 与 <code>函数防抖 debounce</code>。</p>\n<h4 id=\"Throttle-and-Debounce\"><a href=\"#Throttle-and-Debounce\" class=\"headerlink\" title=\"Throttle and Debounce\"></a>Throttle and Debounce</h4><blockquote>\n<p>Throttle 和 Debounce 函数都可以限定函数的执行时间点，在 <code>window.onresize</code> 事件中：<br>使用 <code>throttle(action, time)</code> 可以让 <code>action</code> 在 <code>time</code> 时间内一定执行且只执行一次;<br>使用 <code>debounce(action, time)</code> 函数可以让 <code>action</code> 在 <code>resize</code> 停止 <code>time</code> 时间之后执行。</p>\n</blockquote>\n<p>函数节流与防抖都是避免了连续触发事件而导致浏览器崩溃，简单的封装实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action, time</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> ctx = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> currentTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">        <span class=\"keyword\">if</span> (currentTime - startTime &gt; time) &#123;</div><div class=\"line\">            action.apply(ctx);</div><div class=\"line\">            startTime = currentTime;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, throttle(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resize event'</span>)</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>));</div></pre></td></tr></table></figure>\n<p>即事件连续触发时，<code>throttle(action, time)</code> 中的 <code>action</code> 会每隔 <code>time</code> 时间就触发一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action, time</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> timer;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> ctx = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (timer) &#123;</div><div class=\"line\">            clearTimeout(timer);</div><div class=\"line\">        &#125;</div><div class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            action.apply(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;, time);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, debounce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resize'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>));</div></pre></td></tr></table></figure>\n<p>即事件连续触发时，<code>debounce(action, time)</code> 中的 <code>action</code> 并不会立即执行；当第二次触发 <code>window.onresize</code> 事件时，如果两次事件发生的间隔小于 <code>time</code>，则仍然不执行 <code>action</code>，只有两次间隔大于 <code>time</code> 才会执行 <code>action</code>。</p>\n<p>更多内容可以阅读 <a href=\"https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\" target=\"_blank\" rel=\"external\">《浅谈 Underscore.js 中 <em>.throttle 和 </em>.debounce 的差异》</a>，文中用电梯策略来讲解节流与防抖的区别，以及在 Underscore.js 中的实现，非常值得一看。</p>\n<h2 id=\"7-Ajax\"><a href=\"#7-Ajax\" class=\"headerlink\" title=\"7.Ajax\"></a>7.Ajax</h2><p>这一节内容比较杂，并且一些内容和优化建议现在并不实用了，大概参考一下吧。</p>\n<h4 id=\"GET-与-POST-的区别\"><a href=\"#GET-与-POST-的区别\" class=\"headerlink\" title=\"GET 与 POST 的区别\"></a>GET 与 POST 的区别</h4><blockquote>\n<p>GET 请求是幂等的，经 GET 请求的数据会被缓存起来，对于少量数据而言 GET 请求往服务器只发送一个数据包，POST 请求发送两个数据包，一个装载头信息一个装载 POST 正文。只有当请求的 URL 加上参数的长度接近或超过2048个字符时才使用 POST 获取数据。</p>\n</blockquote>\n<p>这是书中给的信息，然而是不准确的。</p>\n<p>实际上，<strong>URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。</strong>，区别主要在语义上，POST 请求并不是明文因而相对更安全，以及书中提到的数据包数量的区别。</p>\n<p>更多详细内容可参考 <a href=\"http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html\" target=\"_blank\" rel=\"external\">《浅谈HTTP中Get与Post的区别》</a></p>\n<h2 id=\"8-编程实践\"><a href=\"#8-编程实践\" class=\"headerlink\" title=\"8.编程实践\"></a>8.编程实践</h2><ul>\n<li><p>避免双重求值</p>\n<ul>\n<li>避免以 <code>new Function()</code> 的形式来创建函数</li>\n<li>避免用 <code>setTimeout/setInterval</code> 执行字符串，可改为传入函数</li>\n</ul>\n</li>\n<li><p>使用 Object/Array 直接量可以加快运行并且也节省了代码</p>\n</li>\n<li>用速度最快的部分（位操作，原生 JavaScript）</li>\n</ul>\n<p>后面两章没有太多可参考的新内容，都比较过时，就不记录了~ done!</p>\n","excerpt":"<p><img src=\"/images/javascript-is-fast.png\" alt=\"cover\"></p>\n<p>接<a href=\"http://mechanicianw.github.io/2016/09/26/high-performance-javascript-a/\">前四节的总结</a></p>\n<h2 id=\"5-字符串和正则表达式\"><a href=\"#5-字符串和正则表达式\" class=\"headerlink\" title=\"5.字符串和正则表达式\"></a>5.字符串和正则表达式</h2><h4 id=\"字符串构建原理\"><a href=\"#字符串构建原理\" class=\"headerlink\" title=\"字符串构建原理\"></a>字符串构建原理</h4><p><code>str += &#39;one&#39; + &#39;two&#39;</code></p>\n<p>这行代码运行时会经历四个步骤：</p>\n<blockquote>\n<p>1.在内存中创建一个临时字符串<br>2.链接后的字符串 ‘onetwo’ 被赋值给该临时字符串<br>3.临时字符串与 str 当前值连接<br>4.结果赋给 str</p>\n</blockquote>","more":"<p>过程中产生的临时字符串造成了较大的性能开销，应当避免在字符串构建过程中创建临时字符串：</p>\n<p><code>str = str + &#39;one&#39; + &#39;two&#39;</code></p>\n<p>由于IE之外的浏览器会给表达式左侧字符串分配更多内存，然后把第二个字符串拷贝到最左侧字符串的末尾，因此如果在循环中，基础字符串位于最左端，就可以避免重复拷贝一个逐渐变大的基础字符串。</p>\n<p>除此之外，使用数组项合并的方法（<code>Array.prototype.join</code>）比其它字符串连接方法更慢，<code>String.prototype.concat</code> 也比简单的 <code>+</code> 和 <code>+=</code>更慢，构建大字符串时会造成灾难性的性能问题。</p>\n<p>在此也拓展一个vajoy大大提到的知识点， <strong>字符串方法是如何调用的？</strong></p>\n<p>字符串（String）类型属于基本类型，它不是对象，那我们是怎么调用它的 <code>concat</code>、<code>substring</code> 等字符串属性方法呢？</p>\n<p>在 JavaScript 的世界中万物皆对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"some text\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</div><div class=\"line\">s1.color = <span class=\"string\">\"red\"</span>;</div><div class=\"line\">alert(s1.color);  <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>其实在每次调用 s1 的属性方法时，后台都会默默地先执行 <code>s1=new String(&#39;some text&#39;)</code> ，从而让我们可以顺着原型链调用到String对象的属性（比如第二行调用了 <code>substring</code>）。</p>\n<p>在调用完毕后，后台会再默默销毁掉这个先前创建的包装对象，因此在第三行代码执行完毕之后， <code>s1</code>即被销毁，最后 alert 的结果是 <code>undefined</code></p>\n<blockquote>\n<p>“引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。” ——《高程三》</p>\n</blockquote>\n<h4 id=\"正则表达式优化\"><a href=\"#正则表达式优化\" class=\"headerlink\" title=\"正则表达式优化\"></a>正则表达式优化</h4><p>本节内容最重要的是理解 <strong>回溯</strong> ：</p>\n<blockquote>\n<p>回溯法采用试错的思想，它尝试分步的去解决一个问题。</p>\n<p>在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</p>\n<p>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>\n<p>1.找到一个可能存在的正确的答案</p>\n<p>2.在尝试了所有可能的分步方法后宣告该问题没有答案</p>\n<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>\n</blockquote>\n<p>回溯是正则表达式匹配过程中的基础部分，使用不当也会造成非常大的计算消耗。提高效率的方法：</p>\n<ol>\n<li><p>加快匹配失败的过程：正则表达式慢的原因通常是匹配失败的过程慢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'eABC21323AB213'</span>,</div><div class=\"line\">    r1 = <span class=\"regexp\">/\\bAB/</span>.test(str),   <span class=\"comment\">//匹配失败的过程较长</span></div><div class=\"line\">    r2 = <span class=\"regexp\">/^AB/</span>.test(str);    <span class=\"comment\">//匹配失败的过程很短</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>减少分支条件，具体化量词：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'cat 1990'</span>;  <span class=\"comment\">//需匹配：19XX年出生的猫或蝙蝠</span></div><div class=\"line\"><span class=\"keyword\">var</span> r1 = <span class=\"regexp\">/(cat|bat)\\s\\d&#123;4&#125;/</span>.test(str);  <span class=\"comment\">//不推荐</span></div><div class=\"line\"><span class=\"keyword\">var</span> r1 = <span class=\"regexp\">/[bc]at\\s19\\d&#123;2&#125;/</span>.test(str);  <span class=\"comment\">//推荐，减少分支，具体化量词</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用非捕获组，在不需要反向引用的时候</p>\n</li>\n<li><p>只捕获感兴趣的文本以减少后处理：如果需要引用匹配的一部分，应该先捕获那些片段，再用反向引用来处理</p>\n</li>\n<li><p>拆开复杂的表达式：避免在一个正则表达式中处理太多任务。复杂的搜索问题需要条件逻辑，拆分成两个或多个正则表达式更容易解决，通常也会更高效</p>\n</li>\n</ol>\n<h2 id=\"6-快速响应的用户界面\"><a href=\"#6-快速响应的用户界面\" class=\"headerlink\" title=\"6.快速响应的用户界面\"></a>6.快速响应的用户界面</h2><p>有一次和一位月饼厂的安卓开发聊天，她说她最近跟合作的前端沟通很费劲，她一直想弄明白浏览器UI线程是不是单线程，可是那个前端也不明白这个概念，由此引出了对一些前端开发人员业务知识薄弱的吐槽。听的时候我也没法做任何反应，我也并不清楚这个概念 = =</p>\n<p>好在这一章节就围绕浏览器的UI线程展开的，依然是干货很多让人“知其所以然”。</p>\n<h4 id=\"浏览器UI线程\"><a href=\"#浏览器UI线程\" class=\"headerlink\" title=\"浏览器UI线程\"></a>浏览器UI线程</h4><blockquote>\n<p>大多数浏览器让一个单线程共用于执行 JavaScript 和更新用户界面，每个时刻只能执行其中一种操作，这意味着当 JavaScript 代码正在执行时用户界面无法响应输入，反之亦然。</p>\n</blockquote>\n<p>好像是很容易理解的，但还是深入了解一下 wikipedia 中 <code>线程</code> 的定义：</p>\n<blockquote>\n<p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>\n</blockquote>\n<p>再看一下什么是 <code>进程</code>：</p>\n<blockquote>\n<p>进程（英语：process），是计算机中已运行程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p>\n<p>用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。<br>进程需要一些资源才能完成工作，如CPU使用时间、内存、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。</p>\n</blockquote>\n<p>然而常规浏览器并不会只有一个线程在运作，主要线程可归类为：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/561179/201601/561179-20160103131737151-1750514444.jpg\" alt=\"common thread\"></p>\n<p>基础知识补到这里，半路出家的程序员心好累。</p>\n<p><strong>UI线程的工作基于一个简单的队列系统</strong> ，任务会保存到队列中直到线程空闲，一旦空闲队列中的下一个任务就被重新提取出来并运行。先看一个简单的交互例子来理解UI线程的队列系统：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">    &lt;title&gt;Browser UI Thread Example&lt;/title&gt;</div><div class=\"line\">  &lt;/head&gt;</div><div class=\"line\">  &lt;body&gt;</div><div class=\"line\">    &lt;button onclick=\"handleClick()\"&gt;Click Me&lt;/button&gt;</div><div class=\"line\">    &lt;script type=\"text/javascript\"&gt;</div><div class=\"line\">      function handleClick()&#123;</div><div class=\"line\">        var div = document.createElement(\"div\");</div><div class=\"line\">        div.innerHTML = \"Clicked!\";</div><div class=\"line\">        document.body.appendChild(div);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &lt;/script&gt;</div><div class=\"line\">  &lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>按钮上绑定了一个点击事件，点击后会调用 <code>handleClick()</code> 函数。</p>\n<p><img src=\"http://hi.csdn.net/attachment/201005/31/0_12752710809o5M.gif\" alt=\"thread\"></p>\n<ol>\n<li><p>按钮被点击，触发UI线程创建两个任务并添加到队列中。</p>\n<ul>\n<li>更新按钮UI</li>\n<li>执行 JavaScript 即执行 <code>handleClick()</code> 函数段代码</li>\n</ul>\n</li>\n<li><p>执行 JavaScript 过程中创建了新的 div 元素并附加在 body 后，又触发了一次UI更新</p>\n</li>\n</ol>\n<p>大多数浏览器在 JavaScript 运行时会停止吧新任务加入 UI 线程的队列中，因此如果用户试图在任务运行期间与页面交互，不仅没有即时的 UI 更新，可能连 UI 更新任务都不会加入到队列中。</p>\n<blockquote>\n<p>当脚本执行时，UI 不随用户交互而更新，执行时间段内用户交互行为所引发的 JavaScript 任务会被加入队列中，并在最初的 JavaScript 任务完成后一次执行。而这段时间里由交互行为引发的 UI 更新会被自动跳过。因此在一个脚本运行期间点击一个按钮，将无法看到它被按下的样式，尽管它的 onclick 事件处理器会被执行。</p>\n</blockquote>\n<h4 id=\"使用定时器进行优化\"><a href=\"#使用定时器进行优化\" class=\"headerlink\" title=\"使用定时器进行优化\"></a>使用定时器进行优化</h4><p><strong>单个 JavaScript 操作花费的总时间不应该超过100毫秒。否则用户会感到与界面失去联系。</strong></p>\n<p>有一些复杂的任务无法在100毫秒内执行完毕则需要停止 JavaScript 的执行，让出线程控制权使得 UI 可以更新。因此我们需要使用定时器进行优化。</p>\n<p>创建一个定时器会造成 UI 线程暂停，也会重置所有相关的浏览器限制，包括长时间运行脚本定时器和调用栈。这使得定时器成为长时间运行 JavaScript 代码理想的跨浏览器解决方案。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"my-button\"</span>);</div><div class=\"line\">button.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  oneMethod();</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"notice\"</span>).style.color = <span class=\"string\">\"red\"</span>;</div><div class=\"line\">  &#125;, <span class=\"number\">250</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>需要注意 <code>setTimeout()</code> 和 <code>setInterval()</code> 函数中的第二个参数表示任务何时被添加到 UI 队列，而不是一定会在这段时间后执行。定时器代码只有在创建它的函数执行完成之后才有可能被执行。如果调用setTimeout()的函数又调用了其他任务，耗时超过定时器延时，定时器代码将立即被执行，它与主调函数之间没有可察觉的延迟。</p>\n<p>同时需要注意的是定时器的精度问题： <strong>定时器延迟通常并不精准，不可用于测量实际时间。所以延迟的最小值建议为25毫秒，以免加上误差延时实际上变得更小，不够进行UI刷新。</strong></p>\n<p>我以前还想过用定时器来 console.log 打印出来运行耗费时间来进行优化测试之类的，这样看来还是 too naive ，所以该怎么记录代码的运行时间？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> start = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</div><div class=\"line\">stop;</div><div class=\"line\">someLongProcess();</div><div class=\"line\">stop = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">if</span>(stop-start &lt; <span class=\"number\">50</span>)&#123;</div><div class=\"line\">  alert(<span class=\"string\">\"Just about right.\"</span>);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  alert(<span class=\"string\">\"Taking too long.\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们也可以利用类似思路，把需要长时间运行的脚本切割成小任务来执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timedProcessArray</span>(<span class=\"params\">items, process, callback</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> todo = items.concat(); <span class=\"comment\">//create a clone of the original</span></div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> start = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">    <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">      process(todo.shift());</div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (todo.length &gt; <span class=\"number\">0</span> &amp;&amp; (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - start &lt; <span class=\"number\">50</span>));</div><div class=\"line\">    <span class=\"comment\">// 检查是否仍有任务需执行</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (todo.length &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">      setTimeout(<span class=\"built_in\">arguments</span>.callee, <span class=\"number\">25</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      callback(items);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"number\">25</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>克隆需执行的任务数组来进行操作，每次取一项并从数组中移除这项(array.shift())，如果此时程序所耗费时间少于50毫秒，那就见缝插针地继续指向任务项，否则就先停止执行代码，25毫秒后继续。</p>\n<p>定时器很好用，但是滥用也同样会导致性能问题。</p>\n<p>在上面定时器的例子中，我想到了另一个通过定时器来实现的优化点：<code>函数节流 throttele</code> 与 <code>函数防抖 debounce</code>。</p>\n<h4 id=\"Throttle-and-Debounce\"><a href=\"#Throttle-and-Debounce\" class=\"headerlink\" title=\"Throttle and Debounce\"></a>Throttle and Debounce</h4><blockquote>\n<p>Throttle 和 Debounce 函数都可以限定函数的执行时间点，在 <code>window.onresize</code> 事件中：<br>使用 <code>throttle(action, time)</code> 可以让 <code>action</code> 在 <code>time</code> 时间内一定执行且只执行一次;<br>使用 <code>debounce(action, time)</code> 函数可以让 <code>action</code> 在 <code>resize</code> 停止 <code>time</code> 时间之后执行。</p>\n</blockquote>\n<p>函数节流与防抖都是避免了连续触发事件而导致浏览器崩溃，简单的封装实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action, time</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> ctx = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> currentTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">        <span class=\"keyword\">if</span> (currentTime - startTime &gt; time) &#123;</div><div class=\"line\">            action.apply(ctx);</div><div class=\"line\">            startTime = currentTime;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, throttle(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resize event'</span>)</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>));</div></pre></td></tr></table></figure>\n<p>即事件连续触发时，<code>throttle(action, time)</code> 中的 <code>action</code> 会每隔 <code>time</code> 时间就触发一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action, time</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> timer;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> ctx = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (timer) &#123;</div><div class=\"line\">            clearTimeout(timer);</div><div class=\"line\">        &#125;</div><div class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            action.apply(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;, time);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, debounce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resize'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>));</div></pre></td></tr></table></figure>\n<p>即事件连续触发时，<code>debounce(action, time)</code> 中的 <code>action</code> 并不会立即执行；当第二次触发 <code>window.onresize</code> 事件时，如果两次事件发生的间隔小于 <code>time</code>，则仍然不执行 <code>action</code>，只有两次间隔大于 <code>time</code> 才会执行 <code>action</code>。</p>\n<p>更多内容可以阅读 <a href=\"https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs\">《浅谈 Underscore.js 中 <em>.throttle 和 </em>.debounce 的差异》</a>，文中用电梯策略来讲解节流与防抖的区别，以及在 Underscore.js 中的实现，非常值得一看。</p>\n<h2 id=\"7-Ajax\"><a href=\"#7-Ajax\" class=\"headerlink\" title=\"7.Ajax\"></a>7.Ajax</h2><p>这一节内容比较杂，并且一些内容和优化建议现在并不实用了，大概参考一下吧。</p>\n<h4 id=\"GET-与-POST-的区别\"><a href=\"#GET-与-POST-的区别\" class=\"headerlink\" title=\"GET 与 POST 的区别\"></a>GET 与 POST 的区别</h4><blockquote>\n<p>GET 请求是幂等的，经 GET 请求的数据会被缓存起来，对于少量数据而言 GET 请求往服务器只发送一个数据包，POST 请求发送两个数据包，一个装载头信息一个装载 POST 正文。只有当请求的 URL 加上参数的长度接近或超过2048个字符时才使用 POST 获取数据。</p>\n</blockquote>\n<p>这是书中给的信息，然而是不准确的。</p>\n<p>实际上，<strong>URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。</strong>，区别主要在语义上，POST 请求并不是明文因而相对更安全，以及书中提到的数据包数量的区别。</p>\n<p>更多详细内容可参考 <a href=\"http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html\">《浅谈HTTP中Get与Post的区别》</a></p>\n<h2 id=\"8-编程实践\"><a href=\"#8-编程实践\" class=\"headerlink\" title=\"8.编程实践\"></a>8.编程实践</h2><ul>\n<li><p>避免双重求值</p>\n<ul>\n<li>避免以 <code>new Function()</code> 的形式来创建函数</li>\n<li>避免用 <code>setTimeout/setInterval</code> 执行字符串，可改为传入函数</li>\n</ul>\n</li>\n<li><p>使用 Object/Array 直接量可以加快运行并且也节省了代码</p>\n</li>\n<li>用速度最快的部分（位操作，原生 JavaScript）</li>\n</ul>\n<p>后面两章没有太多可参考的新内容，都比较过时，就不记录了~ done!</p>"},{"layout":"post","title":"tips:编写邮件中的html文件","date":"2015-12-03T09:31:00.000Z","_content":"\n最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。\n\n如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。\n目前常见的邮箱客户端有Gmail，Outlook等，[不同邮箱客户端对CSS样式的支持情况](https://www.campaignmonitor.com/css/)也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。\n1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。\n\n<!--more-->\n\n```\n<div style=\"width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;\">\n    内容区域\n</div>\n```\n\n2.网页的布局必须使用表格\n\n```\n<div style=\"text-align:center;\">\n    <table width=\"600\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"margin:0 auto;\"><tbody><tr><td>\n        <div style=\"width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;\">\n\n            <!-- 水平居中的邮件 -->\n\n        </div>\n    </td></tr></tbody></table>\n</div>\n```\n\n3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读\n\n4.如果想测试自己写的html在邮件中效果，可以使用这个网站（https://litmus.com/）\n这是我测试页面时的截图：\n\n![](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png)","source":"_posts/html-in-email.md","raw":"---\nlayout: post\ntitle:  \"tips:编写邮件中的html文件\"\ndate:   2015-12-03 17:31\ncategories: front-end css\n---\n\n最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。\n\n如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。\n目前常见的邮箱客户端有Gmail，Outlook等，[不同邮箱客户端对CSS样式的支持情况](https://www.campaignmonitor.com/css/)也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。\n1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。\n\n<!--more-->\n\n```\n<div style=\"width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;\">\n    内容区域\n</div>\n```\n\n2.网页的布局必须使用表格\n\n```\n<div style=\"text-align:center;\">\n    <table width=\"600\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"margin:0 auto;\"><tbody><tr><td>\n        <div style=\"width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;\">\n\n            <!-- 水平居中的邮件 -->\n\n        </div>\n    </td></tr></tbody></table>\n</div>\n```\n\n3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读\n\n4.如果想测试自己写的html在邮件中效果，可以使用这个网站（https://litmus.com/）\n这是我测试页面时的截图：\n\n![](http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png)","slug":"html-in-email","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyj7000lgbehwzurecyj","content":"<p>最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。</p>\n<p>如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。<br>目前常见的邮箱客户端有Gmail，Outlook等，<a href=\"https://www.campaignmonitor.com/css/\" target=\"_blank\" rel=\"external\">不同邮箱客户端对CSS样式的支持情况</a>也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。<br>1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。</div></p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;&quot;&gt;</div><div class=\"line\">    内容区域</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>2.网页的布局必须使用表格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;text-align:center;&quot;&gt;</div><div class=\"line\">    &lt;table width=&quot;600&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;margin:0 auto;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;</div><div class=\"line\">        &lt;div style=&quot;width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">            &lt;!-- 水平居中的邮件 --&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读</p>\n<p>4.如果想测试自己写的html在邮件中效果，可以使用这个网站（<a href=\"https://litmus.com/）\" target=\"_blank\" rel=\"external\">https://litmus.com/）</a><br>这是我测试页面时的截图：</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png\" alt=\"\"></p>\n","excerpt":"<p>最近在做的招聘模块里，有个需求是这样的，用户把中意的简历通过邮箱转发。</p>\n<p>如果直接发送现有的简历详情页的话，在邮件里无法正常显示，查阅了一些资料，最后又写了单独一版邮件用的html文件。<br>目前常见的邮箱客户端有Gmail，Outlook等，<a href=\"https://www.campaignmonitor.com/css/\">不同邮箱客户端对CSS样式的支持情况</a>也不同。平时CSS样式一般写在header标签里或者外联一个CSS文件，但是在邮件中这些都会通通失效。<br>1.由于我们想要发送的内容是嵌套在客户端内的，所以它不会是完整的html文件，应该为<div>容器内的代码片段。并且由于邮箱自身设置了CSS样式，它可能会对我们的样式产生影响，所以我们应该尽量都使用行内样式。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;width:600px;text-align:left;color:#000;font:normal 12px/15px arial,simsun;background:#fff;&quot;&gt;</div><div class=\"line\">    内容区域</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>2.网页的布局必须使用表格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;text-align:center;&quot;&gt;</div><div class=\"line\">    &lt;table width=&quot;600&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;margin:0 auto;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;</div><div class=\"line\">        &lt;div style=&quot;width:600px;text-align:left;font:12px/15px simsun;color:#000;background:#fff;&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">            &lt;!-- 水平居中的邮件 --&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>3.在引入图片时需要注意，有的客户端会默认不显示图片，所以要确保图片不显示的情况下，也不会影响正文的阅读</p>\n<p>4.如果想测试自己写的html在邮件中效果，可以使用这个网站（<a href=\"https://litmus.com/）\">https://litmus.com/）</a><br>这是我测试页面时的截图：</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720151202143934.png\" alt=\"\"></p>"},{"layout":"post","title":"150824去哪儿网面试总结","date":"2015-08-24T14:20:24.000Z","_content":"1.get()与post()的区别\n\nHttp定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。\n\n根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。\n\n根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\nGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。\n\nPOST的安全性要比GET的安全性高：\n\n<!--more-->\n\n通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n2.CSS优先级   [参考内容](http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html)\n\n（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style\n\n选择器优先权（权重）：\n\n1.  内联样式表的权值最高 1000；\n\n2.  ID 选择器的权值为 100\n\n3.  Class 类选择器的权值为 10\n\n4.  HTML 标签选择器的权值为 1\n\n![](http://www.nowamagic.net/csszone/images/priority_rules_1.jpg)\n\nCSS **优先级法则：**\n\nA  选择器都有一个权值，权值越大越优先；\n\nB  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；\n\nC  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；\n\nD  继承的CSS 样式不如后来指定的CSS 样式；\n\nE  在同一组属性设置中标有“!important”规则的优先级最大\n\n3.一次请求的完整流程\n\n① 建立TCP连接\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n② Web浏览器向Web服务器发送请求命令\n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n③ Web浏览器发送请求头信息\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n④ Web服务器应答\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n⑤ Web服务器发送应答头信息\n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n⑥ Web服务器向浏览器发送数据\n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n⑦ Web服务器关闭TCP连接\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN\n\n“8”*11=88\n\n“8a”*11=NaN","source":"_posts/intern-qunar-interview.markdown","raw":"---\nlayout: post\ntitle:  \"150824去哪儿网面试总结\"\ndate:   2015-08-24 22:20:24\ncategories: front-end interview\n---\n1.get()与post()的区别\n\nHttp定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。\n\n根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。\n\n根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n\nGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。\n\nPOST的安全性要比GET的安全性高：\n\n<!--more-->\n\n通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n\n2.CSS优先级   [参考内容](http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html)\n\n（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style\n\n选择器优先权（权重）：\n\n1.  内联样式表的权值最高 1000；\n\n2.  ID 选择器的权值为 100\n\n3.  Class 类选择器的权值为 10\n\n4.  HTML 标签选择器的权值为 1\n\n![](http://www.nowamagic.net/csszone/images/priority_rules_1.jpg)\n\nCSS **优先级法则：**\n\nA  选择器都有一个权值，权值越大越优先；\n\nB  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；\n\nC  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；\n\nD  继承的CSS 样式不如后来指定的CSS 样式；\n\nE  在同一组属性设置中标有“!important”规则的优先级最大\n\n3.一次请求的完整流程\n\n① 建立TCP连接\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n② Web浏览器向Web服务器发送请求命令\n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n③ Web浏览器发送请求头信息\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n④ Web服务器应答\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n⑤ Web服务器发送应答头信息\n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n⑥ Web服务器向浏览器发送数据\n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n⑦ Web服务器关闭TCP连接\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN\n\n“8”*11=88\n\n“8a”*11=NaN","slug":"intern-qunar-interview","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyjc000ogbehceyfwznd","content":"<p>1.get()与post()的区别</p>\n<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>\n<p>根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。</p>\n<p>根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。</p>\n<p>POST的安全性要比GET的安全性高：</p>\n<a id=\"more\"></a>\n<p>通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n<p>2.CSS优先级   <a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\" target=\"_blank\" rel=\"external\">参考内容</a></p>\n<p>（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style</p>\n<p>选择器优先权（权重）：</p>\n<ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<p><img src=\"http://www.nowamagic.net/csszone/images/priority_rules_1.jpg\" alt=\"\"></p>\n<p>CSS <strong>优先级法则：</strong></p>\n<p>A  选择器都有一个权值，权值越大越优先；</p>\n<p>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p>\n<p>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p>\n<p>D  继承的CSS 样式不如后来指定的CSS 样式；</p>\n<p>E  在同一组属性设置中标有“!important”规则的优先级最大</p>\n<p>3.一次请求的完整流程</p>\n<p>① 建立TCP连接</p>\n<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p>② Web浏览器向Web服务器发送请求命令</p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p>③ Web浏览器发送请求头信息</p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>④ Web服务器应答</p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p>⑤ Web服务器发送应答头信息</p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<p>⑥ Web服务器向浏览器发送数据</p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p>⑦ Web服务器关闭TCP连接</p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p>4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN</p>\n<p>“8”*11=88</p>\n<p>“8a”*11=NaN</p>\n","excerpt":"<p>1.get()与post()的区别</p>\n<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>\n<p>根据HTTP规范，GET用于信息获取，而且应该是安全的（是非修改信息）和幂等（同一URL的多个请求应该返回同样的结果）的。</p>\n<p>根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>\n<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据则放置在是HTTP包的包体中。</p>\n<p>POST的安全性要比GET的安全性高：</p>","more":"<p>通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>\n<p>2.CSS优先级   <a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\">参考内容</a></p>\n<p>（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style</p>\n<p>选择器优先权（权重）：</p>\n<ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<p><img src=\"http://www.nowamagic.net/csszone/images/priority_rules_1.jpg\" alt=\"\"></p>\n<p>CSS <strong>优先级法则：</strong></p>\n<p>A  选择器都有一个权值，权值越大越优先；</p>\n<p>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p>\n<p>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p>\n<p>D  继承的CSS 样式不如后来指定的CSS 样式；</p>\n<p>E  在同一组属性设置中标有“!important”规则的优先级最大</p>\n<p>3.一次请求的完整流程</p>\n<p>① 建立TCP连接</p>\n<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p>② Web浏览器向Web服务器发送请求命令</p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p>③ Web浏览器发送请求头信息</p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>④ Web服务器应答</p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p>⑤ Web服务器发送应答头信息</p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<p>⑥ Web服务器向浏览器发送数据</p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p>⑦ Web服务器关闭TCP连接</p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p>4.遇算术运算符，进行自动类型转换Number，如果不能转，则输出NaN</p>\n<p>“8”*11=88</p>\n<p>“8a”*11=NaN</p>"},{"layout":"post","title":"Before learning the functional programming and design patterns","date":"2016-11-17T13:15:00.000Z","_content":"\n![cover](images/JavaScript-for-Kids.png)\n\n## 基础知识\n\n### OOP In JavaScript\n\n#### Duck Typing 鸭子类型\n\nJavaScript 是一门动态类型语言，与静态类型语言相比，在进行变量赋值时并不需要考虑它的类型。在动态类型语言的面向对象设计中， `鸭子类型` 的概念非常重要：\n\n> [鸭子类型 (duck typing)](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B) 的通俗说法是““当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”” 鸭子类型指导我们只关注对象的行为，而不专注对象本身，即关注 HAS-A,而不是IS-A。\n\n#### 多态\n多态的含义是“同一操作作用于不同对象上面，可以产生不同的解释和执行结果”，背后的思想是把“不变的事物”与“可能改变的事物”分离开来，把不变的部分隔离出来，把可变的部分封装起来，使得代码变得可扩展，修改代码也变得更加安全。 **不必再向对象询问“你是什么类型”再根据得到的答案调用对象的某个行为，直接调用就是了** 。JavaScript 的多态性与生俱来，它在编译时没有类型检查的过程。\n\n<!--more-->\n\n多态最根本的作用在于通过 **把过程化的条件分支语句转化为对象的多态性** 。将行为分布在各个对象中，由对象负责自己的行为，避免代码中充斥着错综复杂的if-else判断。\n\n一个实际开发中的例子，“引用了不同地图应用的API，使其在页面中渲染地图”\n\n```javascript\nvar googleMap = {\n  show: function () {\n    console.log('开始渲染google地图')\n  }\n}\n\nvar baiduMap = {\n  show: function () {\n    console.log('开始渲染baidu地图')\n  }\n}\n\n// 不具有多态性的代码\n\nvar renderMap = function (type) {\n  if (type === 'google') {\n    googleMap.show()\n  } else if (type === 'baidu') {\n    baiduMap.show()\n  }\n}\n\nrenderMap('google')\nrenderMap('baidu')\n\n// 具有多态性的代码\nvar renderMap = function (map) {\n  if (map.show instanceof Function) {\n    map.show()\n  }\n}\nrenderMap(googleMap)\nrenderMap(googleMap)\n```\n\n#### 封装\n\n封装为的是使信息隐藏，使得对象内部的变化对其它对象是不可见的。\n\n在 JavaScript 中依赖变量的作用域来实现封装特性 ，以及 ES6 提供的新的变量声明命令 `let` 和 新的数据类型 `Symbol`:\n\n```javascript\nvar myObject = (function (){\n  var _name = 'encapsulation'\n  return {\n    getName: function () {\n      return _name\n    }\n  }\n})()\n\nconsole.log(myObject._name) //undefined\nconsole.log(myObject.getName()) // encapsulation\n```\n\n从 [在 JavaScript 中依赖变量的作用域来实现封装特性](http://efe.baidu.com/blog/javascript-private-implement/) 可以发现， `Symbol + 类WeakMap 的整合方案` 是一个较好的实现方式。\n\n未完待续\n","source":"_posts/javascript-patterns.md","raw":"---\nlayout: post\ntitle:  \"Before learning the functional programming and design patterns\"\ndate:   2016-11-17 21:15\ncategories: front-end javascript\n---\n\n![cover](images/JavaScript-for-Kids.png)\n\n## 基础知识\n\n### OOP In JavaScript\n\n#### Duck Typing 鸭子类型\n\nJavaScript 是一门动态类型语言，与静态类型语言相比，在进行变量赋值时并不需要考虑它的类型。在动态类型语言的面向对象设计中， `鸭子类型` 的概念非常重要：\n\n> [鸭子类型 (duck typing)](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B) 的通俗说法是““当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”” 鸭子类型指导我们只关注对象的行为，而不专注对象本身，即关注 HAS-A,而不是IS-A。\n\n#### 多态\n多态的含义是“同一操作作用于不同对象上面，可以产生不同的解释和执行结果”，背后的思想是把“不变的事物”与“可能改变的事物”分离开来，把不变的部分隔离出来，把可变的部分封装起来，使得代码变得可扩展，修改代码也变得更加安全。 **不必再向对象询问“你是什么类型”再根据得到的答案调用对象的某个行为，直接调用就是了** 。JavaScript 的多态性与生俱来，它在编译时没有类型检查的过程。\n\n<!--more-->\n\n多态最根本的作用在于通过 **把过程化的条件分支语句转化为对象的多态性** 。将行为分布在各个对象中，由对象负责自己的行为，避免代码中充斥着错综复杂的if-else判断。\n\n一个实际开发中的例子，“引用了不同地图应用的API，使其在页面中渲染地图”\n\n```javascript\nvar googleMap = {\n  show: function () {\n    console.log('开始渲染google地图')\n  }\n}\n\nvar baiduMap = {\n  show: function () {\n    console.log('开始渲染baidu地图')\n  }\n}\n\n// 不具有多态性的代码\n\nvar renderMap = function (type) {\n  if (type === 'google') {\n    googleMap.show()\n  } else if (type === 'baidu') {\n    baiduMap.show()\n  }\n}\n\nrenderMap('google')\nrenderMap('baidu')\n\n// 具有多态性的代码\nvar renderMap = function (map) {\n  if (map.show instanceof Function) {\n    map.show()\n  }\n}\nrenderMap(googleMap)\nrenderMap(googleMap)\n```\n\n#### 封装\n\n封装为的是使信息隐藏，使得对象内部的变化对其它对象是不可见的。\n\n在 JavaScript 中依赖变量的作用域来实现封装特性 ，以及 ES6 提供的新的变量声明命令 `let` 和 新的数据类型 `Symbol`:\n\n```javascript\nvar myObject = (function (){\n  var _name = 'encapsulation'\n  return {\n    getName: function () {\n      return _name\n    }\n  }\n})()\n\nconsole.log(myObject._name) //undefined\nconsole.log(myObject.getName()) // encapsulation\n```\n\n从 [在 JavaScript 中依赖变量的作用域来实现封装特性](http://efe.baidu.com/blog/javascript-private-implement/) 可以发现， `Symbol + 类WeakMap 的整合方案` 是一个较好的实现方式。\n\n未完待续\n","slug":"javascript-patterns","published":1,"updated":"2017-11-19T06:51:11.000Z","_id":"cja54xyjf000qgbehtpo16xsj","comments":1,"photos":[],"link":"","content":"<p><img src=\"images/JavaScript-for-Kids.png\" alt=\"cover\"></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"OOP-In-JavaScript\"><a href=\"#OOP-In-JavaScript\" class=\"headerlink\" title=\"OOP In JavaScript\"></a>OOP In JavaScript</h3><h4 id=\"Duck-Typing-鸭子类型\"><a href=\"#Duck-Typing-鸭子类型\" class=\"headerlink\" title=\"Duck Typing 鸭子类型\"></a>Duck Typing 鸭子类型</h4><p>JavaScript 是一门动态类型语言，与静态类型语言相比，在进行变量赋值时并不需要考虑它的类型。在动态类型语言的面向对象设计中， <code>鸭子类型</code> 的概念非常重要：</p>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"external\">鸭子类型 (duck typing)</a> 的通俗说法是““当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”” 鸭子类型指导我们只关注对象的行为，而不专注对象本身，即关注 HAS-A,而不是IS-A。</p>\n</blockquote>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>多态的含义是“同一操作作用于不同对象上面，可以产生不同的解释和执行结果”，背后的思想是把“不变的事物”与“可能改变的事物”分离开来，把不变的部分隔离出来，把可变的部分封装起来，使得代码变得可扩展，修改代码也变得更加安全。 <strong>不必再向对象询问“你是什么类型”再根据得到的答案调用对象的某个行为，直接调用就是了</strong> 。JavaScript 的多态性与生俱来，它在编译时没有类型检查的过程。</p>\n<a id=\"more\"></a>\n<p>多态最根本的作用在于通过 <strong>把过程化的条件分支语句转化为对象的多态性</strong> 。将行为分布在各个对象中，由对象负责自己的行为，避免代码中充斥着错综复杂的if-else判断。</p>\n<p>一个实际开发中的例子，“引用了不同地图应用的API，使其在页面中渲染地图”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> googleMap = &#123;</div><div class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染google地图'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> baiduMap = &#123;</div><div class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染baidu地图'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不具有多态性的代码</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'google'</span>) &#123;</div><div class=\"line\">    googleMap.show()</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'baidu'</span>) &#123;</div><div class=\"line\">    baiduMap.show()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">renderMap(<span class=\"string\">'google'</span>)</div><div class=\"line\">renderMap(<span class=\"string\">'baidu'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 具有多态性的代码</span></div><div class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (map.show <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</div><div class=\"line\">    map.show()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">renderMap(googleMap)</div><div class=\"line\">renderMap(googleMap)</div></pre></td></tr></table></figure>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装为的是使信息隐藏，使得对象内部的变化对其它对象是不可见的。</p>\n<p>在 JavaScript 中依赖变量的作用域来实现封装特性 ，以及 ES6 提供的新的变量声明命令 <code>let</code> 和 新的数据类型 <code>Symbol</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myObject = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _name = <span class=\"string\">'encapsulation'</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> _name</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)()</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(myObject._name) <span class=\"comment\">//undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(myObject.getName()) <span class=\"comment\">// encapsulation</span></div></pre></td></tr></table></figure>\n<p>从 <a href=\"http://efe.baidu.com/blog/javascript-private-implement/\" target=\"_blank\" rel=\"external\">在 JavaScript 中依赖变量的作用域来实现封装特性</a> 可以发现， <code>Symbol + 类WeakMap 的整合方案</code> 是一个较好的实现方式。</p>\n<p>未完待续</p>\n","excerpt":"<p><img src=\"images/JavaScript-for-Kids.png\" alt=\"cover\"></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"OOP-In-JavaScript\"><a href=\"#OOP-In-JavaScript\" class=\"headerlink\" title=\"OOP In JavaScript\"></a>OOP In JavaScript</h3><h4 id=\"Duck-Typing-鸭子类型\"><a href=\"#Duck-Typing-鸭子类型\" class=\"headerlink\" title=\"Duck Typing 鸭子类型\"></a>Duck Typing 鸭子类型</h4><p>JavaScript 是一门动态类型语言，与静态类型语言相比，在进行变量赋值时并不需要考虑它的类型。在动态类型语言的面向对象设计中， <code>鸭子类型</code> 的概念非常重要：</p>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">鸭子类型 (duck typing)</a> 的通俗说法是““当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”” 鸭子类型指导我们只关注对象的行为，而不专注对象本身，即关注 HAS-A,而不是IS-A。</p>\n</blockquote>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>多态的含义是“同一操作作用于不同对象上面，可以产生不同的解释和执行结果”，背后的思想是把“不变的事物”与“可能改变的事物”分离开来，把不变的部分隔离出来，把可变的部分封装起来，使得代码变得可扩展，修改代码也变得更加安全。 <strong>不必再向对象询问“你是什么类型”再根据得到的答案调用对象的某个行为，直接调用就是了</strong> 。JavaScript 的多态性与生俱来，它在编译时没有类型检查的过程。</p>","more":"<p>多态最根本的作用在于通过 <strong>把过程化的条件分支语句转化为对象的多态性</strong> 。将行为分布在各个对象中，由对象负责自己的行为，避免代码中充斥着错综复杂的if-else判断。</p>\n<p>一个实际开发中的例子，“引用了不同地图应用的API，使其在页面中渲染地图”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> googleMap = &#123;</div><div class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染google地图'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> baiduMap = &#123;</div><div class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染baidu地图'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不具有多态性的代码</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'google'</span>) &#123;</div><div class=\"line\">    googleMap.show()</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'baidu'</span>) &#123;</div><div class=\"line\">    baiduMap.show()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">renderMap(<span class=\"string\">'google'</span>)</div><div class=\"line\">renderMap(<span class=\"string\">'baidu'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 具有多态性的代码</span></div><div class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (map.show <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</div><div class=\"line\">    map.show()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">renderMap(googleMap)</div><div class=\"line\">renderMap(googleMap)</div></pre></td></tr></table></figure>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装为的是使信息隐藏，使得对象内部的变化对其它对象是不可见的。</p>\n<p>在 JavaScript 中依赖变量的作用域来实现封装特性 ，以及 ES6 提供的新的变量声明命令 <code>let</code> 和 新的数据类型 <code>Symbol</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myObject = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _name = <span class=\"string\">'encapsulation'</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> _name</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)()</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(myObject._name) <span class=\"comment\">//undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(myObject.getName()) <span class=\"comment\">// encapsulation</span></div></pre></td></tr></table></figure>\n<p>从 <a href=\"http://efe.baidu.com/blog/javascript-private-implement/\">在 JavaScript 中依赖变量的作用域来实现封装特性</a> 可以发现， <code>Symbol + 类WeakMap 的整合方案</code> 是一个较好的实现方式。</p>\n<p>未完待续</p>"},{"layout":"post","title":"有关闭包，作用域，this对象","date":"2016-01-02T08:51:00.000Z","_content":"\n### 首先看一下维基百科中，闭包的概念：\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n\n#### 在创建函数和调用函数时，都发生了什么\n\n- 创建函数时\n 1. 创建了预先包含全局变量对象的作用域链\n 2. 该作用域链保存在内部[[scope]]属性中\n- 调用函数时\n 1. 创建执行环境\n 2. 复制函数[[scope]]属性中的对象构建作用域链\n 3. 用arguments与其它形参初始化函数的活动对象\n\n<!--more-->\n\n要理解这句话：**JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。**\n\n#### 再用计数器函数来看一个简单的闭包例子\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\ncounter2(); // Number of events: 1\ncounter1(); // Number of events: 3\n```\n\n这个函数实现了分别计数的功能。\n在createCounter()的最后一句：`return increment;`我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。\n因此，在使用`var counter1 = createCounter();`时，实际上，**我们生成了一个新的函数**。\n每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。\n**内部变量 counter 都是独立存在于每个作用域！**例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。\n\n#### 闭包的内存\n\n后台的每个执行环境都有一个表示变量的对象——变量对象。\n\n- 全局环境的变量对象始终存在\n- 像 createCounter()函数这样的局部变量，只在函数执行的过程中存在\n- 作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象\n- *一般来讲*当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。\n\n*但闭包的情况有所不同：*\n内部定义的函数会把外部函数的活动对象添加到它的作用域链中。\n当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为**匿名函数的作用域链仍然在引用这个活动对象**。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。\n一个简单的构造闭包以及释放内存的例子：\n\n```\nfunction outer () {\n\tvar name = 'foo';\n\treturn function () {\n\t\tconsole.log(name);\n\t}\n}\nvar inner = outer();\ninner();  // foo\ninner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存\n```\n\n并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。\n由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。\n\n#### 闭包的陷阱：循环闭包\n\n**请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。**\n因此，下面这个例子只会返回同一个值。\n\n```\nfunction foo(){\n  var result = new Array();\n  for(var i=0; i<10; i++){\n    result[i] = function(){\n      return i;\n    }\n  }\n  return result;\n}\n```\n\n表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.\n应改为：\n\n```\nfunction foo(){\n  var result = new Array();\n  for(var i=0; i<10; i++){\n    result[i] = function(num){\n      return function(){\n        return num\n      }\n    }(i);\n  }\n  return result;\n}\n```\n\n在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。\n匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。\n\n换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。\n代码简化如下：\n\n```\nvar arr = new Array();\nfor (var i = 0; i < 50; i++) {\n  (function () {\n    arr[i] = document.createElement('i');\n    arr[i].index = i;\n    arr[i].onclick = function () {\n        console.log(this.index);\n    };\n  })(i);\n};\n```\n\n`arr[i].index = i;`这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50\n\n#### 闭包中的this对象\n\n**匿名函数的执行环境具有全局性，因此其this对象通常指向window**\n```\nvar name = \"The Window\";\n　var object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　  return function(){\n　　　　 return this.name;\n　　　};\n　　}\n　};\nalert(object.getNameFunc()()); // “The Window”\n```\n内部函数在搜索`this`和`arguments`这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。\n\n### 关于this关键字\n\n在《JavaScripts语言精粹》中，把this的出现场景分为四种：\n\n> 有对象就指向调用对象\n\n> 没调用对象就指向全局对象\n\n> 用new构造就指向新对象\n\n> 通过 apply 或 call 或 bind 来改变 this 的所指。\n\n#### 1.全局的this===window\n\n#### 2.作为对象方法的函数的this指向这个上级对象\n\n```\nvar o ={\n  prop:37;\n  f:function(){return this.prop}\n}\nconsole.log(o.f()); //37\n```\n\n#### 3.构造函数调用，this指向其生成的新对象\n\n```\nwindow. x = 2;\nfunction test(m){\n　this.x = m;\n}\nvar o = new test(5);\nalert(x); //5\n```\n\n#### 4.apply 和 call 调用以及 bind 绑定\n\n全局函数apply和call可以用来改变函数中this的指向，如下：\n\n```\n// 定义一个全局函数\n   function foo() {\n       console.log(this.fruit);\n   }\n // 定义一个全局变量\n   var fruit = \"apple\";\n   // 自定义一个对象\n   var pack = {\n       fruit: \"orange\"\n   };\n    // 等价于window.foo();\n   foo.apply(window);  // \"apple\",此时this等于window\n   // 此时foo中的this === pack\n   foo.apply(pack);    // \"orange\"\n```\n","source":"_posts/learning-clouser-scope.md","raw":"---\nlayout: post\ntitle:  \"有关闭包，作用域，this对象\"\ndate:   2016-01-02 16:51\ncategories: front-end javascript\n---\n\n### 首先看一下维基百科中，闭包的概念：\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n\n#### 在创建函数和调用函数时，都发生了什么\n\n- 创建函数时\n 1. 创建了预先包含全局变量对象的作用域链\n 2. 该作用域链保存在内部[[scope]]属性中\n- 调用函数时\n 1. 创建执行环境\n 2. 复制函数[[scope]]属性中的对象构建作用域链\n 3. 用arguments与其它形参初始化函数的活动对象\n\n<!--more-->\n\n要理解这句话：**JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。**\n\n#### 再用计数器函数来看一个简单的闭包例子\n\n```\nfunction createCounter() {\n  var counter = 0;\n  function increment() {\n    counter = counter + 1;\n    console.log(\"Number of events: \" + counter);\n  }\n  return increment;\n}\nvar counter1 = createCounter();\nvar counter2 = createCounter();\n\ncounter1(); // Number of events: 1\ncounter1(); // Number of events: 2\ncounter2(); // Number of events: 1\ncounter1(); // Number of events: 3\n```\n\n这个函数实现了分别计数的功能。\n在createCounter()的最后一句：`return increment;`我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。\n因此，在使用`var counter1 = createCounter();`时，实际上，**我们生成了一个新的函数**。\n每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。\n**内部变量 counter 都是独立存在于每个作用域！**例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。\n\n#### 闭包的内存\n\n后台的每个执行环境都有一个表示变量的对象——变量对象。\n\n- 全局环境的变量对象始终存在\n- 像 createCounter()函数这样的局部变量，只在函数执行的过程中存在\n- 作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象\n- *一般来讲*当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。\n\n*但闭包的情况有所不同：*\n内部定义的函数会把外部函数的活动对象添加到它的作用域链中。\n当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为**匿名函数的作用域链仍然在引用这个活动对象**。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。\n一个简单的构造闭包以及释放内存的例子：\n\n```\nfunction outer () {\n\tvar name = 'foo';\n\treturn function () {\n\t\tconsole.log(name);\n\t}\n}\nvar inner = outer();\ninner();  // foo\ninner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存\n```\n\n并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。\n由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。\n\n#### 闭包的陷阱：循环闭包\n\n**请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。**\n因此，下面这个例子只会返回同一个值。\n\n```\nfunction foo(){\n  var result = new Array();\n  for(var i=0; i<10; i++){\n    result[i] = function(){\n      return i;\n    }\n  }\n  return result;\n}\n```\n\n表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.\n应改为：\n\n```\nfunction foo(){\n  var result = new Array();\n  for(var i=0; i<10; i++){\n    result[i] = function(num){\n      return function(){\n        return num\n      }\n    }(i);\n  }\n  return result;\n}\n```\n\n在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。\n匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。\n\n换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。\n代码简化如下：\n\n```\nvar arr = new Array();\nfor (var i = 0; i < 50; i++) {\n  (function () {\n    arr[i] = document.createElement('i');\n    arr[i].index = i;\n    arr[i].onclick = function () {\n        console.log(this.index);\n    };\n  })(i);\n};\n```\n\n`arr[i].index = i;`这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50\n\n#### 闭包中的this对象\n\n**匿名函数的执行环境具有全局性，因此其this对象通常指向window**\n```\nvar name = \"The Window\";\n　var object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　  return function(){\n　　　　 return this.name;\n　　　};\n　　}\n　};\nalert(object.getNameFunc()()); // “The Window”\n```\n内部函数在搜索`this`和`arguments`这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。\n\n### 关于this关键字\n\n在《JavaScripts语言精粹》中，把this的出现场景分为四种：\n\n> 有对象就指向调用对象\n\n> 没调用对象就指向全局对象\n\n> 用new构造就指向新对象\n\n> 通过 apply 或 call 或 bind 来改变 this 的所指。\n\n#### 1.全局的this===window\n\n#### 2.作为对象方法的函数的this指向这个上级对象\n\n```\nvar o ={\n  prop:37;\n  f:function(){return this.prop}\n}\nconsole.log(o.f()); //37\n```\n\n#### 3.构造函数调用，this指向其生成的新对象\n\n```\nwindow. x = 2;\nfunction test(m){\n　this.x = m;\n}\nvar o = new test(5);\nalert(x); //5\n```\n\n#### 4.apply 和 call 调用以及 bind 绑定\n\n全局函数apply和call可以用来改变函数中this的指向，如下：\n\n```\n// 定义一个全局函数\n   function foo() {\n       console.log(this.fruit);\n   }\n // 定义一个全局变量\n   var fruit = \"apple\";\n   // 自定义一个对象\n   var pack = {\n       fruit: \"orange\"\n   };\n    // 等价于window.foo();\n   foo.apply(window);  // \"apple\",此时this等于window\n   // 此时foo中的this === pack\n   foo.apply(pack);    // \"orange\"\n```\n","slug":"learning-clouser-scope","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyjk000tgbehdso4kdho","content":"<h3 id=\"首先看一下维基百科中，闭包的概念：\"><a href=\"#首先看一下维基百科中，闭包的概念：\" class=\"headerlink\" title=\"首先看一下维基百科中，闭包的概念：\"></a>首先看一下维基百科中，闭包的概念：</h3><blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。<br>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n</blockquote>\n<h4 id=\"在创建函数和调用函数时，都发生了什么\"><a href=\"#在创建函数和调用函数时，都发生了什么\" class=\"headerlink\" title=\"在创建函数和调用函数时，都发生了什么\"></a>在创建函数和调用函数时，都发生了什么</h4><ul>\n<li>创建函数时<ol>\n<li>创建了预先包含全局变量对象的作用域链</li>\n<li>该作用域链保存在内部[[scope]]属性中</li>\n</ol>\n</li>\n<li>调用函数时<ol>\n<li>创建执行环境</li>\n<li>复制函数[[scope]]属性中的对象构建作用域链</li>\n<li>用arguments与其它形参初始化函数的活动对象</li>\n</ol>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>要理解这句话：<strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong></p>\n<h4 id=\"再用计数器函数来看一个简单的闭包例子\"><a href=\"#再用计数器函数来看一个简单的闭包例子\" class=\"headerlink\" title=\"再用计数器函数来看一个简单的闭包例子\"></a>再用计数器函数来看一个简单的闭包例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createCounter() &#123;</div><div class=\"line\">  var counter = 0;</div><div class=\"line\">  function increment() &#123;</div><div class=\"line\">    counter = counter + 1;</div><div class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return increment;</div><div class=\"line\">&#125;</div><div class=\"line\">var counter1 = createCounter();</div><div class=\"line\">var counter2 = createCounter();</div><div class=\"line\"></div><div class=\"line\">counter1(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 2</div><div class=\"line\">counter2(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 3</div></pre></td></tr></table></figure>\n<p>这个函数实现了分别计数的功能。<br>在createCounter()的最后一句：<code>return increment;</code>我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。<br>因此，在使用<code>var counter1 = createCounter();</code>时，实际上，<strong>我们生成了一个新的函数</strong>。<br>每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。<br><strong>内部变量 counter 都是独立存在于每个作用域！</strong>例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。</p>\n<h4 id=\"闭包的内存\"><a href=\"#闭包的内存\" class=\"headerlink\" title=\"闭包的内存\"></a>闭包的内存</h4><p>后台的每个执行环境都有一个表示变量的对象——变量对象。</p>\n<ul>\n<li>全局环境的变量对象始终存在</li>\n<li>像 createCounter()函数这样的局部变量，只在函数执行的过程中存在</li>\n<li>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象</li>\n<li><em>一般来讲</em>当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。</li>\n</ul>\n<p><em>但闭包的情况有所不同：</em><br>内部定义的函数会把外部函数的活动对象添加到它的作用域链中。<br>当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为<strong>匿名函数的作用域链仍然在引用这个活动对象</strong>。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。<br>一个简单的构造闭包以及释放内存的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outer () &#123;</div><div class=\"line\">\tvar name = &apos;foo&apos;;</div><div class=\"line\">\treturn function () &#123;</div><div class=\"line\">\t\tconsole.log(name);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var inner = outer();</div><div class=\"line\">inner();  // foo</div><div class=\"line\">inner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存</div></pre></td></tr></table></figure>\n<p>并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。<br>由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。</p>\n<h4 id=\"闭包的陷阱：循环闭包\"><a href=\"#闭包的陷阱：循环闭包\" class=\"headerlink\" title=\"闭包的陷阱：循环闭包\"></a>闭包的陷阱：循环闭包</h4><p><strong>请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。</strong><br>因此，下面这个例子只会返回同一个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">  var result = new Array();</div><div class=\"line\">  for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function()&#123;</div><div class=\"line\">      return i;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.<br>应改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">  var result = new Array();</div><div class=\"line\">  for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function(num)&#123;</div><div class=\"line\">      return function()&#123;</div><div class=\"line\">        return num</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;(i);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。<br>匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。</p>\n<p>换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。<br>代码简化如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = new Array();</div><div class=\"line\">for (var i = 0; i &lt; 50; i++) &#123;</div><div class=\"line\">  (function () &#123;</div><div class=\"line\">    arr[i] = document.createElement(&apos;i&apos;);</div><div class=\"line\">    arr[i].index = i;</div><div class=\"line\">    arr[i].onclick = function () &#123;</div><div class=\"line\">        console.log(this.index);</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;)(i);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>arr[i].index = i;</code>这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50</p>\n<h4 id=\"闭包中的this对象\"><a href=\"#闭包中的this对象\" class=\"headerlink\" title=\"闭包中的this对象\"></a>闭包中的this对象</h4><p><strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\">　var object = &#123;</div><div class=\"line\">　　name : &quot;My Object&quot;,</div><div class=\"line\">　　getNameFunc : function()&#123;</div><div class=\"line\">　　  return function()&#123;</div><div class=\"line\">　　　　 return this.name;</div><div class=\"line\">　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">　&#125;;</div><div class=\"line\">alert(object.getNameFunc()()); // “The Window”</div></pre></td></tr></table></figure></p>\n<p>内部函数在搜索<code>this</code>和<code>arguments</code>这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。</p>\n<h3 id=\"关于this关键字\"><a href=\"#关于this关键字\" class=\"headerlink\" title=\"关于this关键字\"></a>关于this关键字</h3><p>在《JavaScripts语言精粹》中，把this的出现场景分为四种：</p>\n<blockquote>\n<p>有对象就指向调用对象</p>\n<p>没调用对象就指向全局对象</p>\n<p>用new构造就指向新对象</p>\n<p>通过 apply 或 call 或 bind 来改变 this 的所指。</p>\n</blockquote>\n<h4 id=\"1-全局的this-window\"><a href=\"#1-全局的this-window\" class=\"headerlink\" title=\"1.全局的this===window\"></a>1.全局的this===window</h4><h4 id=\"2-作为对象方法的函数的this指向这个上级对象\"><a href=\"#2-作为对象方法的函数的this指向这个上级对象\" class=\"headerlink\" title=\"2.作为对象方法的函数的this指向这个上级对象\"></a>2.作为对象方法的函数的this指向这个上级对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o =&#123;</div><div class=\"line\">  prop:37;</div><div class=\"line\">  f:function()&#123;return this.prop&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(o.f()); //37</div></pre></td></tr></table></figure>\n<h4 id=\"3-构造函数调用，this指向其生成的新对象\"><a href=\"#3-构造函数调用，this指向其生成的新对象\" class=\"headerlink\" title=\"3.构造函数调用，this指向其生成的新对象\"></a>3.构造函数调用，this指向其生成的新对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">window. x = 2;</div><div class=\"line\">function test(m)&#123;</div><div class=\"line\">　this.x = m;</div><div class=\"line\">&#125;</div><div class=\"line\">var o = new test(5);</div><div class=\"line\">alert(x); //5</div></pre></td></tr></table></figure>\n<h4 id=\"4-apply-和-call-调用以及-bind-绑定\"><a href=\"#4-apply-和-call-调用以及-bind-绑定\" class=\"headerlink\" title=\"4.apply 和 call 调用以及 bind 绑定\"></a>4.apply 和 call 调用以及 bind 绑定</h4><p>全局函数apply和call可以用来改变函数中this的指向，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 定义一个全局函数</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">       console.log(this.fruit);</div><div class=\"line\">   &#125;</div><div class=\"line\"> // 定义一个全局变量</div><div class=\"line\">   var fruit = &quot;apple&quot;;</div><div class=\"line\">   // 自定义一个对象</div><div class=\"line\">   var pack = &#123;</div><div class=\"line\">       fruit: &quot;orange&quot;</div><div class=\"line\">   &#125;;</div><div class=\"line\">    // 等价于window.foo();</div><div class=\"line\">   foo.apply(window);  // &quot;apple&quot;,此时this等于window</div><div class=\"line\">   // 此时foo中的this === pack</div><div class=\"line\">   foo.apply(pack);    // &quot;orange&quot;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"首先看一下维基百科中，闭包的概念：\"><a href=\"#首先看一下维基百科中，闭包的概念：\" class=\"headerlink\" title=\"首先看一下维基百科中，闭包的概念：\"></a>首先看一下维基百科中，闭包的概念：</h3><blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。<br>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n</blockquote>\n<h4 id=\"在创建函数和调用函数时，都发生了什么\"><a href=\"#在创建函数和调用函数时，都发生了什么\" class=\"headerlink\" title=\"在创建函数和调用函数时，都发生了什么\"></a>在创建函数和调用函数时，都发生了什么</h4><ul>\n<li>创建函数时<ol>\n<li>创建了预先包含全局变量对象的作用域链</li>\n<li>该作用域链保存在内部[[scope]]属性中</li>\n</ol>\n</li>\n<li>调用函数时<ol>\n<li>创建执行环境</li>\n<li>复制函数[[scope]]属性中的对象构建作用域链</li>\n<li>用arguments与其它形参初始化函数的活动对象</li>\n</ol>\n</li>\n</ul>","more":"<p>要理解这句话：<strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong></p>\n<h4 id=\"再用计数器函数来看一个简单的闭包例子\"><a href=\"#再用计数器函数来看一个简单的闭包例子\" class=\"headerlink\" title=\"再用计数器函数来看一个简单的闭包例子\"></a>再用计数器函数来看一个简单的闭包例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createCounter() &#123;</div><div class=\"line\">  var counter = 0;</div><div class=\"line\">  function increment() &#123;</div><div class=\"line\">    counter = counter + 1;</div><div class=\"line\">    console.log(&quot;Number of events: &quot; + counter);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return increment;</div><div class=\"line\">&#125;</div><div class=\"line\">var counter1 = createCounter();</div><div class=\"line\">var counter2 = createCounter();</div><div class=\"line\"></div><div class=\"line\">counter1(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 2</div><div class=\"line\">counter2(); // Number of events: 1</div><div class=\"line\">counter1(); // Number of events: 3</div></pre></td></tr></table></figure>\n<p>这个函数实现了分别计数的功能。<br>在createCounter()的最后一句：<code>return increment;</code>我们返回了该局部函数。在这里并不是返回了increment()函数的调用结果，而是返回了该结果本身。<br>因此，在使用<code>var counter1 = createCounter();</code>时，实际上，<strong>我们生成了一个新的函数</strong>。<br>每个生成的函数，都会保持在 createCounter() 所创建的 counter 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。<br><strong>内部变量 counter 都是独立存在于每个作用域！</strong>例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 counter 变量。</p>\n<h4 id=\"闭包的内存\"><a href=\"#闭包的内存\" class=\"headerlink\" title=\"闭包的内存\"></a>闭包的内存</h4><p>后台的每个执行环境都有一个表示变量的对象——变量对象。</p>\n<ul>\n<li>全局环境的变量对象始终存在</li>\n<li>像 createCounter()函数这样的局部变量，只在函数执行的过程中存在</li>\n<li>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含变量对象</li>\n<li><em>一般来讲</em>当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。</li>\n</ul>\n<p><em>但闭包的情况有所不同：</em><br>内部定义的函数会把外部函数的活动对象添加到它的作用域链中。<br>当上述例子中createCounter()执行完毕后，它的活动对象也不会销毁，因为<strong>匿名函数的作用域链仍然在引用这个活动对象</strong>。也就是说这个函数执行完毕后，虽然其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中。只有当匿名函数被销毁后，createCounter()的活动对象才会被销毁。<br>一个简单的构造闭包以及释放内存的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outer () &#123;</div><div class=\"line\">\tvar name = &apos;foo&apos;;</div><div class=\"line\">\treturn function () &#123;</div><div class=\"line\">\t\tconsole.log(name);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var inner = outer();</div><div class=\"line\">inner();  // foo</div><div class=\"line\">inner = null;  // 解除对 outer 内部的匿名函数的引用，以便释放内存</div></pre></td></tr></table></figure>\n<p>并且，闭包在IE低版本中会导致特殊的问题。如果闭包作用域链中保存着一个HTML元素，那么该元素将无法销毁。<br>由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包。</p>\n<h4 id=\"闭包的陷阱：循环闭包\"><a href=\"#闭包的陷阱：循环闭包\" class=\"headerlink\" title=\"闭包的陷阱：循环闭包\"></a>闭包的陷阱：循环闭包</h4><p><strong>请牢记一点：闭包只能取得包含函数中任何变量的最后一个值。</strong><br>因此，下面这个例子只会返回同一个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">  var result = new Array();</div><div class=\"line\">  for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function()&#123;</div><div class=\"line\">      return i;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>表面上看，每个函数都会返回自己的索引值，但实际上，每个函数都会返回10.因为事件处理器函数绑定了变量i本身，foo()执行完毕后，每个函数内的i的值都是10.<br>应改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo()&#123;</div><div class=\"line\">  var result = new Array();</div><div class=\"line\">  for(var i=0; i&lt;10; i++)&#123;</div><div class=\"line\">    result[i] = function(num)&#123;</div><div class=\"line\">      return function()&#123;</div><div class=\"line\">        return num</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;(i);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，我们定义了一个匿名函数，把匿名函数的结果赋值给数组。<br>匿名函数的参数num就是最终函数要返回的值，在调用每个匿名函数时，我们都把当前i的值赋给了num，匿名函数内部的闭包又可以访问到num，因此result数组里的每个函数都有自己的num变量的副本，就可以返回不同的值了。</p>\n<p>换个应用场景，如果想循环若干个节点，在这个for循环里绑定onclick，使每个节点被点击时都会打印其对应的索引值。<br>代码简化如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = new Array();</div><div class=\"line\">for (var i = 0; i &lt; 50; i++) &#123;</div><div class=\"line\">  (function () &#123;</div><div class=\"line\">    arr[i] = document.createElement(&apos;i&apos;);</div><div class=\"line\">    arr[i].index = i;</div><div class=\"line\">    arr[i].onclick = function () &#123;</div><div class=\"line\">        console.log(this.index);</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;)(i);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>arr[i].index = i;</code>这一句很关键，如果省略的话，onclick函数执行时作用域里没有i这个变量，只能一直向上查找，最后打印出50</p>\n<h4 id=\"闭包中的this对象\"><a href=\"#闭包中的this对象\" class=\"headerlink\" title=\"闭包中的this对象\"></a>闭包中的this对象</h4><p><strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\">　var object = &#123;</div><div class=\"line\">　　name : &quot;My Object&quot;,</div><div class=\"line\">　　getNameFunc : function()&#123;</div><div class=\"line\">　　  return function()&#123;</div><div class=\"line\">　　　　 return this.name;</div><div class=\"line\">　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">　&#125;;</div><div class=\"line\">alert(object.getNameFunc()()); // “The Window”</div></pre></td></tr></table></figure></p>\n<p>内部函数在搜索<code>this</code>和<code>arguments</code>这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。</p>\n<h3 id=\"关于this关键字\"><a href=\"#关于this关键字\" class=\"headerlink\" title=\"关于this关键字\"></a>关于this关键字</h3><p>在《JavaScripts语言精粹》中，把this的出现场景分为四种：</p>\n<blockquote>\n<p>有对象就指向调用对象</p>\n<p>没调用对象就指向全局对象</p>\n<p>用new构造就指向新对象</p>\n<p>通过 apply 或 call 或 bind 来改变 this 的所指。</p>\n</blockquote>\n<h4 id=\"1-全局的this-window\"><a href=\"#1-全局的this-window\" class=\"headerlink\" title=\"1.全局的this===window\"></a>1.全局的this===window</h4><h4 id=\"2-作为对象方法的函数的this指向这个上级对象\"><a href=\"#2-作为对象方法的函数的this指向这个上级对象\" class=\"headerlink\" title=\"2.作为对象方法的函数的this指向这个上级对象\"></a>2.作为对象方法的函数的this指向这个上级对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o =&#123;</div><div class=\"line\">  prop:37;</div><div class=\"line\">  f:function()&#123;return this.prop&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(o.f()); //37</div></pre></td></tr></table></figure>\n<h4 id=\"3-构造函数调用，this指向其生成的新对象\"><a href=\"#3-构造函数调用，this指向其生成的新对象\" class=\"headerlink\" title=\"3.构造函数调用，this指向其生成的新对象\"></a>3.构造函数调用，this指向其生成的新对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">window. x = 2;</div><div class=\"line\">function test(m)&#123;</div><div class=\"line\">　this.x = m;</div><div class=\"line\">&#125;</div><div class=\"line\">var o = new test(5);</div><div class=\"line\">alert(x); //5</div></pre></td></tr></table></figure>\n<h4 id=\"4-apply-和-call-调用以及-bind-绑定\"><a href=\"#4-apply-和-call-调用以及-bind-绑定\" class=\"headerlink\" title=\"4.apply 和 call 调用以及 bind 绑定\"></a>4.apply 和 call 调用以及 bind 绑定</h4><p>全局函数apply和call可以用来改变函数中this的指向，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 定义一个全局函数</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">       console.log(this.fruit);</div><div class=\"line\">   &#125;</div><div class=\"line\"> // 定义一个全局变量</div><div class=\"line\">   var fruit = &quot;apple&quot;;</div><div class=\"line\">   // 自定义一个对象</div><div class=\"line\">   var pack = &#123;</div><div class=\"line\">       fruit: &quot;orange&quot;</div><div class=\"line\">   &#125;;</div><div class=\"line\">    // 等价于window.foo();</div><div class=\"line\">   foo.apply(window);  // &quot;apple&quot;,此时this等于window</div><div class=\"line\">   // 此时foo中的this === pack</div><div class=\"line\">   foo.apply(pack);    // &quot;orange&quot;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"BFC学习笔记","date":"2015-08-20T02:54:24.000Z","_content":"### 一.概念\n\n在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。\n\n### 二.产生BFC条件：\n\n当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：\n\n*   float的值不为none。\n*   overflow的值不为visible。\n*   display的值为table-cell, table-caption, inline-block中的任何一个。\n*   position的值不为relative和static。\n\n<!--more-->\n\n### 三.应用\n\n1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。\n\n2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖\n\n3）解决上下相邻两个元素重叠\n> 外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。\n\n4）清除元素内部浮动\n\n只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。","source":"_posts/learning-note-bfc.md","raw":"---\nlayout: post\ntitle:  \"BFC学习笔记\"\ndate:   2015-08-20 10:54:24\ncategories: css\n---\n### 一.概念\n\n在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。\n\n### 二.产生BFC条件：\n\n当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：\n\n*   float的值不为none。\n*   overflow的值不为visible。\n*   display的值为table-cell, table-caption, inline-block中的任何一个。\n*   position的值不为relative和static。\n\n<!--more-->\n\n### 三.应用\n\n1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。\n\n2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖\n\n3）解决上下相邻两个元素重叠\n> 外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。\n\n4）清除元素内部浮动\n\n只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。","slug":"learning-note-bfc","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyjo000vgbehn18cbf9c","content":"<h3 id=\"一-概念\"><a href=\"#一-概念\" class=\"headerlink\" title=\"一.概念\"></a>一.概念</h3><p>在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。</p>\n<h3 id=\"二-产生BFC条件：\"><a href=\"#二-产生BFC条件：\" class=\"headerlink\" title=\"二.产生BFC条件：\"></a>二.产生BFC条件：</h3><p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：</p>\n<ul>\n<li>float的值不为none。</li>\n<li>overflow的值不为visible。</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个。</li>\n<li>position的值不为relative和static。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"三-应用\"><a href=\"#三-应用\" class=\"headerlink\" title=\"三.应用\"></a>三.应用</h3><p>1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。</p>\n<p>2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖</p>\n<p>3）解决上下相邻两个元素重叠</p>\n<blockquote>\n<p>外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。</p>\n</blockquote>\n<p>4）清除元素内部浮动</p>\n<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。</p>\n","excerpt":"<h3 id=\"一-概念\"><a href=\"#一-概念\" class=\"headerlink\" title=\"一.概念\"></a>一.概念</h3><p>在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。</p>\n<h3 id=\"二-产生BFC条件：\"><a href=\"#二-产生BFC条件：\" class=\"headerlink\" title=\"二.产生BFC条件：\"></a>二.产生BFC条件：</h3><p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：</p>\n<ul>\n<li>float的值不为none。</li>\n<li>overflow的值不为visible。</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个。</li>\n<li>position的值不为relative和static。</li>\n</ul>","more":"<h3 id=\"三-应用\"><a href=\"#三-应用\" class=\"headerlink\" title=\"三.应用\"></a>三.应用</h3><p>1)包含浮动元素BFC会根据子元素的情况自适应高度，这个特性是对父元素使overflow:hidden/auto/scroll、float:left/right样式可以闭合浮动的原理。</p>\n<p>2)不被浮动元素覆盖浮动元素：为元素创建BFC后可避免其被浮动的兄弟元素覆盖</p>\n<p>3）解决上下相邻两个元素重叠</p>\n<blockquote>\n<p>外边距折叠的规则：仅当两个块级元素毗邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。</p>\n</blockquote>\n<p>4）清除元素内部浮动</p>\n<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。</p>"},{"layout":"post","title":"解决中文拼音输入法在input监听的问题","date":"2017-08-22T12:16:00.000Z","_content":"\n### 一、问题\n![cover](/images/chinese-pinyin.gif)\n\n在通过监听用户输入，将输入作为 Keyword 进行查询时（做了防抖）发现有如图问题，使用中文拼音输入法时，未选中所要的字词前，会自动将输入法分词过的拼音作为文本，由于实时监听输入，就存在将 ce'shi 作为 keyword 查询的问题了。\n在这里，前端需要对拼音输入法的这种情况进行处理。\n<!--more-->\n\n### 二、TL;DR 解决方法\n\n可以借鉴 `Vue.js` 的处理方法，引入 `compositionstart` 和 `compositionend` 事件来捕获 `IME(input method editor)` 的启动和关闭。\n这两个事件，目前是IE9+支持，移动端 Safari < 10.2 & UIWebView 暂时无法触发，因此可以作为 PC 端产品的靠谱方案。\n实现：\n\n```javascript\nvar node = document.querySelector('._orgtree');\nif (node) {\n  var fireLock = false;\n  node.addEventListener('compositionstart', function () {\n      fireLock = true;\n  })\n  node.addEventListener('compositionend', function () {\n      fireLock = false;\n  })\n  node.addEventListener('input', function () {\n      if (!fireLock) {\n          searchOrgTree();\n      }\n  });\n}\n```\n\n### 三、怎么更放心地用\n\n这里还是看看 Vue.js 的代码：[src/platforms/web/runtime/directives/model.js](https://github.com/vuejs/vue/blob/c90b140e80f1bd5d01c733a5bd9fa6e9cb3c2b4d/src/platforms/web/runtime/directives/model.js)\n\n```javascript\n// 只贴我们用到的\nexport default {\n  inserted (el, binding, vnode) {\n    if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd)\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart)\n          el.addEventListener('compositionend', onCompositionEnd)\n        }\n      }\n    }\n  }\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) return\n  e.target.composing = false\n  trigger(e.target, 'input')\n}\n\nfunction trigger (el, type) {\n  const e = document.createEvent('HTMLEvents')\n  e.initEvent(type, true, true)\n  el.dispatchEvent(e)\n}\n```\n\n\n> For languages that require an IME (Chinese, Japanese, Korean etc.), you’ll notice that v-model doesn’t get updated during IME composition. If you want to cater for these updates as well, use input event instead.\n\nVue.js 在编写 `v-model` 这一核心指令时用到了 `compositionstart` 和 `compositionend`  这两个事件，保证在输入框交互过程中的文本并不会触发 `v-model` 更新，在源码中也是针对 Safari 做了兼容处理。\n\n","source":"_posts/fix-chinese-input-listener.md","raw":"---\nlayout: post\ntitle:  \"解决中文拼音输入法在input监听的问题\"\ndate:   2017-08-22 20:16\ncategories: front-end javascript\n---\n\n### 一、问题\n![cover](/images/chinese-pinyin.gif)\n\n在通过监听用户输入，将输入作为 Keyword 进行查询时（做了防抖）发现有如图问题，使用中文拼音输入法时，未选中所要的字词前，会自动将输入法分词过的拼音作为文本，由于实时监听输入，就存在将 ce'shi 作为 keyword 查询的问题了。\n在这里，前端需要对拼音输入法的这种情况进行处理。\n<!--more-->\n\n### 二、TL;DR 解决方法\n\n可以借鉴 `Vue.js` 的处理方法，引入 `compositionstart` 和 `compositionend` 事件来捕获 `IME(input method editor)` 的启动和关闭。\n这两个事件，目前是IE9+支持，移动端 Safari < 10.2 & UIWebView 暂时无法触发，因此可以作为 PC 端产品的靠谱方案。\n实现：\n\n```javascript\nvar node = document.querySelector('._orgtree');\nif (node) {\n  var fireLock = false;\n  node.addEventListener('compositionstart', function () {\n      fireLock = true;\n  })\n  node.addEventListener('compositionend', function () {\n      fireLock = false;\n  })\n  node.addEventListener('input', function () {\n      if (!fireLock) {\n          searchOrgTree();\n      }\n  });\n}\n```\n\n### 三、怎么更放心地用\n\n这里还是看看 Vue.js 的代码：[src/platforms/web/runtime/directives/model.js](https://github.com/vuejs/vue/blob/c90b140e80f1bd5d01c733a5bd9fa6e9cb3c2b4d/src/platforms/web/runtime/directives/model.js)\n\n```javascript\n// 只贴我们用到的\nexport default {\n  inserted (el, binding, vnode) {\n    if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd)\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart)\n          el.addEventListener('compositionend', onCompositionEnd)\n        }\n      }\n    }\n  }\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) return\n  e.target.composing = false\n  trigger(e.target, 'input')\n}\n\nfunction trigger (el, type) {\n  const e = document.createEvent('HTMLEvents')\n  e.initEvent(type, true, true)\n  el.dispatchEvent(e)\n}\n```\n\n\n> For languages that require an IME (Chinese, Japanese, Korean etc.), you’ll notice that v-model doesn’t get updated during IME composition. If you want to cater for these updates as well, use input event instead.\n\nVue.js 在编写 `v-model` 这一核心指令时用到了 `compositionstart` 和 `compositionend`  这两个事件，保证在输入框交互过程中的文本并不会触发 `v-model` 更新，在源码中也是针对 Safari 做了兼容处理。\n\n","slug":"fix-chinese-input-listener","published":1,"updated":"2017-11-19T06:48:27.000Z","_id":"cja54xyjp000xgbehn223xoyn","comments":1,"photos":[],"link":"","content":"<h3 id=\"一、问题\"><a href=\"#一、问题\" class=\"headerlink\" title=\"一、问题\"></a>一、问题</h3><p><img src=\"/images/chinese-pinyin.gif\" alt=\"cover\"></p>\n<p>在通过监听用户输入，将输入作为 Keyword 进行查询时（做了防抖）发现有如图问题，使用中文拼音输入法时，未选中所要的字词前，会自动将输入法分词过的拼音作为文本，由于实时监听输入，就存在将 ce’shi 作为 keyword 查询的问题了。<br>在这里，前端需要对拼音输入法的这种情况进行处理。<br><a id=\"more\"></a></p>\n<h3 id=\"二、TL-DR-解决方法\"><a href=\"#二、TL-DR-解决方法\" class=\"headerlink\" title=\"二、TL;DR 解决方法\"></a>二、TL;DR 解决方法</h3><p>可以借鉴 <code>Vue.js</code> 的处理方法，引入 <code>compositionstart</code> 和 <code>compositionend</code> 事件来捕获 <code>IME(input method editor)</code> 的启动和关闭。<br>这两个事件，目前是IE9+支持，移动端 Safari &lt; 10.2 &amp; UIWebView 暂时无法触发，因此可以作为 PC 端产品的靠谱方案。<br>实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'._orgtree'</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (node) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fireLock = <span class=\"literal\">false</span>;</div><div class=\"line\">  node.addEventListener(<span class=\"string\">'compositionstart'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      fireLock = <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  node.addEventListener(<span class=\"string\">'compositionend'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      fireLock = <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  node.addEventListener(<span class=\"string\">'input'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!fireLock) &#123;</div><div class=\"line\">          searchOrgTree();</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三、怎么更放心地用\"><a href=\"#三、怎么更放心地用\" class=\"headerlink\" title=\"三、怎么更放心地用\"></a>三、怎么更放心地用</h3><p>这里还是看看 Vue.js 的代码：<a href=\"https://github.com/vuejs/vue/blob/c90b140e80f1bd5d01c733a5bd9fa6e9cb3c2b4d/src/platforms/web/runtime/directives/model.js\" target=\"_blank\" rel=\"external\">src/platforms/web/runtime/directives/model.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只贴我们用到的</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  inserted (el, binding, vnode) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (vnode.tag === <span class=\"string\">'textarea'</span> || isTextInputType(el.type)) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!binding.modifiers.lazy) &#123;</div><div class=\"line\">        <span class=\"comment\">// Safari &lt; 10.2 &amp; UIWebView doesn't fire compositionend when</span></div><div class=\"line\">        <span class=\"comment\">// switching focus before confirming composition choice</span></div><div class=\"line\">        <span class=\"comment\">// this also fixes the issue where some browsers e.g. iOS Chrome</span></div><div class=\"line\">        <span class=\"comment\">// fires \"change\" instead of \"input\" on autocomplete.</span></div><div class=\"line\">        el.addEventListener(<span class=\"string\">'change'</span>, onCompositionEnd)</div><div class=\"line\">        <span class=\"keyword\">if</span> (!isAndroid) &#123;</div><div class=\"line\">          el.addEventListener(<span class=\"string\">'compositionstart'</span>, onCompositionStart)</div><div class=\"line\">          el.addEventListener(<span class=\"string\">'compositionend'</span>, onCompositionEnd)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onCompositionStart</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.target.composing = <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onCompositionEnd</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// prevent triggering an input event for no reason</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!e.target.composing) <span class=\"keyword\">return</span></div><div class=\"line\">  e.target.composing = <span class=\"literal\">false</span></div><div class=\"line\">  trigger(e.target, <span class=\"string\">'input'</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trigger</span> (<span class=\"params\">el, type</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> e = <span class=\"built_in\">document</span>.createEvent(<span class=\"string\">'HTMLEvents'</span>)</div><div class=\"line\">  e.initEvent(type, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>)</div><div class=\"line\">  el.dispatchEvent(e)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>For languages that require an IME (Chinese, Japanese, Korean etc.), you’ll notice that v-model doesn’t get updated during IME composition. If you want to cater for these updates as well, use input event instead.</p>\n</blockquote>\n<p>Vue.js 在编写 <code>v-model</code> 这一核心指令时用到了 <code>compositionstart</code> 和 <code>compositionend</code>  这两个事件，保证在输入框交互过程中的文本并不会触发 <code>v-model</code> 更新，在源码中也是针对 Safari 做了兼容处理。</p>\n","excerpt":"<h3 id=\"一、问题\"><a href=\"#一、问题\" class=\"headerlink\" title=\"一、问题\"></a>一、问题</h3><p><img src=\"/images/chinese-pinyin.gif\" alt=\"cover\"></p>\n<p>在通过监听用户输入，将输入作为 Keyword 进行查询时（做了防抖）发现有如图问题，使用中文拼音输入法时，未选中所要的字词前，会自动将输入法分词过的拼音作为文本，由于实时监听输入，就存在将 ce’shi 作为 keyword 查询的问题了。<br>在这里，前端需要对拼音输入法的这种情况进行处理。<br>","more":"</p>\n<h3 id=\"二、TL-DR-解决方法\"><a href=\"#二、TL-DR-解决方法\" class=\"headerlink\" title=\"二、TL;DR 解决方法\"></a>二、TL;DR 解决方法</h3><p>可以借鉴 <code>Vue.js</code> 的处理方法，引入 <code>compositionstart</code> 和 <code>compositionend</code> 事件来捕获 <code>IME(input method editor)</code> 的启动和关闭。<br>这两个事件，目前是IE9+支持，移动端 Safari &lt; 10.2 &amp; UIWebView 暂时无法触发，因此可以作为 PC 端产品的靠谱方案。<br>实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'._orgtree'</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (node) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fireLock = <span class=\"literal\">false</span>;</div><div class=\"line\">  node.addEventListener(<span class=\"string\">'compositionstart'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      fireLock = <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  node.addEventListener(<span class=\"string\">'compositionend'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      fireLock = <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  node.addEventListener(<span class=\"string\">'input'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!fireLock) &#123;</div><div class=\"line\">          searchOrgTree();</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三、怎么更放心地用\"><a href=\"#三、怎么更放心地用\" class=\"headerlink\" title=\"三、怎么更放心地用\"></a>三、怎么更放心地用</h3><p>这里还是看看 Vue.js 的代码：<a href=\"https://github.com/vuejs/vue/blob/c90b140e80f1bd5d01c733a5bd9fa6e9cb3c2b4d/src/platforms/web/runtime/directives/model.js\">src/platforms/web/runtime/directives/model.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只贴我们用到的</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  inserted (el, binding, vnode) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (vnode.tag === <span class=\"string\">'textarea'</span> || isTextInputType(el.type)) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!binding.modifiers.lazy) &#123;</div><div class=\"line\">        <span class=\"comment\">// Safari &lt; 10.2 &amp; UIWebView doesn't fire compositionend when</span></div><div class=\"line\">        <span class=\"comment\">// switching focus before confirming composition choice</span></div><div class=\"line\">        <span class=\"comment\">// this also fixes the issue where some browsers e.g. iOS Chrome</span></div><div class=\"line\">        <span class=\"comment\">// fires \"change\" instead of \"input\" on autocomplete.</span></div><div class=\"line\">        el.addEventListener(<span class=\"string\">'change'</span>, onCompositionEnd)</div><div class=\"line\">        <span class=\"keyword\">if</span> (!isAndroid) &#123;</div><div class=\"line\">          el.addEventListener(<span class=\"string\">'compositionstart'</span>, onCompositionStart)</div><div class=\"line\">          el.addEventListener(<span class=\"string\">'compositionend'</span>, onCompositionEnd)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onCompositionStart</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.target.composing = <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onCompositionEnd</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// prevent triggering an input event for no reason</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!e.target.composing) <span class=\"keyword\">return</span></div><div class=\"line\">  e.target.composing = <span class=\"literal\">false</span></div><div class=\"line\">  trigger(e.target, <span class=\"string\">'input'</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trigger</span> (<span class=\"params\">el, type</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> e = <span class=\"built_in\">document</span>.createEvent(<span class=\"string\">'HTMLEvents'</span>)</div><div class=\"line\">  e.initEvent(type, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>)</div><div class=\"line\">  el.dispatchEvent(e)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>For languages that require an IME (Chinese, Japanese, Korean etc.), you’ll notice that v-model doesn’t get updated during IME composition. If you want to cater for these updates as well, use input event instead.</p>\n</blockquote>\n<p>Vue.js 在编写 <code>v-model</code> 这一核心指令时用到了 <code>compositionstart</code> 和 <code>compositionend</code>  这两个事件，保证在输入框交互过程中的文本并不会触发 <code>v-model</code> 更新，在源码中也是针对 Safari 做了兼容处理。</p>"},{"layout":"post","title":"Viewport-Percentage (or Viewport-Relative) Lengths","date":"2016-03-17T11:16:00.000Z","_content":"\n### 什么是视区百分比长度（viewport-percentage lengths）？\n\n先看一下W3C给出的定义：\n\n >The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.\n\n意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。`initial containing block`意为浏览器内部的可视区域，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n\n<!--more-->\n\n视区单位有`vh` (相对于视区高度), `vw`(相对于视区宽度), `vmin` (相对于视区高度或宽度，取决于哪个更小) and `vmax` (类似于vw但取决于哪个更大)。\n\n### 它是如何分配浏览器高度的？\n\n我们可以假借`vh`: `1vh`相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。\n\n### 浏览器兼容性？\n\n![caniuse](http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png)\n\n在css属性可用性查询网站[caniuse](http://caniuse.com/#search=viewport%20units)中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，**Chrome 20+, IE9+ ,FireFox19+以及Safari6** 都是支持的。\n\n### 100vh与100%的区别？\n\n我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于`window.innerWidth/window.innerHeight`的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）\n就像这个例子：\n\n```\n<body style=\"height:100%\">\n    <div style=\"height:200px\">\n        <p style=\"height:100%; display:block;\">Hello, world!</p>\n    </div>\n</body>\n```\n\n虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px\n\n### 如何用百分比实现同vh一样的效果？\n\n某些情况下，`vw`, `vh`所产生的效果与百分比`%单位`无异，尤其对于`absolute/fixed`定位属性的元素。比如：\n```\n{\n    position: fixed;\n    top: 100%;\n    top: 100vh;\n    left: 5%;\n    left: 5vw;\n    right: 5%;\n    right: 5vw;\n}\n```\n支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。\n\n### 参考内容\n\n* [James Donnelly__stackoverflow](http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window):视区单位布道\n* [视区相关单位_张鑫旭博客](http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/):更多相关与视区单位应用场景的尝试\n* [JS,Jquery获取各种屏幕的宽度和高度](http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html):复习一下有关屏幕高度的知识","source":"_posts/vieport-percentage.md","raw":"---\nlayout: post\ntitle:  \"Viewport-Percentage (or Viewport-Relative) Lengths\"\ndate:   2016-03-17 19:16\ncategories: front-end css\n---\n\n### 什么是视区百分比长度（viewport-percentage lengths）？\n\n先看一下W3C给出的定义：\n\n >The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.\n\n意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。`initial containing block`意为浏览器内部的可视区域，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n\n<!--more-->\n\n视区单位有`vh` (相对于视区高度), `vw`(相对于视区宽度), `vmin` (相对于视区高度或宽度，取决于哪个更小) and `vmax` (类似于vw但取决于哪个更大)。\n\n### 它是如何分配浏览器高度的？\n\n我们可以假借`vh`: `1vh`相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。\n\n### 浏览器兼容性？\n\n![caniuse](http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png)\n\n在css属性可用性查询网站[caniuse](http://caniuse.com/#search=viewport%20units)中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，**Chrome 20+, IE9+ ,FireFox19+以及Safari6** 都是支持的。\n\n### 100vh与100%的区别？\n\n我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于`window.innerWidth/window.innerHeight`的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）\n就像这个例子：\n\n```\n<body style=\"height:100%\">\n    <div style=\"height:200px\">\n        <p style=\"height:100%; display:block;\">Hello, world!</p>\n    </div>\n</body>\n```\n\n虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px\n\n### 如何用百分比实现同vh一样的效果？\n\n某些情况下，`vw`, `vh`所产生的效果与百分比`%单位`无异，尤其对于`absolute/fixed`定位属性的元素。比如：\n```\n{\n    position: fixed;\n    top: 100%;\n    top: 100vh;\n    left: 5%;\n    left: 5vw;\n    right: 5%;\n    right: 5vw;\n}\n```\n支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。\n\n### 参考内容\n\n* [James Donnelly__stackoverflow](http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window):视区单位布道\n* [视区相关单位_张鑫旭博客](http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/):更多相关与视区单位应用场景的尝试\n* [JS,Jquery获取各种屏幕的宽度和高度](http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html):复习一下有关屏幕高度的知识","slug":"vieport-percentage","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyjs0010gbehn2f6ug9b","content":"<h3 id=\"什么是视区百分比长度（viewport-percentage-lengths）？\"><a href=\"#什么是视区百分比长度（viewport-percentage-lengths）？\" class=\"headerlink\" title=\"什么是视区百分比长度（viewport-percentage lengths）？\"></a>什么是视区百分比长度（viewport-percentage lengths）？</h3><p>先看一下W3C给出的定义：</p>\n<blockquote>\n<p>The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>\n</blockquote>\n<p>意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。<code>initial containing block</code>意为浏览器内部的可视区域，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>\n<a id=\"more\"></a>\n<p>视区单位有<code>vh</code> (相对于视区高度), <code>vw</code>(相对于视区宽度), <code>vmin</code> (相对于视区高度或宽度，取决于哪个更小) and <code>vmax</code> (类似于vw但取决于哪个更大)。</p>\n<h3 id=\"它是如何分配浏览器高度的？\"><a href=\"#它是如何分配浏览器高度的？\" class=\"headerlink\" title=\"它是如何分配浏览器高度的？\"></a>它是如何分配浏览器高度的？</h3><p>我们可以假借<code>vh</code>: <code>1vh</code>相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。</p>\n<h3 id=\"浏览器兼容性？\"><a href=\"#浏览器兼容性？\" class=\"headerlink\" title=\"浏览器兼容性？\"></a>浏览器兼容性？</h3><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png\" alt=\"caniuse\"></p>\n<p>在css属性可用性查询网站<a href=\"http://caniuse.com/#search=viewport%20units\" target=\"_blank\" rel=\"external\">caniuse</a>中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，<strong>Chrome 20+, IE9+ ,FireFox19+以及Safari6</strong> 都是支持的。</p>\n<h3 id=\"100vh与100-的区别？\"><a href=\"#100vh与100-的区别？\" class=\"headerlink\" title=\"100vh与100%的区别？\"></a>100vh与100%的区别？</h3><p>我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于<code>window.innerWidth/window.innerHeight</code>的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）<br>就像这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body style=&quot;height:100%&quot;&gt;</div><div class=\"line\">    &lt;div style=&quot;height:200px&quot;&gt;</div><div class=\"line\">        &lt;p style=&quot;height:100%; display:block;&quot;&gt;Hello, world!&lt;/p&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px</p>\n<h3 id=\"如何用百分比实现同vh一样的效果？\"><a href=\"#如何用百分比实现同vh一样的效果？\" class=\"headerlink\" title=\"如何用百分比实现同vh一样的效果？\"></a>如何用百分比实现同vh一样的效果？</h3><p>某些情况下，<code>vw</code>, <code>vh</code>所产生的效果与百分比<code>%单位</code>无异，尤其对于<code>absolute/fixed</code>定位属性的元素。比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    position: fixed;</div><div class=\"line\">    top: 100%;</div><div class=\"line\">    top: 100vh;</div><div class=\"line\">    left: 5%;</div><div class=\"line\">    left: 5vw;</div><div class=\"line\">    right: 5%;</div><div class=\"line\">    right: 5vw;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window\" target=\"_blank\" rel=\"external\">James Donnelly__stackoverflow</a>:视区单位布道</li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/\" target=\"_blank\" rel=\"external\">视区相关单位_张鑫旭博客</a>:更多相关与视区单位应用场景的尝试</li>\n<li><a href=\"http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html\" target=\"_blank\" rel=\"external\">JS,Jquery获取各种屏幕的宽度和高度</a>:复习一下有关屏幕高度的知识</li>\n</ul>\n","excerpt":"<h3 id=\"什么是视区百分比长度（viewport-percentage-lengths）？\"><a href=\"#什么是视区百分比长度（viewport-percentage-lengths）？\" class=\"headerlink\" title=\"什么是视区百分比长度（viewport-percentage lengths）？\"></a>什么是视区百分比长度（viewport-percentage lengths）？</h3><p>先看一下W3C给出的定义：</p>\n<blockquote>\n<p>The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>\n</blockquote>\n<p>意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。<code>initial containing block</code>意为浏览器内部的可视区域，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>","more":"<p>视区单位有<code>vh</code> (相对于视区高度), <code>vw</code>(相对于视区宽度), <code>vmin</code> (相对于视区高度或宽度，取决于哪个更小) and <code>vmax</code> (类似于vw但取决于哪个更大)。</p>\n<h3 id=\"它是如何分配浏览器高度的？\"><a href=\"#它是如何分配浏览器高度的？\" class=\"headerlink\" title=\"它是如何分配浏览器高度的？\"></a>它是如何分配浏览器高度的？</h3><p>我们可以假借<code>vh</code>: <code>1vh</code>相当于1%的视区高度，忽略元素在DOM树中的位置，100vh相当于浏览器内部可视区域的高度。</p>\n<h3 id=\"浏览器兼容性？\"><a href=\"#浏览器兼容性？\" class=\"headerlink\" title=\"浏览器兼容性？\"></a>浏览器兼容性？</h3><p><img src=\"http://o7ts2uaks.bkt.clouddn.com/98A8FA40-23DE-4D3B-AE9B-A434F44A5AA0.png\" alt=\"caniuse\"></p>\n<p>在css属性可用性查询网站<a href=\"http://caniuse.com/#search=viewport%20units\">caniuse</a>中我们查到了，目前主流浏览器对于视区单位的支持性，从中我们可以看出，<strong>Chrome 20+, IE9+ ,FireFox19+以及Safari6</strong> 都是支持的。</p>\n<h3 id=\"100vh与100-的区别？\"><a href=\"#100vh与100-的区别？\" class=\"headerlink\" title=\"100vh与100%的区别？\"></a>100vh与100%的区别？</h3><p>我们知道，vh是相对于视区高度的单位，所以100vh被设置的高度永远是相对于<code>window.innerWidth/window.innerHeight</code>的。而被设置成百分比高度的标签，它的实际高度要取决于其父标签（块级）<br>就像这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body style=&quot;height:100%&quot;&gt;</div><div class=\"line\">    &lt;div style=&quot;height:200px&quot;&gt;</div><div class=\"line\">        &lt;p style=&quot;height:100%; display:block;&quot;&gt;Hello, world!&lt;/p&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>虽然p标签设置了高度为100％，但是其外部div的高度为200px，因此这个p标签的实际高度只是200px</p>\n<h3 id=\"如何用百分比实现同vh一样的效果？\"><a href=\"#如何用百分比实现同vh一样的效果？\" class=\"headerlink\" title=\"如何用百分比实现同vh一样的效果？\"></a>如何用百分比实现同vh一样的效果？</h3><p>某些情况下，<code>vw</code>, <code>vh</code>所产生的效果与百分比<code>%单位</code>无异，尤其对于<code>absolute/fixed</code>定位属性的元素。比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    position: fixed;</div><div class=\"line\">    top: 100%;</div><div class=\"line\">    top: 100vh;</div><div class=\"line\">    left: 5%;</div><div class=\"line\">    left: 5vw;</div><div class=\"line\">    right: 5%;</div><div class=\"line\">    right: 5vw;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>支持vh, vw单位的浏览器就会使用视区单位（因为在后面声明）；不支持的就是要百分比%单位。</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"http://stackoverflow.com/questions/1575141/make-div-100-height-of-browser-window\">James Donnelly__stackoverflow</a>:视区单位布道</li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/\">视区相关单位_张鑫旭博客</a>:更多相关与视区单位应用场景的尝试</li>\n<li><a href=\"http://www.cnblogs.com/xiaopin/archive/2012/03/26/2418152.html\">JS,Jquery获取各种屏幕的宽度和高度</a>:复习一下有关屏幕高度的知识</li>\n</ul>"},{"layout":"post","title":"javascript面向对象的程序设计","date":"2015-08-19T23:43:50.000Z","_content":"参考《JavaScript高级程序设计》第三版\n\n阮一峰[Javascript 面向对象编程](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)\n\n## 一.创建对象\n\n#### 1.字面量\n\n```\nvar cat1 = {\n\ncat1.name = \"kitty\";\n\ncat1.color = \"white\";\n\n};\n\nvar cat2 = {\n\ncat2.name = \"greg\";\n\ncat2.color = \"black\";\n\n};\n```\n\n有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。\n\n<!--more-->\n\n#### 2.工厂模式\n\n```\nfunction creatCat(name,color){\n\nvar o = new Object();\n\n0.name = name;\n\n0.color = color;\n\nreturn 0 ;\n\n}\n\nvar cat1 = createCat(\"kitty\",white);\n\nvar cat2 = createCat(\"greg\",black);\n```\n\n\n解决了多个相似对象的问题，但没有解决对象类型识别的问题。\n\n#### 3.构造函数模式\n\n```\nfunction Cat(name,color){\n\nthis.name=name;\n\nthis.color=color;\n\n}\n\nvar cat1 = new  Cat(\"kitty\",\"white\");\n\nvar cat2 = new  Cat(\"greg\",\"black\");\n\nalert(cat1.name); // kitty\n\nalert(cat1.color); // white\n```\n\n即没有return调用，将属性，方法赋给了_this_对象，函数名始终以大写字母开头\n\n任何函数只要通过new调用，就可以作为构造函数\n\n这时cat1和cat2会自动含有一个_constructor_属性，指向它们的构造函数。\n\n```\nalert(cat1.constructor == Cat); //true\nalert(cat2.constructor == Cat); //true\n```\n\nJavascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。\n\n```\nalert(cat1 instanceof Cat); //true\nalert(cat2 instanceof Cat); //true\n```\n\n**构造函数模式的问题：**\n\n构造函数方法很好用，但是存在一个浪费内存的问题。\n\n请看，我们现在为Cat对象添加一个不变的属性\"type\"（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：\n\n```\n function Cat(name,color){\n   this.name = name;\n   this.color = color;\n   this.type = \"猫科动物\";\n   this.eat = function(){alert(\"吃老鼠\");};\n }\n ```\n\n还是采用同样的方法，生成实例：\n\n```\n var cat1 = new Cat(\"kitty\",\"white\");\n var cat2 = new Cat (\"greg\",\"black\");\n alert(cat1.type); // 猫科动物\n cat1.eat(); // 吃老鼠\n```\n\n表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。\n `alert(cat1.eat == cat2.eat); //false`\n能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。\n\n#### 3.原型模式（Prototype模式）\n\n每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。\n\n原型对象可以让所有对象实例共享它所包含的属性和方法。\n\n我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n\n```\nfunction Cat(name,color){\n\nthis.name = name;\n\nthis.color = color;\n\n}\n\nCat.prototype.type = \"猫科动物\";\n\nCat.prototype.eat = function(){alert(\"吃老鼠\")};\n```\n\n然后，生成实例。\n\n```\nvar cat1 = new Cat(\"kitty\",\"white\");\nvar cat2 = new Cat(\"greg\",\"black\");\nalert(cat1.type); // 猫科动物\ncat1.eat(); // 吃老鼠\n```\n\n这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\n`alert(cat1.eat == cat2.eat); //true`\n\n**二、 Prototype模式的验证方法**\n\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n\n**1 isPrototypeOf()**\n\n这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n\n```\nalert(Cat.prototype.isPrototypeOf(cat1)); //true\nalert(Cat.prototype.isPrototypeOf(cat2)); //true\n```\n\n**2 hasOwnProperty()**\n\n每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false\n\n```\nalert(cat1.hasOwnProperty(\"name\")); // true\nalert(cat1.hasOwnProperty(\"type\")); // false\n```\n\n**3 in运算符**\n\nin运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。\n\n```\nalert(\"name\" in cat1); // true\nalert(\"type\" in cat1); // true\n```\n\nin运算符还可以用来遍历某个对象的所有属性。\n`for(var prop in cat1) { alert(\"cat1[\"+prop+\"]=\"+cat1[prop]); }`","source":"_posts/note-learning-javascript-oop.md","raw":"---\nlayout: post\ntitle:  \"javascript面向对象的程序设计\"\ndate:   2015-08-20 7:43:50\ncategories: javascript\n---\n参考《JavaScript高级程序设计》第三版\n\n阮一峰[Javascript 面向对象编程](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)\n\n## 一.创建对象\n\n#### 1.字面量\n\n```\nvar cat1 = {\n\ncat1.name = \"kitty\";\n\ncat1.color = \"white\";\n\n};\n\nvar cat2 = {\n\ncat2.name = \"greg\";\n\ncat2.color = \"black\";\n\n};\n```\n\n有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。\n\n<!--more-->\n\n#### 2.工厂模式\n\n```\nfunction creatCat(name,color){\n\nvar o = new Object();\n\n0.name = name;\n\n0.color = color;\n\nreturn 0 ;\n\n}\n\nvar cat1 = createCat(\"kitty\",white);\n\nvar cat2 = createCat(\"greg\",black);\n```\n\n\n解决了多个相似对象的问题，但没有解决对象类型识别的问题。\n\n#### 3.构造函数模式\n\n```\nfunction Cat(name,color){\n\nthis.name=name;\n\nthis.color=color;\n\n}\n\nvar cat1 = new  Cat(\"kitty\",\"white\");\n\nvar cat2 = new  Cat(\"greg\",\"black\");\n\nalert(cat1.name); // kitty\n\nalert(cat1.color); // white\n```\n\n即没有return调用，将属性，方法赋给了_this_对象，函数名始终以大写字母开头\n\n任何函数只要通过new调用，就可以作为构造函数\n\n这时cat1和cat2会自动含有一个_constructor_属性，指向它们的构造函数。\n\n```\nalert(cat1.constructor == Cat); //true\nalert(cat2.constructor == Cat); //true\n```\n\nJavascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。\n\n```\nalert(cat1 instanceof Cat); //true\nalert(cat2 instanceof Cat); //true\n```\n\n**构造函数模式的问题：**\n\n构造函数方法很好用，但是存在一个浪费内存的问题。\n\n请看，我们现在为Cat对象添加一个不变的属性\"type\"（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：\n\n```\n function Cat(name,color){\n   this.name = name;\n   this.color = color;\n   this.type = \"猫科动物\";\n   this.eat = function(){alert(\"吃老鼠\");};\n }\n ```\n\n还是采用同样的方法，生成实例：\n\n```\n var cat1 = new Cat(\"kitty\",\"white\");\n var cat2 = new Cat (\"greg\",\"black\");\n alert(cat1.type); // 猫科动物\n cat1.eat(); // 吃老鼠\n```\n\n表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。\n `alert(cat1.eat == cat2.eat); //false`\n能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。\n\n#### 3.原型模式（Prototype模式）\n\n每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。\n\n原型对象可以让所有对象实例共享它所包含的属性和方法。\n\n我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n\n```\nfunction Cat(name,color){\n\nthis.name = name;\n\nthis.color = color;\n\n}\n\nCat.prototype.type = \"猫科动物\";\n\nCat.prototype.eat = function(){alert(\"吃老鼠\")};\n```\n\n然后，生成实例。\n\n```\nvar cat1 = new Cat(\"kitty\",\"white\");\nvar cat2 = new Cat(\"greg\",\"black\");\nalert(cat1.type); // 猫科动物\ncat1.eat(); // 吃老鼠\n```\n\n这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\n`alert(cat1.eat == cat2.eat); //true`\n\n**二、 Prototype模式的验证方法**\n\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n\n**1 isPrototypeOf()**\n\n这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n\n```\nalert(Cat.prototype.isPrototypeOf(cat1)); //true\nalert(Cat.prototype.isPrototypeOf(cat2)); //true\n```\n\n**2 hasOwnProperty()**\n\n每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false\n\n```\nalert(cat1.hasOwnProperty(\"name\")); // true\nalert(cat1.hasOwnProperty(\"type\")); // false\n```\n\n**3 in运算符**\n\nin运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。\n\n```\nalert(\"name\" in cat1); // true\nalert(\"type\" in cat1); // true\n```\n\nin运算符还可以用来遍历某个对象的所有属性。\n`for(var prop in cat1) { alert(\"cat1[\"+prop+\"]=\"+cat1[prop]); }`","slug":"note-learning-javascript-oop","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyju0012gbehkpixmrsq","content":"<p>参考《JavaScript高级程序设计》第三版</p>\n<p>阮一峰<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\" target=\"_blank\" rel=\"external\">Javascript 面向对象编程</a></p>\n<h2 id=\"一-创建对象\"><a href=\"#一-创建对象\" class=\"headerlink\" title=\"一.创建对象\"></a>一.创建对象</h2><h4 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1.字面量\"></a>1.字面量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat1.name = &quot;kitty&quot;;</div><div class=\"line\"></div><div class=\"line\">cat1.color = &quot;white&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var cat2 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat2.name = &quot;greg&quot;;</div><div class=\"line\"></div><div class=\"line\">cat2.color = &quot;black&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>\n<a id=\"more\"></a>\n<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2.工厂模式\"></a>2.工厂模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function creatCat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">var o = new Object();</div><div class=\"line\"></div><div class=\"line\">0.name = name;</div><div class=\"line\"></div><div class=\"line\">0.color = color;</div><div class=\"line\"></div><div class=\"line\">return 0 ;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = createCat(&quot;kitty&quot;,white);</div><div class=\"line\"></div><div class=\"line\">var cat2 = createCat(&quot;greg&quot;,black);</div></pre></td></tr></table></figure>\n<p>解决了多个相似对象的问题，但没有解决对象类型识别的问题。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3.构造函数模式\"></a>3.构造函数模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name=name;</div><div class=\"line\"></div><div class=\"line\">this.color=color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = new  Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\"></div><div class=\"line\">var cat2 = new  Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\"></div><div class=\"line\">alert(cat1.name); // kitty</div><div class=\"line\"></div><div class=\"line\">alert(cat1.color); // white</div></pre></td></tr></table></figure>\n<p>即没有return调用，将属性，方法赋给了<em>this</em>对象，函数名始终以大写字母开头</p>\n<p>任何函数只要通过new调用，就可以作为构造函数</p>\n<p>这时cat1和cat2会自动含有一个<em>constructor</em>属性，指向它们的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.constructor == Cat); //true</div><div class=\"line\">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure>\n<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1 instanceof Cat); //true</div><div class=\"line\">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure>\n<p><strong>构造函数模式的问题：</strong></p>\n<p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>\n<p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.color = color;</div><div class=\"line\">  this.type = &quot;猫科动物&quot;;</div><div class=\"line\">  this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是采用同样的方法，生成实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat (&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。<br> <code>alert(cat1.eat == cat2.eat); //false</code><br>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>\n<h4 id=\"3-原型模式（Prototype模式）\"><a href=\"#3-原型模式（Prototype模式）\" class=\"headerlink\" title=\"3.原型模式（Prototype模式）\"></a>3.原型模式（Prototype模式）</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>\n<p>原型对象可以让所有对象实例共享它所包含的属性和方法。</p>\n<p>我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name = name;</div><div class=\"line\"></div><div class=\"line\">this.color = color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.type = &quot;猫科动物&quot;;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure>\n<p>然后，生成实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。<br><code>alert(cat1.eat == cat2.eat); //true</code></p>\n<p><strong>二、 Prototype模式的验证方法</strong></p>\n<p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>\n<p><strong>1 isPrototypeOf()</strong></p>\n<p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure>\n<p><strong>2 hasOwnProperty()</strong></p>\n<p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class=\"line\">alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</div></pre></td></tr></table></figure>\n<p><strong>3 in运算符</strong></p>\n<p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(&quot;name&quot; in cat1); // true</div><div class=\"line\">alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure>\n<p>in运算符还可以用来遍历某个对象的所有属性。<br><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }</code></p>\n","excerpt":"<p>参考《JavaScript高级程序设计》第三版</p>\n<p>阮一峰<a href=\"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html\">Javascript 面向对象编程</a></p>\n<h2 id=\"一-创建对象\"><a href=\"#一-创建对象\" class=\"headerlink\" title=\"一.创建对象\"></a>一.创建对象</h2><h4 id=\"1-字面量\"><a href=\"#1-字面量\" class=\"headerlink\" title=\"1.字面量\"></a>1.字面量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat1.name = &quot;kitty&quot;;</div><div class=\"line\"></div><div class=\"line\">cat1.color = &quot;white&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var cat2 = &#123;</div><div class=\"line\"></div><div class=\"line\">cat2.name = &quot;greg&quot;;</div><div class=\"line\"></div><div class=\"line\">cat2.color = &quot;black&quot;;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>","more":"<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2.工厂模式\"></a>2.工厂模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function creatCat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">var o = new Object();</div><div class=\"line\"></div><div class=\"line\">0.name = name;</div><div class=\"line\"></div><div class=\"line\">0.color = color;</div><div class=\"line\"></div><div class=\"line\">return 0 ;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = createCat(&quot;kitty&quot;,white);</div><div class=\"line\"></div><div class=\"line\">var cat2 = createCat(&quot;greg&quot;,black);</div></pre></td></tr></table></figure>\n<p>解决了多个相似对象的问题，但没有解决对象类型识别的问题。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3.构造函数模式\"></a>3.构造函数模式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name=name;</div><div class=\"line\"></div><div class=\"line\">this.color=color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var cat1 = new  Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\"></div><div class=\"line\">var cat2 = new  Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\"></div><div class=\"line\">alert(cat1.name); // kitty</div><div class=\"line\"></div><div class=\"line\">alert(cat1.color); // white</div></pre></td></tr></table></figure>\n<p>即没有return调用，将属性，方法赋给了<em>this</em>对象，函数名始终以大写字母开头</p>\n<p>任何函数只要通过new调用，就可以作为构造函数</p>\n<p>这时cat1和cat2会自动含有一个<em>constructor</em>属性，指向它们的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.constructor == Cat); //true</div><div class=\"line\">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure>\n<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1 instanceof Cat); //true</div><div class=\"line\">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure>\n<p><strong>构造函数模式的问题：</strong></p>\n<p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>\n<p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.color = color;</div><div class=\"line\">  this.type = &quot;猫科动物&quot;;</div><div class=\"line\">  this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是采用同样的方法，生成实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat (&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。<br> <code>alert(cat1.eat == cat2.eat); //false</code><br>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>\n<h4 id=\"3-原型模式（Prototype模式）\"><a href=\"#3-原型模式（Prototype模式）\" class=\"headerlink\" title=\"3.原型模式（Prototype模式）\"></a>3.原型模式（Prototype模式）</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>\n<p>原型对象可以让所有对象实例共享它所包含的属性和方法。</p>\n<p>我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Cat(name,color)&#123;</div><div class=\"line\"></div><div class=\"line\">this.name = name;</div><div class=\"line\"></div><div class=\"line\">this.color = color;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.type = &quot;猫科动物&quot;;</div><div class=\"line\"></div><div class=\"line\">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure>\n<p>然后，生成实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1 = new Cat(&quot;kitty&quot;,&quot;white&quot;);</div><div class=\"line\">var cat2 = new Cat(&quot;greg&quot;,&quot;black&quot;);</div><div class=\"line\">alert(cat1.type); // 猫科动物</div><div class=\"line\">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>\n<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。<br><code>alert(cat1.eat == cat2.eat); //true</code></p>\n<p><strong>二、 Prototype模式的验证方法</strong></p>\n<p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>\n<p><strong>1 isPrototypeOf()</strong></p>\n<p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class=\"line\">alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure>\n<p><strong>2 hasOwnProperty()</strong></p>\n<p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。本地属性为true，由prototype对象继承为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class=\"line\">alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</div></pre></td></tr></table></figure>\n<p><strong>3 in运算符</strong></p>\n<p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(&quot;name&quot; in cat1); // true</div><div class=\"line\">alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure>\n<p>in运算符还可以用来遍历某个对象的所有属性。<br><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }</code></p>"},{"layout":"post","title":"[译]JavaScript最佳实践：提高代码质量的技巧和建议","date":"2016-03-13T08:24:00.000Z","_content":"\n原文地址：https://www.codementor.io/javascript/tutorial/javascript-best-practices\n\n![image](https://www.filepicker.io/api/file/e4jxgEgHRzS1zQU6aJLR)\n每天学习新知识可以让我们变成一个更优秀更理性的人。作为一名开发者，持续学习也是我们工作的一部分，无论如何，这些新知识的学习过程都是积极有益的经验积累。\n\n在这篇教程中，我会提出一些JavaScript的最佳实践，你就不会觉得学习起来很困难了。准备好了就来一起升级你的代码吧！\n\n### 1.避免污染全局作用域\n\n声明变量的过程中有很多有趣的地方。有的时候，你可能在不知情的情况下却声明了一个`全局变量`。在现代浏览器中，全局变量会被储存在`window`对象中，因此会有很多内容运行在其中，你不知情声明的全局变量可能会覆盖掉一些默认值。\n\n<!--more-->\n\n我们假设你有一个包含`<script>`标签的HTML文件（或者是其中引入了JavaScript文件）：\n```\nvar foo = 42;\nconsole.log(foo);\n```\n很明显，控制台会打印出`42`，但是如果这段代码不是执行在函数中的话，这一段执行上下文就会变成全局的。因此，这个变量`foo`也会被绑定在`window`对象上，意味着`window.foo`也是`42`。这样是很危险的，你可能覆盖掉了已经存在的全局变量。\n```\nfunction print () {\n   // do something\n}\nprint();\n```\n当执行`windos.print`（或者`print`）时，由于我们已经覆盖了原生的print函数，浏览器就不会弹出打印窗口了。\n\n解决方法很简单；我们需要一个叫做`立即执行函数`的包装函数，如下：\n```\n// Declare an anonymous function\n(function () {\n   var foo = 42;\n   console.log(window.foo);\n   // → undefined\n   console.log(foo);\n   // → 42\n})();\n//^ and call it immediately\n```\n除了这种解决方法，你也可以选择把`window`和其它全局对象（如`document`）作为参数传递给函数（这样可能会提升性能）：\n```\n(function (global, doc) {\n  global.setTimeout(function () {\n     doc.body.innerHTML = \"Hello!\";\n  }, 1000);\n})(window, document);\n```\n因此，你要用包裹函数避免创建全局变量。注意一点，我不会在代码段中使用包裹函数，因为我们是要专注于代码本身。\n\nTip: [模块打包工具browserify](http://browserify.org/)是避免创建全局变量的又一种方法。它以与Node.js同样的方式使用`require`函数。\n\n多说一点，Node.js通过函数来自动包裹你的文件。它们看起来就像这样：\n```\n(function (exports, require, module, __filename, __dirname) {\n// ...\n```\n可能你觉得`require`函数也是全局的，然而它并不是。它只不过是一个函数参数。\n\n#### Did you know?\n\n尽管`window`对象其中包含着全局变量，它本身也是个全局变量，`window`内部指向的是它本身：\n\n```\nwindow.window.window\n// => Window{...}\n```\n这是因为`window`是一个循环对象。想要创建一个循环对象的话可以参考：\n```\n// 创建一个对象\nvar foo = {};\n\n//给对象本身赋值一个属性\nfoo.bar = foo;\n\n// foo就变成了一个循环对象\nfoo.bar.bar.bar.bar\n// → foo\n```\n所以你可以这样表白你对JavaScripte无限的爱了：\n![circle](https://www.filepicker.io/api/file/ZMNjGIiQ52IKsseTjqno)\n你就可以像这样无限扩展这个Object（直到浏览器崩溃）\n\n### 2.使用'use strict'的好处\n\n严格使用`use strict`！没有什么方法比把这行代码添在JavaScript里可以让你的代码更magic了。\n\n举个例子：\n```\n//  糟糕的写法，会让你在不知情的情况下创建了全局变量\n(function () {\n   a = 42;\n   console.log(a);\n   // → 42\n})();\nconsole.log(a);\n// → 42\n```\n\n设置严格模式，你就会得到报错信息：\n```\n(function () {\n   \"use strict\";\n   a = 42;\n   // Error: Uncaught ReferenceError: a is not defined\n})();\n```\n你可能想知道为什么你不能把`\"use strict\"`写在包裹函数外面。事实上，可以写在外面，严格模式就会在全局应用。这么什么不好的，但是要注意如果代码引入了第三方库，或是要打包到一个文件的时候，全局应用可能会造成影响。\n\n### 3.严格等于 ===\n\n如果你想用`==`来比较a和b的话，在JavaScript中你可能会发现它的结果有点奇怪：如果你比较的是字符串和数字，它们也会是相等的（`==`）：\n```\n\"42\" == 42\n// true\n```\n显然，用严格等于（`===`）更好\n```\n\"42\" === 42\n// false\n```\n\n### 4.用`&&`和`||`魔法\n\n在日常工作中，你可以发现用逻辑操作符缩短你的代码\n\n默认\n```\n\"\" || \"foo\"   // → \"foo\"\n\nundefined || 42   // → 42\n\n//注意一下，如果你想通过这种方式来处理0的话，你要检查它是0还是未赋值\nvar a = 0;\na || 42\n// → 42\n\n// 三元表达式看起来就像是一行结构的if-else语句\nvar b = typeof a === \"number\" ? a : 42;\n// → 0\n```\n不需要用if表达式来判断布尔值，你可以简单地这样处理：\n```\nexpr && doSomething();\n\n// Instead of:\nif (expr) {\n   doSomething();\n}\n```\n在上例中如果我们需要`doSomething()`来返回结果的话，使用逻辑操作符会看起来更带感：\n```\nfunction doSomething () {\n   return { foo: \"bar\" };\n}\nvar expr = true;\nvar res = expr && doSomething();\nres && console.log(res);\n// → { foo: \"bar\" }\n```\n在这个问题上你可能会有异议，但使用逻辑操作符确实是更理想的方式。可能你认为用这种方法是“丑化”代码，但那些代码压缩器却真的在这样做。\n\n尽管代码变短了，它的可读性却依然很好。\n\n### 5.改变变量类型\n\n取决于实际场景，有很多改变变量类型的方法，如下是最常用的方法：\n```\n// anything =》 number\n\nvar foo = \"42\";\nvar myNumber = +foo; // shortcut for Number(foo)\n// → 42\n\n// Tip: 可以直接把它变成负数\nvar negativeFoo = -foo; // or -Number(foo)\n// → -42\n\n// object => array\n// Tip: `arguments` 是一个对象但通常被用作为数组\nvar args = { 0: \"foo\", 1: \"bar\", length: 2 };\nArray.prototype.slice.call(args)\n// → [ 'foo', 'bar' ]\n\n// Anything =》 boolean\n// 两次取非可以使它变成布尔值\nvar t = 1;\nvar f = 0;\n!!t\n// → true\n!!f\n// → false\n\n// 一次取非\n!t\n// → false\n!f\n// → true\n\n// Anything =》 string\nvar foo = 42;\n\"\" + foo // 转变为字符串的简短方法\n// → \"42\"\n\nfoo = { hello: \"world\" };\nJSON.stringify(foo);\n// → '{ \"hello\":\"world\" }'\n\nJSON.stringify(foo, null, 4); // 美化代码\n// →\n// '{\n//    \"hello\": \"world\"\n// }'\n\n// 注意一点，不可以 JSON.stringify 环形结构的对象\nJSON.stringify(window);\n// ⚠ TypeError: JSON.stringify cannot serialize cyclic structures.\n```\n\n### 6.代码风格指南\n\n新项目中在不同文件里应该遵循同样的代码风格，对于老项目，就沿用旧的代码风格，除非你下定决心去整体改掉陈旧代码的风格（要和同事讨论之后再决定）。只要你确定了代码风格，就要一直遵循它。\n\n这是一些可参考的代码风格\n\n* [Google JavaScript Style Guide](https://google.github.io/styleguide/javascriptguide.xml)\n* [aribnb/javascript](https://github.com/airbnb/javascript)\n* [my code-style](https://github.com/IonicaBizau/code-style)\n\n### 额外提示\n\n在其它一些JavaScript最佳实践中可以发现有一些有助于编码的工具：\n\n- [js-beautify](https://github.com/beautify-web/js-beautify):美化代码\n- [UglifyJS(2)](https://github.com/mishoo/UglifyJS2):压缩代码\n- [jshint](https://github.com/jshint/jshint):检测代码中的错误\n- [jscs](http://jscs.info/):可扩展的风格检测\n\n最后一件事，好好[debug](https://www.codementor.io/learn-programming/what-to-do-when-your-website-is-broken),而不是用`console.log`\n\n祝编码愉快！\n\n### 参考内容\n* [初学者指南：学习JavaScript的最佳方法](https://www.codementor.io/javascript/tutorial/how-to-learn-javascript-properly)\n* [关于JavaScript初学者必知的十件事](https://www.codementor.io/javascript/tutorial/top-ten-things-beginners-must-know-javascript)\n* [在2016年JavaScript开发者需要学习的技巧](https://www.codementor.io/learn-programming/javascript-trends-skills-developers-should-learn)\n* [4种开始使用ES2015的方法](https://www.codementor.io/javascript/tutorial/4-easy-ways-to-start-using-es2015)\n* [最重要的21道面试题](https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers)\n","source":"_posts/trans-javascript-code-tips.md","raw":"---\nlayout: post\ntitle:  \"[译]JavaScript最佳实践：提高代码质量的技巧和建议\"\ndate:   2016-03-13 16:24\ncategories: javascript\n---\n\n原文地址：https://www.codementor.io/javascript/tutorial/javascript-best-practices\n\n![image](https://www.filepicker.io/api/file/e4jxgEgHRzS1zQU6aJLR)\n每天学习新知识可以让我们变成一个更优秀更理性的人。作为一名开发者，持续学习也是我们工作的一部分，无论如何，这些新知识的学习过程都是积极有益的经验积累。\n\n在这篇教程中，我会提出一些JavaScript的最佳实践，你就不会觉得学习起来很困难了。准备好了就来一起升级你的代码吧！\n\n### 1.避免污染全局作用域\n\n声明变量的过程中有很多有趣的地方。有的时候，你可能在不知情的情况下却声明了一个`全局变量`。在现代浏览器中，全局变量会被储存在`window`对象中，因此会有很多内容运行在其中，你不知情声明的全局变量可能会覆盖掉一些默认值。\n\n<!--more-->\n\n我们假设你有一个包含`<script>`标签的HTML文件（或者是其中引入了JavaScript文件）：\n```\nvar foo = 42;\nconsole.log(foo);\n```\n很明显，控制台会打印出`42`，但是如果这段代码不是执行在函数中的话，这一段执行上下文就会变成全局的。因此，这个变量`foo`也会被绑定在`window`对象上，意味着`window.foo`也是`42`。这样是很危险的，你可能覆盖掉了已经存在的全局变量。\n```\nfunction print () {\n   // do something\n}\nprint();\n```\n当执行`windos.print`（或者`print`）时，由于我们已经覆盖了原生的print函数，浏览器就不会弹出打印窗口了。\n\n解决方法很简单；我们需要一个叫做`立即执行函数`的包装函数，如下：\n```\n// Declare an anonymous function\n(function () {\n   var foo = 42;\n   console.log(window.foo);\n   // → undefined\n   console.log(foo);\n   // → 42\n})();\n//^ and call it immediately\n```\n除了这种解决方法，你也可以选择把`window`和其它全局对象（如`document`）作为参数传递给函数（这样可能会提升性能）：\n```\n(function (global, doc) {\n  global.setTimeout(function () {\n     doc.body.innerHTML = \"Hello!\";\n  }, 1000);\n})(window, document);\n```\n因此，你要用包裹函数避免创建全局变量。注意一点，我不会在代码段中使用包裹函数，因为我们是要专注于代码本身。\n\nTip: [模块打包工具browserify](http://browserify.org/)是避免创建全局变量的又一种方法。它以与Node.js同样的方式使用`require`函数。\n\n多说一点，Node.js通过函数来自动包裹你的文件。它们看起来就像这样：\n```\n(function (exports, require, module, __filename, __dirname) {\n// ...\n```\n可能你觉得`require`函数也是全局的，然而它并不是。它只不过是一个函数参数。\n\n#### Did you know?\n\n尽管`window`对象其中包含着全局变量，它本身也是个全局变量，`window`内部指向的是它本身：\n\n```\nwindow.window.window\n// => Window{...}\n```\n这是因为`window`是一个循环对象。想要创建一个循环对象的话可以参考：\n```\n// 创建一个对象\nvar foo = {};\n\n//给对象本身赋值一个属性\nfoo.bar = foo;\n\n// foo就变成了一个循环对象\nfoo.bar.bar.bar.bar\n// → foo\n```\n所以你可以这样表白你对JavaScripte无限的爱了：\n![circle](https://www.filepicker.io/api/file/ZMNjGIiQ52IKsseTjqno)\n你就可以像这样无限扩展这个Object（直到浏览器崩溃）\n\n### 2.使用'use strict'的好处\n\n严格使用`use strict`！没有什么方法比把这行代码添在JavaScript里可以让你的代码更magic了。\n\n举个例子：\n```\n//  糟糕的写法，会让你在不知情的情况下创建了全局变量\n(function () {\n   a = 42;\n   console.log(a);\n   // → 42\n})();\nconsole.log(a);\n// → 42\n```\n\n设置严格模式，你就会得到报错信息：\n```\n(function () {\n   \"use strict\";\n   a = 42;\n   // Error: Uncaught ReferenceError: a is not defined\n})();\n```\n你可能想知道为什么你不能把`\"use strict\"`写在包裹函数外面。事实上，可以写在外面，严格模式就会在全局应用。这么什么不好的，但是要注意如果代码引入了第三方库，或是要打包到一个文件的时候，全局应用可能会造成影响。\n\n### 3.严格等于 ===\n\n如果你想用`==`来比较a和b的话，在JavaScript中你可能会发现它的结果有点奇怪：如果你比较的是字符串和数字，它们也会是相等的（`==`）：\n```\n\"42\" == 42\n// true\n```\n显然，用严格等于（`===`）更好\n```\n\"42\" === 42\n// false\n```\n\n### 4.用`&&`和`||`魔法\n\n在日常工作中，你可以发现用逻辑操作符缩短你的代码\n\n默认\n```\n\"\" || \"foo\"   // → \"foo\"\n\nundefined || 42   // → 42\n\n//注意一下，如果你想通过这种方式来处理0的话，你要检查它是0还是未赋值\nvar a = 0;\na || 42\n// → 42\n\n// 三元表达式看起来就像是一行结构的if-else语句\nvar b = typeof a === \"number\" ? a : 42;\n// → 0\n```\n不需要用if表达式来判断布尔值，你可以简单地这样处理：\n```\nexpr && doSomething();\n\n// Instead of:\nif (expr) {\n   doSomething();\n}\n```\n在上例中如果我们需要`doSomething()`来返回结果的话，使用逻辑操作符会看起来更带感：\n```\nfunction doSomething () {\n   return { foo: \"bar\" };\n}\nvar expr = true;\nvar res = expr && doSomething();\nres && console.log(res);\n// → { foo: \"bar\" }\n```\n在这个问题上你可能会有异议，但使用逻辑操作符确实是更理想的方式。可能你认为用这种方法是“丑化”代码，但那些代码压缩器却真的在这样做。\n\n尽管代码变短了，它的可读性却依然很好。\n\n### 5.改变变量类型\n\n取决于实际场景，有很多改变变量类型的方法，如下是最常用的方法：\n```\n// anything =》 number\n\nvar foo = \"42\";\nvar myNumber = +foo; // shortcut for Number(foo)\n// → 42\n\n// Tip: 可以直接把它变成负数\nvar negativeFoo = -foo; // or -Number(foo)\n// → -42\n\n// object => array\n// Tip: `arguments` 是一个对象但通常被用作为数组\nvar args = { 0: \"foo\", 1: \"bar\", length: 2 };\nArray.prototype.slice.call(args)\n// → [ 'foo', 'bar' ]\n\n// Anything =》 boolean\n// 两次取非可以使它变成布尔值\nvar t = 1;\nvar f = 0;\n!!t\n// → true\n!!f\n// → false\n\n// 一次取非\n!t\n// → false\n!f\n// → true\n\n// Anything =》 string\nvar foo = 42;\n\"\" + foo // 转变为字符串的简短方法\n// → \"42\"\n\nfoo = { hello: \"world\" };\nJSON.stringify(foo);\n// → '{ \"hello\":\"world\" }'\n\nJSON.stringify(foo, null, 4); // 美化代码\n// →\n// '{\n//    \"hello\": \"world\"\n// }'\n\n// 注意一点，不可以 JSON.stringify 环形结构的对象\nJSON.stringify(window);\n// ⚠ TypeError: JSON.stringify cannot serialize cyclic structures.\n```\n\n### 6.代码风格指南\n\n新项目中在不同文件里应该遵循同样的代码风格，对于老项目，就沿用旧的代码风格，除非你下定决心去整体改掉陈旧代码的风格（要和同事讨论之后再决定）。只要你确定了代码风格，就要一直遵循它。\n\n这是一些可参考的代码风格\n\n* [Google JavaScript Style Guide](https://google.github.io/styleguide/javascriptguide.xml)\n* [aribnb/javascript](https://github.com/airbnb/javascript)\n* [my code-style](https://github.com/IonicaBizau/code-style)\n\n### 额外提示\n\n在其它一些JavaScript最佳实践中可以发现有一些有助于编码的工具：\n\n- [js-beautify](https://github.com/beautify-web/js-beautify):美化代码\n- [UglifyJS(2)](https://github.com/mishoo/UglifyJS2):压缩代码\n- [jshint](https://github.com/jshint/jshint):检测代码中的错误\n- [jscs](http://jscs.info/):可扩展的风格检测\n\n最后一件事，好好[debug](https://www.codementor.io/learn-programming/what-to-do-when-your-website-is-broken),而不是用`console.log`\n\n祝编码愉快！\n\n### 参考内容\n* [初学者指南：学习JavaScript的最佳方法](https://www.codementor.io/javascript/tutorial/how-to-learn-javascript-properly)\n* [关于JavaScript初学者必知的十件事](https://www.codementor.io/javascript/tutorial/top-ten-things-beginners-must-know-javascript)\n* [在2016年JavaScript开发者需要学习的技巧](https://www.codementor.io/learn-programming/javascript-trends-skills-developers-should-learn)\n* [4种开始使用ES2015的方法](https://www.codementor.io/javascript/tutorial/4-easy-ways-to-start-using-es2015)\n* [最重要的21道面试题](https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers)\n","slug":"trans-javascript-code-tips","published":1,"updated":"2017-03-15T14:29:06.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyjw0015gbehtcrwqbbc","content":"<p>原文地址：<a href=\"https://www.codementor.io/javascript/tutorial/javascript-best-practices\" target=\"_blank\" rel=\"external\">https://www.codementor.io/javascript/tutorial/javascript-best-practices</a></p>\n<p><img src=\"https://www.filepicker.io/api/file/e4jxgEgHRzS1zQU6aJLR\" alt=\"image\"><br>每天学习新知识可以让我们变成一个更优秀更理性的人。作为一名开发者，持续学习也是我们工作的一部分，无论如何，这些新知识的学习过程都是积极有益的经验积累。</p>\n<p>在这篇教程中，我会提出一些JavaScript的最佳实践，你就不会觉得学习起来很困难了。准备好了就来一起升级你的代码吧！</p>\n<h3 id=\"1-避免污染全局作用域\"><a href=\"#1-避免污染全局作用域\" class=\"headerlink\" title=\"1.避免污染全局作用域\"></a>1.避免污染全局作用域</h3><p>声明变量的过程中有很多有趣的地方。有的时候，你可能在不知情的情况下却声明了一个<code>全局变量</code>。在现代浏览器中，全局变量会被储存在<code>window</code>对象中，因此会有很多内容运行在其中，你不知情声明的全局变量可能会覆盖掉一些默认值。</p>\n<a id=\"more\"></a>\n<p>我们假设你有一个包含<code>&lt;script&gt;</code>标签的HTML文件（或者是其中引入了JavaScript文件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = 42;</div><div class=\"line\">console.log(foo);</div></pre></td></tr></table></figure></p>\n<p>很明显，控制台会打印出<code>42</code>，但是如果这段代码不是执行在函数中的话，这一段执行上下文就会变成全局的。因此，这个变量<code>foo</code>也会被绑定在<code>window</code>对象上，意味着<code>window.foo</code>也是<code>42</code>。这样是很危险的，你可能覆盖掉了已经存在的全局变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function print () &#123;</div><div class=\"line\">   // do something</div><div class=\"line\">&#125;</div><div class=\"line\">print();</div></pre></td></tr></table></figure></p>\n<p>当执行<code>windos.print</code>（或者<code>print</code>）时，由于我们已经覆盖了原生的print函数，浏览器就不会弹出打印窗口了。</p>\n<p>解决方法很简单；我们需要一个叫做<code>立即执行函数</code>的包装函数，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Declare an anonymous function</div><div class=\"line\">(function () &#123;</div><div class=\"line\">   var foo = 42;</div><div class=\"line\">   console.log(window.foo);</div><div class=\"line\">   // → undefined</div><div class=\"line\">   console.log(foo);</div><div class=\"line\">   // → 42</div><div class=\"line\">&#125;)();</div><div class=\"line\">//^ and call it immediately</div></pre></td></tr></table></figure></p>\n<p>除了这种解决方法，你也可以选择把<code>window</code>和其它全局对象（如<code>document</code>）作为参数传递给函数（这样可能会提升性能）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (global, doc) &#123;</div><div class=\"line\">  global.setTimeout(function () &#123;</div><div class=\"line\">     doc.body.innerHTML = &quot;Hello!&quot;;</div><div class=\"line\">  &#125;, 1000);</div><div class=\"line\">&#125;)(window, document);</div></pre></td></tr></table></figure></p>\n<p>因此，你要用包裹函数避免创建全局变量。注意一点，我不会在代码段中使用包裹函数，因为我们是要专注于代码本身。</p>\n<p>Tip: <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"external\">模块打包工具browserify</a>是避免创建全局变量的又一种方法。它以与Node.js同样的方式使用<code>require</code>函数。</p>\n<p>多说一点，Node.js通过函数来自动包裹你的文件。它们看起来就像这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (exports, require, module, __filename, __dirname) &#123;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>可能你觉得<code>require</code>函数也是全局的，然而它并不是。它只不过是一个函数参数。</p>\n<h4 id=\"Did-you-know\"><a href=\"#Did-you-know\" class=\"headerlink\" title=\"Did you know?\"></a>Did you know?</h4><p>尽管<code>window</code>对象其中包含着全局变量，它本身也是个全局变量，<code>window</code>内部指向的是它本身：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.window.window</div><div class=\"line\">// =&gt; Window&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>这是因为<code>window</code>是一个循环对象。想要创建一个循环对象的话可以参考：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建一个对象</div><div class=\"line\">var foo = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">//给对象本身赋值一个属性</div><div class=\"line\">foo.bar = foo;</div><div class=\"line\"></div><div class=\"line\">// foo就变成了一个循环对象</div><div class=\"line\">foo.bar.bar.bar.bar</div><div class=\"line\">// → foo</div></pre></td></tr></table></figure></p>\n<p>所以你可以这样表白你对JavaScripte无限的爱了：<br><img src=\"https://www.filepicker.io/api/file/ZMNjGIiQ52IKsseTjqno\" alt=\"circle\"><br>你就可以像这样无限扩展这个Object（直到浏览器崩溃）</p>\n<h3 id=\"2-使用’use-strict’的好处\"><a href=\"#2-使用’use-strict’的好处\" class=\"headerlink\" title=\"2.使用’use strict’的好处\"></a>2.使用’use strict’的好处</h3><p>严格使用<code>use strict</code>！没有什么方法比把这行代码添在JavaScript里可以让你的代码更magic了。</p>\n<p>举个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  糟糕的写法，会让你在不知情的情况下创建了全局变量</div><div class=\"line\">(function () &#123;</div><div class=\"line\">   a = 42;</div><div class=\"line\">   console.log(a);</div><div class=\"line\">   // → 42</div><div class=\"line\">&#125;)();</div><div class=\"line\">console.log(a);</div><div class=\"line\">// → 42</div></pre></td></tr></table></figure></p>\n<p>设置严格模式，你就会得到报错信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function () &#123;</div><div class=\"line\">   &quot;use strict&quot;;</div><div class=\"line\">   a = 42;</div><div class=\"line\">   // Error: Uncaught ReferenceError: a is not defined</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>你可能想知道为什么你不能把<code>&quot;use strict&quot;</code>写在包裹函数外面。事实上，可以写在外面，严格模式就会在全局应用。这么什么不好的，但是要注意如果代码引入了第三方库，或是要打包到一个文件的时候，全局应用可能会造成影响。</p>\n<h3 id=\"3-严格等于\"><a href=\"#3-严格等于\" class=\"headerlink\" title=\"3.严格等于 ===\"></a>3.严格等于 ===</h3><p>如果你想用<code>==</code>来比较a和b的话，在JavaScript中你可能会发现它的结果有点奇怪：如果你比较的是字符串和数字，它们也会是相等的（<code>==</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;42&quot; == 42</div><div class=\"line\">// true</div></pre></td></tr></table></figure></p>\n<p>显然，用严格等于（<code>===</code>）更好<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;42&quot; === 42</div><div class=\"line\">// false</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-用-amp-amp-和-魔法\"><a href=\"#4-用-amp-amp-和-魔法\" class=\"headerlink\" title=\"4.用&amp;&amp;和||魔法\"></a>4.用<code>&amp;&amp;</code>和<code>||</code>魔法</h3><p>在日常工作中，你可以发现用逻辑操作符缩短你的代码</p>\n<p>默认<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;&quot; || &quot;foo&quot;   // → &quot;foo&quot;</div><div class=\"line\"></div><div class=\"line\">undefined || 42   // → 42</div><div class=\"line\"></div><div class=\"line\">//注意一下，如果你想通过这种方式来处理0的话，你要检查它是0还是未赋值</div><div class=\"line\">var a = 0;</div><div class=\"line\">a || 42</div><div class=\"line\">// → 42</div><div class=\"line\"></div><div class=\"line\">// 三元表达式看起来就像是一行结构的if-else语句</div><div class=\"line\">var b = typeof a === &quot;number&quot; ? a : 42;</div><div class=\"line\">// → 0</div></pre></td></tr></table></figure></p>\n<p>不需要用if表达式来判断布尔值，你可以简单地这样处理：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">expr &amp;&amp; doSomething();</div><div class=\"line\"></div><div class=\"line\">// Instead of:</div><div class=\"line\">if (expr) &#123;</div><div class=\"line\">   doSomething();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上例中如果我们需要<code>doSomething()</code>来返回结果的话，使用逻辑操作符会看起来更带感：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function doSomething () &#123;</div><div class=\"line\">   return &#123; foo: &quot;bar&quot; &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var expr = true;</div><div class=\"line\">var res = expr &amp;&amp; doSomething();</div><div class=\"line\">res &amp;&amp; console.log(res);</div><div class=\"line\">// → &#123; foo: &quot;bar&quot; &#125;</div></pre></td></tr></table></figure></p>\n<p>在这个问题上你可能会有异议，但使用逻辑操作符确实是更理想的方式。可能你认为用这种方法是“丑化”代码，但那些代码压缩器却真的在这样做。</p>\n<p>尽管代码变短了，它的可读性却依然很好。</p>\n<h3 id=\"5-改变变量类型\"><a href=\"#5-改变变量类型\" class=\"headerlink\" title=\"5.改变变量类型\"></a>5.改变变量类型</h3><p>取决于实际场景，有很多改变变量类型的方法，如下是最常用的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">// anything =》 number</div><div class=\"line\"></div><div class=\"line\">var foo = &quot;42&quot;;</div><div class=\"line\">var myNumber = +foo; // shortcut for Number(foo)</div><div class=\"line\">// → 42</div><div class=\"line\"></div><div class=\"line\">// Tip: 可以直接把它变成负数</div><div class=\"line\">var negativeFoo = -foo; // or -Number(foo)</div><div class=\"line\">// → -42</div><div class=\"line\"></div><div class=\"line\">// object =&gt; array</div><div class=\"line\">// Tip: `arguments` 是一个对象但通常被用作为数组</div><div class=\"line\">var args = &#123; 0: &quot;foo&quot;, 1: &quot;bar&quot;, length: 2 &#125;;</div><div class=\"line\">Array.prototype.slice.call(args)</div><div class=\"line\">// → [ &apos;foo&apos;, &apos;bar&apos; ]</div><div class=\"line\"></div><div class=\"line\">// Anything =》 boolean</div><div class=\"line\">// 两次取非可以使它变成布尔值</div><div class=\"line\">var t = 1;</div><div class=\"line\">var f = 0;</div><div class=\"line\">!!t</div><div class=\"line\">// → true</div><div class=\"line\">!!f</div><div class=\"line\">// → false</div><div class=\"line\"></div><div class=\"line\">// 一次取非</div><div class=\"line\">!t</div><div class=\"line\">// → false</div><div class=\"line\">!f</div><div class=\"line\">// → true</div><div class=\"line\"></div><div class=\"line\">// Anything =》 string</div><div class=\"line\">var foo = 42;</div><div class=\"line\">&quot;&quot; + foo // 转变为字符串的简短方法</div><div class=\"line\">// → &quot;42&quot;</div><div class=\"line\"></div><div class=\"line\">foo = &#123; hello: &quot;world&quot; &#125;;</div><div class=\"line\">JSON.stringify(foo);</div><div class=\"line\">// → &apos;&#123; &quot;hello&quot;:&quot;world&quot; &#125;&apos;</div><div class=\"line\"></div><div class=\"line\">JSON.stringify(foo, null, 4); // 美化代码</div><div class=\"line\">// →</div><div class=\"line\">// &apos;&#123;</div><div class=\"line\">//    &quot;hello&quot;: &quot;world&quot;</div><div class=\"line\">// &#125;&apos;</div><div class=\"line\"></div><div class=\"line\">// 注意一点，不可以 JSON.stringify 环形结构的对象</div><div class=\"line\">JSON.stringify(window);</div><div class=\"line\">// ⚠ TypeError: JSON.stringify cannot serialize cyclic structures.</div></pre></td></tr></table></figure></p>\n<h3 id=\"6-代码风格指南\"><a href=\"#6-代码风格指南\" class=\"headerlink\" title=\"6.代码风格指南\"></a>6.代码风格指南</h3><p>新项目中在不同文件里应该遵循同样的代码风格，对于老项目，就沿用旧的代码风格，除非你下定决心去整体改掉陈旧代码的风格（要和同事讨论之后再决定）。只要你确定了代码风格，就要一直遵循它。</p>\n<p>这是一些可参考的代码风格</p>\n<ul>\n<li><a href=\"https://google.github.io/styleguide/javascriptguide.xml\" target=\"_blank\" rel=\"external\">Google JavaScript Style Guide</a></li>\n<li><a href=\"https://github.com/airbnb/javascript\" target=\"_blank\" rel=\"external\">aribnb/javascript</a></li>\n<li><a href=\"https://github.com/IonicaBizau/code-style\" target=\"_blank\" rel=\"external\">my code-style</a></li>\n</ul>\n<h3 id=\"额外提示\"><a href=\"#额外提示\" class=\"headerlink\" title=\"额外提示\"></a>额外提示</h3><p>在其它一些JavaScript最佳实践中可以发现有一些有助于编码的工具：</p>\n<ul>\n<li><a href=\"https://github.com/beautify-web/js-beautify\" target=\"_blank\" rel=\"external\">js-beautify</a>:美化代码</li>\n<li><a href=\"https://github.com/mishoo/UglifyJS2\" target=\"_blank\" rel=\"external\">UglifyJS(2)</a>:压缩代码</li>\n<li><a href=\"https://github.com/jshint/jshint\" target=\"_blank\" rel=\"external\">jshint</a>:检测代码中的错误</li>\n<li><a href=\"http://jscs.info/\" target=\"_blank\" rel=\"external\">jscs</a>:可扩展的风格检测</li>\n</ul>\n<p>最后一件事，好好<a href=\"https://www.codementor.io/learn-programming/what-to-do-when-your-website-is-broken\" target=\"_blank\" rel=\"external\">debug</a>,而不是用<code>console.log</code></p>\n<p>祝编码愉快！</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/how-to-learn-javascript-properly\" target=\"_blank\" rel=\"external\">初学者指南：学习JavaScript的最佳方法</a></li>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/top-ten-things-beginners-must-know-javascript\" target=\"_blank\" rel=\"external\">关于JavaScript初学者必知的十件事</a></li>\n<li><a href=\"https://www.codementor.io/learn-programming/javascript-trends-skills-developers-should-learn\" target=\"_blank\" rel=\"external\">在2016年JavaScript开发者需要学习的技巧</a></li>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/4-easy-ways-to-start-using-es2015\" target=\"_blank\" rel=\"external\">4种开始使用ES2015的方法</a></li>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers\" target=\"_blank\" rel=\"external\">最重要的21道面试题</a></li>\n</ul>\n","excerpt":"<p>原文地址：<a href=\"https://www.codementor.io/javascript/tutorial/javascript-best-practices\">https://www.codementor.io/javascript/tutorial/javascript-best-practices</a></p>\n<p><img src=\"https://www.filepicker.io/api/file/e4jxgEgHRzS1zQU6aJLR\" alt=\"image\"><br>每天学习新知识可以让我们变成一个更优秀更理性的人。作为一名开发者，持续学习也是我们工作的一部分，无论如何，这些新知识的学习过程都是积极有益的经验积累。</p>\n<p>在这篇教程中，我会提出一些JavaScript的最佳实践，你就不会觉得学习起来很困难了。准备好了就来一起升级你的代码吧！</p>\n<h3 id=\"1-避免污染全局作用域\"><a href=\"#1-避免污染全局作用域\" class=\"headerlink\" title=\"1.避免污染全局作用域\"></a>1.避免污染全局作用域</h3><p>声明变量的过程中有很多有趣的地方。有的时候，你可能在不知情的情况下却声明了一个<code>全局变量</code>。在现代浏览器中，全局变量会被储存在<code>window</code>对象中，因此会有很多内容运行在其中，你不知情声明的全局变量可能会覆盖掉一些默认值。</p>","more":"<p>我们假设你有一个包含<code>&lt;script&gt;</code>标签的HTML文件（或者是其中引入了JavaScript文件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = 42;</div><div class=\"line\">console.log(foo);</div></pre></td></tr></table></figure></p>\n<p>很明显，控制台会打印出<code>42</code>，但是如果这段代码不是执行在函数中的话，这一段执行上下文就会变成全局的。因此，这个变量<code>foo</code>也会被绑定在<code>window</code>对象上，意味着<code>window.foo</code>也是<code>42</code>。这样是很危险的，你可能覆盖掉了已经存在的全局变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function print () &#123;</div><div class=\"line\">   // do something</div><div class=\"line\">&#125;</div><div class=\"line\">print();</div></pre></td></tr></table></figure></p>\n<p>当执行<code>windos.print</code>（或者<code>print</code>）时，由于我们已经覆盖了原生的print函数，浏览器就不会弹出打印窗口了。</p>\n<p>解决方法很简单；我们需要一个叫做<code>立即执行函数</code>的包装函数，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Declare an anonymous function</div><div class=\"line\">(function () &#123;</div><div class=\"line\">   var foo = 42;</div><div class=\"line\">   console.log(window.foo);</div><div class=\"line\">   // → undefined</div><div class=\"line\">   console.log(foo);</div><div class=\"line\">   // → 42</div><div class=\"line\">&#125;)();</div><div class=\"line\">//^ and call it immediately</div></pre></td></tr></table></figure></p>\n<p>除了这种解决方法，你也可以选择把<code>window</code>和其它全局对象（如<code>document</code>）作为参数传递给函数（这样可能会提升性能）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (global, doc) &#123;</div><div class=\"line\">  global.setTimeout(function () &#123;</div><div class=\"line\">     doc.body.innerHTML = &quot;Hello!&quot;;</div><div class=\"line\">  &#125;, 1000);</div><div class=\"line\">&#125;)(window, document);</div></pre></td></tr></table></figure></p>\n<p>因此，你要用包裹函数避免创建全局变量。注意一点，我不会在代码段中使用包裹函数，因为我们是要专注于代码本身。</p>\n<p>Tip: <a href=\"http://browserify.org/\">模块打包工具browserify</a>是避免创建全局变量的又一种方法。它以与Node.js同样的方式使用<code>require</code>函数。</p>\n<p>多说一点，Node.js通过函数来自动包裹你的文件。它们看起来就像这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (exports, require, module, __filename, __dirname) &#123;</div><div class=\"line\">// ...</div></pre></td></tr></table></figure></p>\n<p>可能你觉得<code>require</code>函数也是全局的，然而它并不是。它只不过是一个函数参数。</p>\n<h4 id=\"Did-you-know\"><a href=\"#Did-you-know\" class=\"headerlink\" title=\"Did you know?\"></a>Did you know?</h4><p>尽管<code>window</code>对象其中包含着全局变量，它本身也是个全局变量，<code>window</code>内部指向的是它本身：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.window.window</div><div class=\"line\">// =&gt; Window&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>这是因为<code>window</code>是一个循环对象。想要创建一个循环对象的话可以参考：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建一个对象</div><div class=\"line\">var foo = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">//给对象本身赋值一个属性</div><div class=\"line\">foo.bar = foo;</div><div class=\"line\"></div><div class=\"line\">// foo就变成了一个循环对象</div><div class=\"line\">foo.bar.bar.bar.bar</div><div class=\"line\">// → foo</div></pre></td></tr></table></figure></p>\n<p>所以你可以这样表白你对JavaScripte无限的爱了：<br><img src=\"https://www.filepicker.io/api/file/ZMNjGIiQ52IKsseTjqno\" alt=\"circle\"><br>你就可以像这样无限扩展这个Object（直到浏览器崩溃）</p>\n<h3 id=\"2-使用’use-strict’的好处\"><a href=\"#2-使用’use-strict’的好处\" class=\"headerlink\" title=\"2.使用’use strict’的好处\"></a>2.使用’use strict’的好处</h3><p>严格使用<code>use strict</code>！没有什么方法比把这行代码添在JavaScript里可以让你的代码更magic了。</p>\n<p>举个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  糟糕的写法，会让你在不知情的情况下创建了全局变量</div><div class=\"line\">(function () &#123;</div><div class=\"line\">   a = 42;</div><div class=\"line\">   console.log(a);</div><div class=\"line\">   // → 42</div><div class=\"line\">&#125;)();</div><div class=\"line\">console.log(a);</div><div class=\"line\">// → 42</div></pre></td></tr></table></figure></p>\n<p>设置严格模式，你就会得到报错信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function () &#123;</div><div class=\"line\">   &quot;use strict&quot;;</div><div class=\"line\">   a = 42;</div><div class=\"line\">   // Error: Uncaught ReferenceError: a is not defined</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>你可能想知道为什么你不能把<code>&quot;use strict&quot;</code>写在包裹函数外面。事实上，可以写在外面，严格模式就会在全局应用。这么什么不好的，但是要注意如果代码引入了第三方库，或是要打包到一个文件的时候，全局应用可能会造成影响。</p>\n<h3 id=\"3-严格等于\"><a href=\"#3-严格等于\" class=\"headerlink\" title=\"3.严格等于 ===\"></a>3.严格等于 ===</h3><p>如果你想用<code>==</code>来比较a和b的话，在JavaScript中你可能会发现它的结果有点奇怪：如果你比较的是字符串和数字，它们也会是相等的（<code>==</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;42&quot; == 42</div><div class=\"line\">// true</div></pre></td></tr></table></figure></p>\n<p>显然，用严格等于（<code>===</code>）更好<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;42&quot; === 42</div><div class=\"line\">// false</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-用-amp-amp-和-魔法\"><a href=\"#4-用-amp-amp-和-魔法\" class=\"headerlink\" title=\"4.用&amp;&amp;和||魔法\"></a>4.用<code>&amp;&amp;</code>和<code>||</code>魔法</h3><p>在日常工作中，你可以发现用逻辑操作符缩短你的代码</p>\n<p>默认<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;&quot; || &quot;foo&quot;   // → &quot;foo&quot;</div><div class=\"line\"></div><div class=\"line\">undefined || 42   // → 42</div><div class=\"line\"></div><div class=\"line\">//注意一下，如果你想通过这种方式来处理0的话，你要检查它是0还是未赋值</div><div class=\"line\">var a = 0;</div><div class=\"line\">a || 42</div><div class=\"line\">// → 42</div><div class=\"line\"></div><div class=\"line\">// 三元表达式看起来就像是一行结构的if-else语句</div><div class=\"line\">var b = typeof a === &quot;number&quot; ? a : 42;</div><div class=\"line\">// → 0</div></pre></td></tr></table></figure></p>\n<p>不需要用if表达式来判断布尔值，你可以简单地这样处理：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">expr &amp;&amp; doSomething();</div><div class=\"line\"></div><div class=\"line\">// Instead of:</div><div class=\"line\">if (expr) &#123;</div><div class=\"line\">   doSomething();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上例中如果我们需要<code>doSomething()</code>来返回结果的话，使用逻辑操作符会看起来更带感：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function doSomething () &#123;</div><div class=\"line\">   return &#123; foo: &quot;bar&quot; &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var expr = true;</div><div class=\"line\">var res = expr &amp;&amp; doSomething();</div><div class=\"line\">res &amp;&amp; console.log(res);</div><div class=\"line\">// → &#123; foo: &quot;bar&quot; &#125;</div></pre></td></tr></table></figure></p>\n<p>在这个问题上你可能会有异议，但使用逻辑操作符确实是更理想的方式。可能你认为用这种方法是“丑化”代码，但那些代码压缩器却真的在这样做。</p>\n<p>尽管代码变短了，它的可读性却依然很好。</p>\n<h3 id=\"5-改变变量类型\"><a href=\"#5-改变变量类型\" class=\"headerlink\" title=\"5.改变变量类型\"></a>5.改变变量类型</h3><p>取决于实际场景，有很多改变变量类型的方法，如下是最常用的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">// anything =》 number</div><div class=\"line\"></div><div class=\"line\">var foo = &quot;42&quot;;</div><div class=\"line\">var myNumber = +foo; // shortcut for Number(foo)</div><div class=\"line\">// → 42</div><div class=\"line\"></div><div class=\"line\">// Tip: 可以直接把它变成负数</div><div class=\"line\">var negativeFoo = -foo; // or -Number(foo)</div><div class=\"line\">// → -42</div><div class=\"line\"></div><div class=\"line\">// object =&gt; array</div><div class=\"line\">// Tip: `arguments` 是一个对象但通常被用作为数组</div><div class=\"line\">var args = &#123; 0: &quot;foo&quot;, 1: &quot;bar&quot;, length: 2 &#125;;</div><div class=\"line\">Array.prototype.slice.call(args)</div><div class=\"line\">// → [ &apos;foo&apos;, &apos;bar&apos; ]</div><div class=\"line\"></div><div class=\"line\">// Anything =》 boolean</div><div class=\"line\">// 两次取非可以使它变成布尔值</div><div class=\"line\">var t = 1;</div><div class=\"line\">var f = 0;</div><div class=\"line\">!!t</div><div class=\"line\">// → true</div><div class=\"line\">!!f</div><div class=\"line\">// → false</div><div class=\"line\"></div><div class=\"line\">// 一次取非</div><div class=\"line\">!t</div><div class=\"line\">// → false</div><div class=\"line\">!f</div><div class=\"line\">// → true</div><div class=\"line\"></div><div class=\"line\">// Anything =》 string</div><div class=\"line\">var foo = 42;</div><div class=\"line\">&quot;&quot; + foo // 转变为字符串的简短方法</div><div class=\"line\">// → &quot;42&quot;</div><div class=\"line\"></div><div class=\"line\">foo = &#123; hello: &quot;world&quot; &#125;;</div><div class=\"line\">JSON.stringify(foo);</div><div class=\"line\">// → &apos;&#123; &quot;hello&quot;:&quot;world&quot; &#125;&apos;</div><div class=\"line\"></div><div class=\"line\">JSON.stringify(foo, null, 4); // 美化代码</div><div class=\"line\">// →</div><div class=\"line\">// &apos;&#123;</div><div class=\"line\">//    &quot;hello&quot;: &quot;world&quot;</div><div class=\"line\">// &#125;&apos;</div><div class=\"line\"></div><div class=\"line\">// 注意一点，不可以 JSON.stringify 环形结构的对象</div><div class=\"line\">JSON.stringify(window);</div><div class=\"line\">// ⚠ TypeError: JSON.stringify cannot serialize cyclic structures.</div></pre></td></tr></table></figure></p>\n<h3 id=\"6-代码风格指南\"><a href=\"#6-代码风格指南\" class=\"headerlink\" title=\"6.代码风格指南\"></a>6.代码风格指南</h3><p>新项目中在不同文件里应该遵循同样的代码风格，对于老项目，就沿用旧的代码风格，除非你下定决心去整体改掉陈旧代码的风格（要和同事讨论之后再决定）。只要你确定了代码风格，就要一直遵循它。</p>\n<p>这是一些可参考的代码风格</p>\n<ul>\n<li><a href=\"https://google.github.io/styleguide/javascriptguide.xml\">Google JavaScript Style Guide</a></li>\n<li><a href=\"https://github.com/airbnb/javascript\">aribnb/javascript</a></li>\n<li><a href=\"https://github.com/IonicaBizau/code-style\">my code-style</a></li>\n</ul>\n<h3 id=\"额外提示\"><a href=\"#额外提示\" class=\"headerlink\" title=\"额外提示\"></a>额外提示</h3><p>在其它一些JavaScript最佳实践中可以发现有一些有助于编码的工具：</p>\n<ul>\n<li><a href=\"https://github.com/beautify-web/js-beautify\">js-beautify</a>:美化代码</li>\n<li><a href=\"https://github.com/mishoo/UglifyJS2\">UglifyJS(2)</a>:压缩代码</li>\n<li><a href=\"https://github.com/jshint/jshint\">jshint</a>:检测代码中的错误</li>\n<li><a href=\"http://jscs.info/\">jscs</a>:可扩展的风格检测</li>\n</ul>\n<p>最后一件事，好好<a href=\"https://www.codementor.io/learn-programming/what-to-do-when-your-website-is-broken\">debug</a>,而不是用<code>console.log</code></p>\n<p>祝编码愉快！</p>\n<h3 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h3><ul>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/how-to-learn-javascript-properly\">初学者指南：学习JavaScript的最佳方法</a></li>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/top-ten-things-beginners-must-know-javascript\">关于JavaScript初学者必知的十件事</a></li>\n<li><a href=\"https://www.codementor.io/learn-programming/javascript-trends-skills-developers-should-learn\">在2016年JavaScript开发者需要学习的技巧</a></li>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/4-easy-ways-to-start-using-es2015\">4种开始使用ES2015的方法</a></li>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers\">最重要的21道面试题</a></li>\n</ul>"},{"layout":"post","title":"Make Shell/Git Better","date":"2017-09-15T09:43:00.000Z","_content":"\n## 1.起手式 oh-my-zsh\n![oh-my-zsh](https://camo.githubusercontent.com/5c385f15f3eaedb72cfcfbbaf75355b700ac0757/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6f686d797a73682f6f682d6d792d7a73682d6c6f676f2e706e67)\n\nzsh 被称作是最强大的 shell，而 oh-my-zsh 则是最流行的 zsh 配置文件，提供了丰富的主题以及大量插件，极大地扩展了 zsh 的功能。\n可以无脑引入，便得到了最基本又好用的文件夹跳转，路径、命令、参数补全等便利操作。\n推荐 plugin: git, [autojump](https://github.com/wting/autojump/wiki), [osx](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx)\n\n## 2.优化你的 Git\n**① 美化 diff**\nGit 自己的 git diff 还是蛮不好用也不好看的，文件名和 diff 内容不太好定位。\n基于 [diff-so-fancy](https://github.com/so-fancy/diff-so-fancy) 我们可以做一些美化工作。\n\n<!--more-->\n\n```shell\nnpm install diff-so-fancy -g\n```\n然后在 `~/.gitconfig` 文件中编辑\n```shell\n[alias]\n  d = \"!f() { [ -z \\\"$GIT_PREFIX\\\" ] || cd \\\"$GIT_PREFIX\\\" && git diff --color \\\"$@\\\" | diff-so-fancy  | less --tabs=4 -    RFX; }; f\"\n```\n\n可以参考 `diff-so-fancy` 中的推荐颜色做配置，然后通过 `git d` 命令就可以看到优化过的 diff 信息了\n（git diff VS git d）\n![diff](https://cloud.githubusercontent.com/assets/39191/13622719/7cc7c54c-e555-11e5-86c4-7045d91af041.png)\n\n**② 美化 log**\ngit log 打出来的日志结构是完全扁平的，信息也不够全，依然是很难一眼找到自己想要的信息\n依然是在 `~/.gitconfig` 中编辑：\n```shell\n[alias]\nlg = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset)     %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all\n```\n这样信息清晰好看了很多，也可以看到每个提交所在的分支及其分化衍合的情况\n(git log VS git lg)\n\n![log](http://o7ts2uaks.bkt.clouddn.com/6E897688-D526-4DC5-A373-05FB41734A91.png)\n![lg](http://o7ts2uaks.bkt.clouddn.com/84B43431-AB74-446F-8442-3DFCD8E8E8BE.png)\n\n**③ 命令加强 [git-extras](https://github.com/tj/git-extras)**\nTJ出品的 git 命令扩展集，应有尽有，要啥有啥，按需取用\n\n## 3.终端复用神器 Tmux\n\nTmux 是 Linux 中一种管理窗口的程序，用 Tmux 的主要原因是它提供了一个窗体组随时存储和恢复的功能。\n现在我们经常在开发时给一个项目起很多 server，webpack server 占一个 tab，mock server 占一个 tab，开的时候开半天，哪个断了还要挨个找。\n或者，在用 SSH 登录远程服务器进行调试时，开了N多窗口，过了一会儿发现 `Broken Pipe` 管子裂了，又得重来。\nTmux 可以帮助我们 split 窗口以及进行终端复用保证工作现场不丢失。\n[使用与安装方法](http://cenalulu.github.io/linux/tmux/)\n\n## 4.给命令行使用的代理工具 [proxychains-ng](https://github.com/rofl0r/proxychains-ng)\n用公司的 mnpm 镜像其实就基本不需要这个了。\n自己搭服务器或者在家里办公有需求的话可以用。\n\n## 5. commit message 规范工具 [commitizen](https://github.com/commitizen/cz-cli)\n制定 Code Review 规范时看到了 [Egg.js 的代码贡献规范](https://eggjs.org/zh-cn/contributing.html)\n其中总结了一条好的，有意义的 commit message 应该包含：\n\n> ① type: 本次 commit 的类型(feat/fix/stype/perf....)\n> ② scope: 改动范围\n> ③ subject: 简要概述本次提交做了什么\n> ④ body: 补充 subject, 可以不写\n> ⑤ footer: 本次提交关联的 issue, task\n\n手动按这个写还挺累挺难的，因此决定在团队中推行使用 commitizen\n简单好用，立竿见影\n![commitizen](https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png)\n\n## 6.好玩的 [thefuck](https://github.com/nvbn/thefuck)\n\n![thefuck](https://raw.githubusercontent.com/nvbn/thefuck/master/example.gif)\n\n一个好玩的小工具，给开发添点乐趣。\n","source":"_posts/make-shell-and-git-better.md","raw":"---\nlayout: post\ntitle:  \"Make Shell/Git Better\"\ndate:   2017-09-15 17:43\ncategories: shell git linux\n---\n\n## 1.起手式 oh-my-zsh\n![oh-my-zsh](https://camo.githubusercontent.com/5c385f15f3eaedb72cfcfbbaf75355b700ac0757/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6f686d797a73682f6f682d6d792d7a73682d6c6f676f2e706e67)\n\nzsh 被称作是最强大的 shell，而 oh-my-zsh 则是最流行的 zsh 配置文件，提供了丰富的主题以及大量插件，极大地扩展了 zsh 的功能。\n可以无脑引入，便得到了最基本又好用的文件夹跳转，路径、命令、参数补全等便利操作。\n推荐 plugin: git, [autojump](https://github.com/wting/autojump/wiki), [osx](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx)\n\n## 2.优化你的 Git\n**① 美化 diff**\nGit 自己的 git diff 还是蛮不好用也不好看的，文件名和 diff 内容不太好定位。\n基于 [diff-so-fancy](https://github.com/so-fancy/diff-so-fancy) 我们可以做一些美化工作。\n\n<!--more-->\n\n```shell\nnpm install diff-so-fancy -g\n```\n然后在 `~/.gitconfig` 文件中编辑\n```shell\n[alias]\n  d = \"!f() { [ -z \\\"$GIT_PREFIX\\\" ] || cd \\\"$GIT_PREFIX\\\" && git diff --color \\\"$@\\\" | diff-so-fancy  | less --tabs=4 -    RFX; }; f\"\n```\n\n可以参考 `diff-so-fancy` 中的推荐颜色做配置，然后通过 `git d` 命令就可以看到优化过的 diff 信息了\n（git diff VS git d）\n![diff](https://cloud.githubusercontent.com/assets/39191/13622719/7cc7c54c-e555-11e5-86c4-7045d91af041.png)\n\n**② 美化 log**\ngit log 打出来的日志结构是完全扁平的，信息也不够全，依然是很难一眼找到自己想要的信息\n依然是在 `~/.gitconfig` 中编辑：\n```shell\n[alias]\nlg = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset)     %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all\n```\n这样信息清晰好看了很多，也可以看到每个提交所在的分支及其分化衍合的情况\n(git log VS git lg)\n\n![log](http://o7ts2uaks.bkt.clouddn.com/6E897688-D526-4DC5-A373-05FB41734A91.png)\n![lg](http://o7ts2uaks.bkt.clouddn.com/84B43431-AB74-446F-8442-3DFCD8E8E8BE.png)\n\n**③ 命令加强 [git-extras](https://github.com/tj/git-extras)**\nTJ出品的 git 命令扩展集，应有尽有，要啥有啥，按需取用\n\n## 3.终端复用神器 Tmux\n\nTmux 是 Linux 中一种管理窗口的程序，用 Tmux 的主要原因是它提供了一个窗体组随时存储和恢复的功能。\n现在我们经常在开发时给一个项目起很多 server，webpack server 占一个 tab，mock server 占一个 tab，开的时候开半天，哪个断了还要挨个找。\n或者，在用 SSH 登录远程服务器进行调试时，开了N多窗口，过了一会儿发现 `Broken Pipe` 管子裂了，又得重来。\nTmux 可以帮助我们 split 窗口以及进行终端复用保证工作现场不丢失。\n[使用与安装方法](http://cenalulu.github.io/linux/tmux/)\n\n## 4.给命令行使用的代理工具 [proxychains-ng](https://github.com/rofl0r/proxychains-ng)\n用公司的 mnpm 镜像其实就基本不需要这个了。\n自己搭服务器或者在家里办公有需求的话可以用。\n\n## 5. commit message 规范工具 [commitizen](https://github.com/commitizen/cz-cli)\n制定 Code Review 规范时看到了 [Egg.js 的代码贡献规范](https://eggjs.org/zh-cn/contributing.html)\n其中总结了一条好的，有意义的 commit message 应该包含：\n\n> ① type: 本次 commit 的类型(feat/fix/stype/perf....)\n> ② scope: 改动范围\n> ③ subject: 简要概述本次提交做了什么\n> ④ body: 补充 subject, 可以不写\n> ⑤ footer: 本次提交关联的 issue, task\n\n手动按这个写还挺累挺难的，因此决定在团队中推行使用 commitizen\n简单好用，立竿见影\n![commitizen](https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png)\n\n## 6.好玩的 [thefuck](https://github.com/nvbn/thefuck)\n\n![thefuck](https://raw.githubusercontent.com/nvbn/thefuck/master/example.gif)\n\n一个好玩的小工具，给开发添点乐趣。\n","slug":"make-shell-and-git-better","published":1,"updated":"2017-09-15T16:01:19.000Z","comments":1,"photos":[],"link":"","_id":"cja54xyk10017gbehsogxs6av","content":"<h2 id=\"1-起手式-oh-my-zsh\"><a href=\"#1-起手式-oh-my-zsh\" class=\"headerlink\" title=\"1.起手式 oh-my-zsh\"></a>1.起手式 oh-my-zsh</h2><p><img src=\"https://camo.githubusercontent.com/5c385f15f3eaedb72cfcfbbaf75355b700ac0757/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6f686d797a73682f6f682d6d792d7a73682d6c6f676f2e706e67\" alt=\"oh-my-zsh\"></p>\n<p>zsh 被称作是最强大的 shell，而 oh-my-zsh 则是最流行的 zsh 配置文件，提供了丰富的主题以及大量插件，极大地扩展了 zsh 的功能。<br>可以无脑引入，便得到了最基本又好用的文件夹跳转，路径、命令、参数补全等便利操作。<br>推荐 plugin: git, <a href=\"https://github.com/wting/autojump/wiki\" target=\"_blank\" rel=\"external\">autojump</a>, <a href=\"https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx\" target=\"_blank\" rel=\"external\">osx</a></p>\n<h2 id=\"2-优化你的-Git\"><a href=\"#2-优化你的-Git\" class=\"headerlink\" title=\"2.优化你的 Git\"></a>2.优化你的 Git</h2><p><strong>① 美化 diff</strong><br>Git 自己的 git diff 还是蛮不好用也不好看的，文件名和 diff 内容不太好定位。<br>基于 <a href=\"https://github.com/so-fancy/diff-so-fancy\" target=\"_blank\" rel=\"external\">diff-so-fancy</a> 我们可以做一些美化工作。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install diff-so-fancy -g</div></pre></td></tr></table></figure>\n<p>然后在 <code>~/.gitconfig</code> 文件中编辑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[alias]</div><div class=\"line\">  d = &quot;!f() &#123; [ -z \\&quot;$GIT_PREFIX\\&quot; ] || cd \\&quot;$GIT_PREFIX\\&quot; &amp;&amp; git diff --color \\&quot;$@\\&quot; | diff-so-fancy  | less --tabs=4 -    RFX; &#125;; f&quot;</div></pre></td></tr></table></figure></p>\n<p>可以参考 <code>diff-so-fancy</code> 中的推荐颜色做配置，然后通过 <code>git d</code> 命令就可以看到优化过的 diff 信息了<br>（git diff VS git d）<br><img src=\"https://cloud.githubusercontent.com/assets/39191/13622719/7cc7c54c-e555-11e5-86c4-7045d91af041.png\" alt=\"diff\"></p>\n<p><strong>② 美化 log</strong><br>git log 打出来的日志结构是完全扁平的，信息也不够全，依然是很难一眼找到自己想要的信息<br>依然是在 <code>~/.gitconfig</code> 中编辑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[alias]</div><div class=\"line\">lg = log --graph --abbrev-commit --decorate --format=format:&apos;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset)     %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&apos; --all</div></pre></td></tr></table></figure></p>\n<p>这样信息清晰好看了很多，也可以看到每个提交所在的分支及其分化衍合的情况<br>(git log VS git lg)</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/6E897688-D526-4DC5-A373-05FB41734A91.png\" alt=\"log\"><br><img src=\"http://o7ts2uaks.bkt.clouddn.com/84B43431-AB74-446F-8442-3DFCD8E8E8BE.png\" alt=\"lg\"></p>\n<p><strong>③ 命令加强 <a href=\"https://github.com/tj/git-extras\" target=\"_blank\" rel=\"external\">git-extras</a></strong><br>TJ出品的 git 命令扩展集，应有尽有，要啥有啥，按需取用</p>\n<h2 id=\"3-终端复用神器-Tmux\"><a href=\"#3-终端复用神器-Tmux\" class=\"headerlink\" title=\"3.终端复用神器 Tmux\"></a>3.终端复用神器 Tmux</h2><p>Tmux 是 Linux 中一种管理窗口的程序，用 Tmux 的主要原因是它提供了一个窗体组随时存储和恢复的功能。<br>现在我们经常在开发时给一个项目起很多 server，webpack server 占一个 tab，mock server 占一个 tab，开的时候开半天，哪个断了还要挨个找。<br>或者，在用 SSH 登录远程服务器进行调试时，开了N多窗口，过了一会儿发现 <code>Broken Pipe</code> 管子裂了，又得重来。<br>Tmux 可以帮助我们 split 窗口以及进行终端复用保证工作现场不丢失。<br><a href=\"http://cenalulu.github.io/linux/tmux/\" target=\"_blank\" rel=\"external\">使用与安装方法</a></p>\n<h2 id=\"4-给命令行使用的代理工具-proxychains-ng\"><a href=\"#4-给命令行使用的代理工具-proxychains-ng\" class=\"headerlink\" title=\"4.给命令行使用的代理工具 proxychains-ng\"></a>4.给命令行使用的代理工具 <a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"external\">proxychains-ng</a></h2><p>用公司的 mnpm 镜像其实就基本不需要这个了。<br>自己搭服务器或者在家里办公有需求的话可以用。</p>\n<h2 id=\"5-commit-message-规范工具-commitizen\"><a href=\"#5-commit-message-规范工具-commitizen\" class=\"headerlink\" title=\"5. commit message 规范工具 commitizen\"></a>5. commit message 规范工具 <a href=\"https://github.com/commitizen/cz-cli\" target=\"_blank\" rel=\"external\">commitizen</a></h2><p>制定 Code Review 规范时看到了 <a href=\"https://eggjs.org/zh-cn/contributing.html\" target=\"_blank\" rel=\"external\">Egg.js 的代码贡献规范</a><br>其中总结了一条好的，有意义的 commit message 应该包含：</p>\n<blockquote>\n<p>① type: 本次 commit 的类型(feat/fix/stype/perf….)<br>② scope: 改动范围<br>③ subject: 简要概述本次提交做了什么<br>④ body: 补充 subject, 可以不写<br>⑤ footer: 本次提交关联的 issue, task</p>\n</blockquote>\n<p>手动按这个写还挺累挺难的，因此决定在团队中推行使用 commitizen<br>简单好用，立竿见影<br><img src=\"https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png\" alt=\"commitizen\"></p>\n<h2 id=\"6-好玩的-thefuck\"><a href=\"#6-好玩的-thefuck\" class=\"headerlink\" title=\"6.好玩的 thefuck\"></a>6.好玩的 <a href=\"https://github.com/nvbn/thefuck\" target=\"_blank\" rel=\"external\">thefuck</a></h2><p><img src=\"https://raw.githubusercontent.com/nvbn/thefuck/master/example.gif\" alt=\"thefuck\"></p>\n<p>一个好玩的小工具，给开发添点乐趣。</p>\n","excerpt":"<h2 id=\"1-起手式-oh-my-zsh\"><a href=\"#1-起手式-oh-my-zsh\" class=\"headerlink\" title=\"1.起手式 oh-my-zsh\"></a>1.起手式 oh-my-zsh</h2><p><img src=\"https://camo.githubusercontent.com/5c385f15f3eaedb72cfcfbbaf75355b700ac0757/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6f686d797a73682f6f682d6d792d7a73682d6c6f676f2e706e67\" alt=\"oh-my-zsh\"></p>\n<p>zsh 被称作是最强大的 shell，而 oh-my-zsh 则是最流行的 zsh 配置文件，提供了丰富的主题以及大量插件，极大地扩展了 zsh 的功能。<br>可以无脑引入，便得到了最基本又好用的文件夹跳转，路径、命令、参数补全等便利操作。<br>推荐 plugin: git, <a href=\"https://github.com/wting/autojump/wiki\">autojump</a>, <a href=\"https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx\">osx</a></p>\n<h2 id=\"2-优化你的-Git\"><a href=\"#2-优化你的-Git\" class=\"headerlink\" title=\"2.优化你的 Git\"></a>2.优化你的 Git</h2><p><strong>① 美化 diff</strong><br>Git 自己的 git diff 还是蛮不好用也不好看的，文件名和 diff 内容不太好定位。<br>基于 <a href=\"https://github.com/so-fancy/diff-so-fancy\">diff-so-fancy</a> 我们可以做一些美化工作。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install diff-so-fancy -g</div></pre></td></tr></table></figure>\n<p>然后在 <code>~/.gitconfig</code> 文件中编辑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[alias]</div><div class=\"line\">  d = &quot;!f() &#123; [ -z \\&quot;$GIT_PREFIX\\&quot; ] || cd \\&quot;$GIT_PREFIX\\&quot; &amp;&amp; git diff --color \\&quot;$@\\&quot; | diff-so-fancy  | less --tabs=4 -    RFX; &#125;; f&quot;</div></pre></td></tr></table></figure></p>\n<p>可以参考 <code>diff-so-fancy</code> 中的推荐颜色做配置，然后通过 <code>git d</code> 命令就可以看到优化过的 diff 信息了<br>（git diff VS git d）<br><img src=\"https://cloud.githubusercontent.com/assets/39191/13622719/7cc7c54c-e555-11e5-86c4-7045d91af041.png\" alt=\"diff\"></p>\n<p><strong>② 美化 log</strong><br>git log 打出来的日志结构是完全扁平的，信息也不够全，依然是很难一眼找到自己想要的信息<br>依然是在 <code>~/.gitconfig</code> 中编辑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[alias]</div><div class=\"line\">lg = log --graph --abbrev-commit --decorate --format=format:&apos;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset)     %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&apos; --all</div></pre></td></tr></table></figure></p>\n<p>这样信息清晰好看了很多，也可以看到每个提交所在的分支及其分化衍合的情况<br>(git log VS git lg)</p>\n<p><img src=\"http://o7ts2uaks.bkt.clouddn.com/6E897688-D526-4DC5-A373-05FB41734A91.png\" alt=\"log\"><br><img src=\"http://o7ts2uaks.bkt.clouddn.com/84B43431-AB74-446F-8442-3DFCD8E8E8BE.png\" alt=\"lg\"></p>\n<p><strong>③ 命令加强 <a href=\"https://github.com/tj/git-extras\">git-extras</a></strong><br>TJ出品的 git 命令扩展集，应有尽有，要啥有啥，按需取用</p>\n<h2 id=\"3-终端复用神器-Tmux\"><a href=\"#3-终端复用神器-Tmux\" class=\"headerlink\" title=\"3.终端复用神器 Tmux\"></a>3.终端复用神器 Tmux</h2><p>Tmux 是 Linux 中一种管理窗口的程序，用 Tmux 的主要原因是它提供了一个窗体组随时存储和恢复的功能。<br>现在我们经常在开发时给一个项目起很多 server，webpack server 占一个 tab，mock server 占一个 tab，开的时候开半天，哪个断了还要挨个找。<br>或者，在用 SSH 登录远程服务器进行调试时，开了N多窗口，过了一会儿发现 <code>Broken Pipe</code> 管子裂了，又得重来。<br>Tmux 可以帮助我们 split 窗口以及进行终端复用保证工作现场不丢失。<br><a href=\"http://cenalulu.github.io/linux/tmux/\">使用与安装方法</a></p>\n<h2 id=\"4-给命令行使用的代理工具-proxychains-ng\"><a href=\"#4-给命令行使用的代理工具-proxychains-ng\" class=\"headerlink\" title=\"4.给命令行使用的代理工具 proxychains-ng\"></a>4.给命令行使用的代理工具 <a href=\"https://github.com/rofl0r/proxychains-ng\">proxychains-ng</a></h2><p>用公司的 mnpm 镜像其实就基本不需要这个了。<br>自己搭服务器或者在家里办公有需求的话可以用。</p>\n<h2 id=\"5-commit-message-规范工具-commitizen\"><a href=\"#5-commit-message-规范工具-commitizen\" class=\"headerlink\" title=\"5. commit message 规范工具 commitizen\"></a>5. commit message 规范工具 <a href=\"https://github.com/commitizen/cz-cli\">commitizen</a></h2><p>制定 Code Review 规范时看到了 <a href=\"https://eggjs.org/zh-cn/contributing.html\">Egg.js 的代码贡献规范</a><br>其中总结了一条好的，有意义的 commit message 应该包含：</p>\n<blockquote>\n<p>① type: 本次 commit 的类型(feat/fix/stype/perf….)<br>② scope: 改动范围<br>③ subject: 简要概述本次提交做了什么<br>④ body: 补充 subject, 可以不写<br>⑤ footer: 本次提交关联的 issue, task</p>\n</blockquote>\n<p>手动按这个写还挺累挺难的，因此决定在团队中推行使用 commitizen<br>简单好用，立竿见影<br><img src=\"https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png\" alt=\"commitizen\"></p>\n<h2 id=\"6-好玩的-thefuck\"><a href=\"#6-好玩的-thefuck\" class=\"headerlink\" title=\"6.好玩的 thefuck\"></a>6.好玩的 <a href=\"https://github.com/nvbn/thefuck\">thefuck</a></h2><p><img src=\"https://raw.githubusercontent.com/nvbn/thefuck/master/example.gif\" alt=\"thefuck\"></p>\n<p>一个好玩的小工具，给开发添点乐趣。</p>"},{"layout":"post","title":"《Pragmatic Programmer》","date":"2017-09-15T15:32:00.000Z","_content":"\n![cover](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&fm=27&gp=0.jpg)\n\n[豆瓣地址](https://book.douban.com/subject/5387402/)\n这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。\n定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）\n<!--more-->\n\n### 一、工程意识\n① `Don't Live with Broken Windows: 不要容忍破窗户`\n这其实就是所说的“破窗理论”，破窗户（低劣的设计，糟糕的代码，临时凑合出的可以 work 的奇怪 hack function）具有传染性，只会导致项目中破窗户越来越多，一堆临时的 hack 修补引起连环问题，直到难以修复，程序崩溃。\n熵增定律告诉我们，一个封闭系统总是趋向于熵增，也就是系统的无序程度只会不断增加。软件开发中也是如此，不要容忍破窗户，尽快修复任何已察觉到的问题。\n\n② `DRY - Don't Repeat Yourself 不要重复你自己`\n   `Make It Easy to Reuse 让复用变得容易`\n   `There Are No Final Decisions 不存在最终决策`\n也是非常有名的 `DRY` 原则，与在《重构》与《设计模式》中学习到的类似，应使得我们的程序更\n介绍了几种可能出现重复的场景，应使得程序具有正交性，不仅出于好维护的目的，也为了避免由于需求变更而扩展性不够导致需要重写。（从这里看来软件开发的常见问题这么多年都没啥变化）\n要警惕自己出于懒惰而做的 Copy&Paste，它不仅对项目没什么好处，也是一种“恶劣习惯”的开始。\n维持代码正交性的方法（其实也是重构原则）：\n- 让你的代码保持解耦：`Law of Demeter`\n- 避免使用全局数据\n- 避免编写相似的函数：可以通过策略模式实现\n\n③ `Estimate to Avoid Superises: 估算，以避免发生意外`\n   `Iterate the Schedule with the Code: 通过代码对进度表进行迭代`\n书中提到“使用的时间单位会对结果的解读造成影响”，并由此提到了相应的建议估算单位，这个还是很有意思的:\n![estimate](https://file.sankuai.com/pan/im/1/image/AQhd2cqjdxpb_PAKXwAAElX88ApY@640w_1l?t=b&w=640&h=222)\n\n这只算一些估算经验，真正想进行准确有效的估算，还是要不断复盘检测，建立自己的系统模型，组织开发中所用的步骤，进行合理的模块划分来估算项目进度。\n\n④ `Keep Knowledge in Plain Text: 用纯文本保存知识`\n   `Configure, Don't Integrate: 要配置，不要集成`\n   `Put Abstractions in Code, Details in Metdata: 将抽象放进代码，细节放进元数据`\n这里提到了使耦合减少至最少的一个方法，使用 `Metadata` 元数据，让我们的系统变得高度可配置。元数据是关于数据的数据，比如说数据库 `schema`，对字段进行描述。\n通过以声明方式思考，由元数据驱动的应用将迫使我们解除设计耦合，推迟细节处理并大大提到了可复用性，能快速响应由需求变更导致的改动。\n\n⑤ `Don't Program by Coincidence 不要靠巧合编程`\n这是一个很简单也显而易见的事，然而还是会经常出现“好不容易跑起来了，哪都不要动，先这样吧”。不仅如此，很多时候也是会不经意地忽略这件事，需要警惕，此时能实现很可能是由于正处于边界条件，只是偶然。\n因此不仅要用 case 测试我们的代码，还要对测试 case 进行深思，通过一些覆盖不全、偶然情况的 case 并不意味着代码是 OK 的。\n\n### 二、开始实际的开发\n① `Estimate the Order of Your Algorithms 算法速率`\n书中也简单介绍了 `大O表示法` 与一些常见算法的复杂度。在这里要牢记，要根据实际情况做出选择，过度追求算法上的优化而增加了测试维护的成本得不偿失。\n\n② `Don't Gather Requirement - Dig for Them 不要搜集需求——挖掘它们`\n`Abstractions Live Longer than Details 抽象比细节活得更长久`\n要对需求敏感，不假思索完全按照 PM 提过来的需求描述进行开发，可能会导致项目中的代码扩展性不好。举个例子，“只有人事部门可以查看档案”与“只有指定人员才能查看员工档案”这就是两个不一样的概念。完全按照前者来开发，很有可能只是将人事部门的组织id写入代码，而后者意味着我们可能需要做一个权限服务而与业务逻辑分离。\n\n因此，应该 **把政策的文档与需求的文档分开，使需求称为一般陈述，并把政策信息作为例子发给开发者，作为在具体视线中需要支持的一个 Case，最后政策可以称为应用中的元数据**。\n\n找出用户为何要做特定事情的`起因`，而不只是他们目前做这件事的`方式`。因为作为开发者是要解决用户的商业问题，而不只是满足用户陈述的需求，解决需求的方式是很有可能发生变化的，而深入挖掘到要解决的根本问题，才是可以使得系统高效，开发人员也不必为需求疲于奔命的解决方式。\n\n在编写我们开发人员自己使用、查阅的需求文档时，应注重`保持抽象`，在涉及需求的地方，最简单的，能够准确地反映商业需要的陈述才是最好的，必须把`底层的语义不变项`当做需求进行捕捉。如上个例子，控制可以查看档案的权限，即是语义不变项。\n\n③ `Listen to Nagging Doubts -Start When You're Ready 等你准备好再开始`\n这里讨论了“启动恐惧症”，这件事我也经常遇到，但是并没有反思在什么情况下会出现启动恐惧症，每次都是拖延许久最后在无限抵触和焦虑中把项目赶完了。\n\n书中提出应该注意到自己的疑虑，在长时间的积累后，我们的直觉也会很有用处。除此之外，如果我们发现这种疑虑只是出于拖延的话，应该 **选择一个你觉得会有困难的地方，开始进行某种“概念验证”**，这样可以有效快速地使启动起来了，因为行动结果无非有两种，一种是我们发现，这个困难可以解决然后就可以消除疑虑正式投入开发，另一种我们发现这个地方确实有问题，然后通过求助外界或者更改需求来推进它，总之项目是有了一个不小的进展。\n\n上述只是记了一些我在阅读中感触比较多的地方，实际上这本书虽然是一个蛮远久的“名著”，其中概念都很经典并不过时，书中每页都有启示。还是希望我在实习期就有机会看到这本书的，现在开始也并不晚，并且应该多回顾，随着开发经验的增多应该收获也会越来越多。\n\n\n","source":"_posts/reading-pragmatic-programmer.md","raw":"---\nlayout: post\ntitle:  \"《Pragmatic Programmer》\"\ndate:   2017-09-15 23:32\ncategories: programmer reading\n---\n\n![cover](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&fm=27&gp=0.jpg)\n\n[豆瓣地址](https://book.douban.com/subject/5387402/)\n这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。\n定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）\n<!--more-->\n\n### 一、工程意识\n① `Don't Live with Broken Windows: 不要容忍破窗户`\n这其实就是所说的“破窗理论”，破窗户（低劣的设计，糟糕的代码，临时凑合出的可以 work 的奇怪 hack function）具有传染性，只会导致项目中破窗户越来越多，一堆临时的 hack 修补引起连环问题，直到难以修复，程序崩溃。\n熵增定律告诉我们，一个封闭系统总是趋向于熵增，也就是系统的无序程度只会不断增加。软件开发中也是如此，不要容忍破窗户，尽快修复任何已察觉到的问题。\n\n② `DRY - Don't Repeat Yourself 不要重复你自己`\n   `Make It Easy to Reuse 让复用变得容易`\n   `There Are No Final Decisions 不存在最终决策`\n也是非常有名的 `DRY` 原则，与在《重构》与《设计模式》中学习到的类似，应使得我们的程序更\n介绍了几种可能出现重复的场景，应使得程序具有正交性，不仅出于好维护的目的，也为了避免由于需求变更而扩展性不够导致需要重写。（从这里看来软件开发的常见问题这么多年都没啥变化）\n要警惕自己出于懒惰而做的 Copy&Paste，它不仅对项目没什么好处，也是一种“恶劣习惯”的开始。\n维持代码正交性的方法（其实也是重构原则）：\n- 让你的代码保持解耦：`Law of Demeter`\n- 避免使用全局数据\n- 避免编写相似的函数：可以通过策略模式实现\n\n③ `Estimate to Avoid Superises: 估算，以避免发生意外`\n   `Iterate the Schedule with the Code: 通过代码对进度表进行迭代`\n书中提到“使用的时间单位会对结果的解读造成影响”，并由此提到了相应的建议估算单位，这个还是很有意思的:\n![estimate](https://file.sankuai.com/pan/im/1/image/AQhd2cqjdxpb_PAKXwAAElX88ApY@640w_1l?t=b&w=640&h=222)\n\n这只算一些估算经验，真正想进行准确有效的估算，还是要不断复盘检测，建立自己的系统模型，组织开发中所用的步骤，进行合理的模块划分来估算项目进度。\n\n④ `Keep Knowledge in Plain Text: 用纯文本保存知识`\n   `Configure, Don't Integrate: 要配置，不要集成`\n   `Put Abstractions in Code, Details in Metdata: 将抽象放进代码，细节放进元数据`\n这里提到了使耦合减少至最少的一个方法，使用 `Metadata` 元数据，让我们的系统变得高度可配置。元数据是关于数据的数据，比如说数据库 `schema`，对字段进行描述。\n通过以声明方式思考，由元数据驱动的应用将迫使我们解除设计耦合，推迟细节处理并大大提到了可复用性，能快速响应由需求变更导致的改动。\n\n⑤ `Don't Program by Coincidence 不要靠巧合编程`\n这是一个很简单也显而易见的事，然而还是会经常出现“好不容易跑起来了，哪都不要动，先这样吧”。不仅如此，很多时候也是会不经意地忽略这件事，需要警惕，此时能实现很可能是由于正处于边界条件，只是偶然。\n因此不仅要用 case 测试我们的代码，还要对测试 case 进行深思，通过一些覆盖不全、偶然情况的 case 并不意味着代码是 OK 的。\n\n### 二、开始实际的开发\n① `Estimate the Order of Your Algorithms 算法速率`\n书中也简单介绍了 `大O表示法` 与一些常见算法的复杂度。在这里要牢记，要根据实际情况做出选择，过度追求算法上的优化而增加了测试维护的成本得不偿失。\n\n② `Don't Gather Requirement - Dig for Them 不要搜集需求——挖掘它们`\n`Abstractions Live Longer than Details 抽象比细节活得更长久`\n要对需求敏感，不假思索完全按照 PM 提过来的需求描述进行开发，可能会导致项目中的代码扩展性不好。举个例子，“只有人事部门可以查看档案”与“只有指定人员才能查看员工档案”这就是两个不一样的概念。完全按照前者来开发，很有可能只是将人事部门的组织id写入代码，而后者意味着我们可能需要做一个权限服务而与业务逻辑分离。\n\n因此，应该 **把政策的文档与需求的文档分开，使需求称为一般陈述，并把政策信息作为例子发给开发者，作为在具体视线中需要支持的一个 Case，最后政策可以称为应用中的元数据**。\n\n找出用户为何要做特定事情的`起因`，而不只是他们目前做这件事的`方式`。因为作为开发者是要解决用户的商业问题，而不只是满足用户陈述的需求，解决需求的方式是很有可能发生变化的，而深入挖掘到要解决的根本问题，才是可以使得系统高效，开发人员也不必为需求疲于奔命的解决方式。\n\n在编写我们开发人员自己使用、查阅的需求文档时，应注重`保持抽象`，在涉及需求的地方，最简单的，能够准确地反映商业需要的陈述才是最好的，必须把`底层的语义不变项`当做需求进行捕捉。如上个例子，控制可以查看档案的权限，即是语义不变项。\n\n③ `Listen to Nagging Doubts -Start When You're Ready 等你准备好再开始`\n这里讨论了“启动恐惧症”，这件事我也经常遇到，但是并没有反思在什么情况下会出现启动恐惧症，每次都是拖延许久最后在无限抵触和焦虑中把项目赶完了。\n\n书中提出应该注意到自己的疑虑，在长时间的积累后，我们的直觉也会很有用处。除此之外，如果我们发现这种疑虑只是出于拖延的话，应该 **选择一个你觉得会有困难的地方，开始进行某种“概念验证”**，这样可以有效快速地使启动起来了，因为行动结果无非有两种，一种是我们发现，这个困难可以解决然后就可以消除疑虑正式投入开发，另一种我们发现这个地方确实有问题，然后通过求助外界或者更改需求来推进它，总之项目是有了一个不小的进展。\n\n上述只是记了一些我在阅读中感触比较多的地方，实际上这本书虽然是一个蛮远久的“名著”，其中概念都很经典并不过时，书中每页都有启示。还是希望我在实习期就有机会看到这本书的，现在开始也并不晚，并且应该多回顾，随着开发经验的增多应该收获也会越来越多。\n\n\n","slug":"reading-pragmatic-programmer","published":1,"updated":"2017-11-19T04:21:06.000Z","_id":"cja54xyk90019gbehaoex7omj","comments":1,"photos":[],"link":"","content":"<p><img src=\"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&amp;fm=27&amp;gp=0.jpg\" alt=\"cover\"></p>\n<p><a href=\"https://book.douban.com/subject/5387402/\" target=\"_blank\" rel=\"external\">豆瓣地址</a><br>这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。<br>定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）<br><a id=\"more\"></a></p>\n<h3 id=\"一、工程意识\"><a href=\"#一、工程意识\" class=\"headerlink\" title=\"一、工程意识\"></a>一、工程意识</h3><p>① <code>Don&#39;t Live with Broken Windows: 不要容忍破窗户</code><br>这其实就是所说的“破窗理论”，破窗户（低劣的设计，糟糕的代码，临时凑合出的可以 work 的奇怪 hack function）具有传染性，只会导致项目中破窗户越来越多，一堆临时的 hack 修补引起连环问题，直到难以修复，程序崩溃。<br>熵增定律告诉我们，一个封闭系统总是趋向于熵增，也就是系统的无序程度只会不断增加。软件开发中也是如此，不要容忍破窗户，尽快修复任何已察觉到的问题。</p>\n<p>② <code>DRY - Don&#39;t Repeat Yourself 不要重复你自己</code><br>   <code>Make It Easy to Reuse 让复用变得容易</code><br>   <code>There Are No Final Decisions 不存在最终决策</code><br>也是非常有名的 <code>DRY</code> 原则，与在《重构》与《设计模式》中学习到的类似，应使得我们的程序更<br>介绍了几种可能出现重复的场景，应使得程序具有正交性，不仅出于好维护的目的，也为了避免由于需求变更而扩展性不够导致需要重写。（从这里看来软件开发的常见问题这么多年都没啥变化）<br>要警惕自己出于懒惰而做的 Copy&amp;Paste，它不仅对项目没什么好处，也是一种“恶劣习惯”的开始。<br>维持代码正交性的方法（其实也是重构原则）：</p>\n<ul>\n<li>让你的代码保持解耦：<code>Law of Demeter</code></li>\n<li>避免使用全局数据</li>\n<li>避免编写相似的函数：可以通过策略模式实现</li>\n</ul>\n<p>③ <code>Estimate to Avoid Superises: 估算，以避免发生意外</code><br>   <code>Iterate the Schedule with the Code: 通过代码对进度表进行迭代</code><br>书中提到“使用的时间单位会对结果的解读造成影响”，并由此提到了相应的建议估算单位，这个还是很有意思的:<br><img src=\"https://file.sankuai.com/pan/im/1/image/AQhd2cqjdxpb_PAKXwAAElX88ApY@640w_1l?t=b&amp;w=640&amp;h=222\" alt=\"estimate\"></p>\n<p>这只算一些估算经验，真正想进行准确有效的估算，还是要不断复盘检测，建立自己的系统模型，组织开发中所用的步骤，进行合理的模块划分来估算项目进度。</p>\n<p>④ <code>Keep Knowledge in Plain Text: 用纯文本保存知识</code><br>   <code>Configure, Don&#39;t Integrate: 要配置，不要集成</code><br>   <code>Put Abstractions in Code, Details in Metdata: 将抽象放进代码，细节放进元数据</code><br>这里提到了使耦合减少至最少的一个方法，使用 <code>Metadata</code> 元数据，让我们的系统变得高度可配置。元数据是关于数据的数据，比如说数据库 <code>schema</code>，对字段进行描述。<br>通过以声明方式思考，由元数据驱动的应用将迫使我们解除设计耦合，推迟细节处理并大大提到了可复用性，能快速响应由需求变更导致的改动。</p>\n<p>⑤ <code>Don&#39;t Program by Coincidence 不要靠巧合编程</code><br>这是一个很简单也显而易见的事，然而还是会经常出现“好不容易跑起来了，哪都不要动，先这样吧”。不仅如此，很多时候也是会不经意地忽略这件事，需要警惕，此时能实现很可能是由于正处于边界条件，只是偶然。<br>因此不仅要用 case 测试我们的代码，还要对测试 case 进行深思，通过一些覆盖不全、偶然情况的 case 并不意味着代码是 OK 的。</p>\n<h3 id=\"二、开始实际的开发\"><a href=\"#二、开始实际的开发\" class=\"headerlink\" title=\"二、开始实际的开发\"></a>二、开始实际的开发</h3><p>① <code>Estimate the Order of Your Algorithms 算法速率</code><br>书中也简单介绍了 <code>大O表示法</code> 与一些常见算法的复杂度。在这里要牢记，要根据实际情况做出选择，过度追求算法上的优化而增加了测试维护的成本得不偿失。</p>\n<p>② <code>Don&#39;t Gather Requirement - Dig for Them 不要搜集需求——挖掘它们</code><br><code>Abstractions Live Longer than Details 抽象比细节活得更长久</code><br>要对需求敏感，不假思索完全按照 PM 提过来的需求描述进行开发，可能会导致项目中的代码扩展性不好。举个例子，“只有人事部门可以查看档案”与“只有指定人员才能查看员工档案”这就是两个不一样的概念。完全按照前者来开发，很有可能只是将人事部门的组织id写入代码，而后者意味着我们可能需要做一个权限服务而与业务逻辑分离。</p>\n<p>因此，应该 <strong>把政策的文档与需求的文档分开，使需求称为一般陈述，并把政策信息作为例子发给开发者，作为在具体视线中需要支持的一个 Case，最后政策可以称为应用中的元数据</strong>。</p>\n<p>找出用户为何要做特定事情的<code>起因</code>，而不只是他们目前做这件事的<code>方式</code>。因为作为开发者是要解决用户的商业问题，而不只是满足用户陈述的需求，解决需求的方式是很有可能发生变化的，而深入挖掘到要解决的根本问题，才是可以使得系统高效，开发人员也不必为需求疲于奔命的解决方式。</p>\n<p>在编写我们开发人员自己使用、查阅的需求文档时，应注重<code>保持抽象</code>，在涉及需求的地方，最简单的，能够准确地反映商业需要的陈述才是最好的，必须把<code>底层的语义不变项</code>当做需求进行捕捉。如上个例子，控制可以查看档案的权限，即是语义不变项。</p>\n<p>③ <code>Listen to Nagging Doubts -Start When You&#39;re Ready 等你准备好再开始</code><br>这里讨论了“启动恐惧症”，这件事我也经常遇到，但是并没有反思在什么情况下会出现启动恐惧症，每次都是拖延许久最后在无限抵触和焦虑中把项目赶完了。</p>\n<p>书中提出应该注意到自己的疑虑，在长时间的积累后，我们的直觉也会很有用处。除此之外，如果我们发现这种疑虑只是出于拖延的话，应该 <strong>选择一个你觉得会有困难的地方，开始进行某种“概念验证”</strong>，这样可以有效快速地使启动起来了，因为行动结果无非有两种，一种是我们发现，这个困难可以解决然后就可以消除疑虑正式投入开发，另一种我们发现这个地方确实有问题，然后通过求助外界或者更改需求来推进它，总之项目是有了一个不小的进展。</p>\n<p>上述只是记了一些我在阅读中感触比较多的地方，实际上这本书虽然是一个蛮远久的“名著”，其中概念都很经典并不过时，书中每页都有启示。还是希望我在实习期就有机会看到这本书的，现在开始也并不晚，并且应该多回顾，随着开发经验的增多应该收获也会越来越多。</p>\n","excerpt":"<p><img src=\"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&amp;fm=27&amp;gp=0.jpg\" alt=\"cover\"></p>\n<p><a href=\"https://book.douban.com/subject/5387402/\">豆瓣地址</a><br>这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。<br>定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）<br>","more":"</p>\n<h3 id=\"一、工程意识\"><a href=\"#一、工程意识\" class=\"headerlink\" title=\"一、工程意识\"></a>一、工程意识</h3><p>① <code>Don&#39;t Live with Broken Windows: 不要容忍破窗户</code><br>这其实就是所说的“破窗理论”，破窗户（低劣的设计，糟糕的代码，临时凑合出的可以 work 的奇怪 hack function）具有传染性，只会导致项目中破窗户越来越多，一堆临时的 hack 修补引起连环问题，直到难以修复，程序崩溃。<br>熵增定律告诉我们，一个封闭系统总是趋向于熵增，也就是系统的无序程度只会不断增加。软件开发中也是如此，不要容忍破窗户，尽快修复任何已察觉到的问题。</p>\n<p>② <code>DRY - Don&#39;t Repeat Yourself 不要重复你自己</code><br>   <code>Make It Easy to Reuse 让复用变得容易</code><br>   <code>There Are No Final Decisions 不存在最终决策</code><br>也是非常有名的 <code>DRY</code> 原则，与在《重构》与《设计模式》中学习到的类似，应使得我们的程序更<br>介绍了几种可能出现重复的场景，应使得程序具有正交性，不仅出于好维护的目的，也为了避免由于需求变更而扩展性不够导致需要重写。（从这里看来软件开发的常见问题这么多年都没啥变化）<br>要警惕自己出于懒惰而做的 Copy&amp;Paste，它不仅对项目没什么好处，也是一种“恶劣习惯”的开始。<br>维持代码正交性的方法（其实也是重构原则）：</p>\n<ul>\n<li>让你的代码保持解耦：<code>Law of Demeter</code></li>\n<li>避免使用全局数据</li>\n<li>避免编写相似的函数：可以通过策略模式实现</li>\n</ul>\n<p>③ <code>Estimate to Avoid Superises: 估算，以避免发生意外</code><br>   <code>Iterate the Schedule with the Code: 通过代码对进度表进行迭代</code><br>书中提到“使用的时间单位会对结果的解读造成影响”，并由此提到了相应的建议估算单位，这个还是很有意思的:<br><img src=\"https://file.sankuai.com/pan/im/1/image/AQhd2cqjdxpb_PAKXwAAElX88ApY@640w_1l?t=b&amp;w=640&amp;h=222\" alt=\"estimate\"></p>\n<p>这只算一些估算经验，真正想进行准确有效的估算，还是要不断复盘检测，建立自己的系统模型，组织开发中所用的步骤，进行合理的模块划分来估算项目进度。</p>\n<p>④ <code>Keep Knowledge in Plain Text: 用纯文本保存知识</code><br>   <code>Configure, Don&#39;t Integrate: 要配置，不要集成</code><br>   <code>Put Abstractions in Code, Details in Metdata: 将抽象放进代码，细节放进元数据</code><br>这里提到了使耦合减少至最少的一个方法，使用 <code>Metadata</code> 元数据，让我们的系统变得高度可配置。元数据是关于数据的数据，比如说数据库 <code>schema</code>，对字段进行描述。<br>通过以声明方式思考，由元数据驱动的应用将迫使我们解除设计耦合，推迟细节处理并大大提到了可复用性，能快速响应由需求变更导致的改动。</p>\n<p>⑤ <code>Don&#39;t Program by Coincidence 不要靠巧合编程</code><br>这是一个很简单也显而易见的事，然而还是会经常出现“好不容易跑起来了，哪都不要动，先这样吧”。不仅如此，很多时候也是会不经意地忽略这件事，需要警惕，此时能实现很可能是由于正处于边界条件，只是偶然。<br>因此不仅要用 case 测试我们的代码，还要对测试 case 进行深思，通过一些覆盖不全、偶然情况的 case 并不意味着代码是 OK 的。</p>\n<h3 id=\"二、开始实际的开发\"><a href=\"#二、开始实际的开发\" class=\"headerlink\" title=\"二、开始实际的开发\"></a>二、开始实际的开发</h3><p>① <code>Estimate the Order of Your Algorithms 算法速率</code><br>书中也简单介绍了 <code>大O表示法</code> 与一些常见算法的复杂度。在这里要牢记，要根据实际情况做出选择，过度追求算法上的优化而增加了测试维护的成本得不偿失。</p>\n<p>② <code>Don&#39;t Gather Requirement - Dig for Them 不要搜集需求——挖掘它们</code><br><code>Abstractions Live Longer than Details 抽象比细节活得更长久</code><br>要对需求敏感，不假思索完全按照 PM 提过来的需求描述进行开发，可能会导致项目中的代码扩展性不好。举个例子，“只有人事部门可以查看档案”与“只有指定人员才能查看员工档案”这就是两个不一样的概念。完全按照前者来开发，很有可能只是将人事部门的组织id写入代码，而后者意味着我们可能需要做一个权限服务而与业务逻辑分离。</p>\n<p>因此，应该 <strong>把政策的文档与需求的文档分开，使需求称为一般陈述，并把政策信息作为例子发给开发者，作为在具体视线中需要支持的一个 Case，最后政策可以称为应用中的元数据</strong>。</p>\n<p>找出用户为何要做特定事情的<code>起因</code>，而不只是他们目前做这件事的<code>方式</code>。因为作为开发者是要解决用户的商业问题，而不只是满足用户陈述的需求，解决需求的方式是很有可能发生变化的，而深入挖掘到要解决的根本问题，才是可以使得系统高效，开发人员也不必为需求疲于奔命的解决方式。</p>\n<p>在编写我们开发人员自己使用、查阅的需求文档时，应注重<code>保持抽象</code>，在涉及需求的地方，最简单的，能够准确地反映商业需要的陈述才是最好的，必须把<code>底层的语义不变项</code>当做需求进行捕捉。如上个例子，控制可以查看档案的权限，即是语义不变项。</p>\n<p>③ <code>Listen to Nagging Doubts -Start When You&#39;re Ready 等你准备好再开始</code><br>这里讨论了“启动恐惧症”，这件事我也经常遇到，但是并没有反思在什么情况下会出现启动恐惧症，每次都是拖延许久最后在无限抵触和焦虑中把项目赶完了。</p>\n<p>书中提出应该注意到自己的疑虑，在长时间的积累后，我们的直觉也会很有用处。除此之外，如果我们发现这种疑虑只是出于拖延的话，应该 <strong>选择一个你觉得会有困难的地方，开始进行某种“概念验证”</strong>，这样可以有效快速地使启动起来了，因为行动结果无非有两种，一种是我们发现，这个困难可以解决然后就可以消除疑虑正式投入开发，另一种我们发现这个地方确实有问题，然后通过求助外界或者更改需求来推进它，总之项目是有了一个不小的进展。</p>\n<p>上述只是记了一些我在阅读中感触比较多的地方，实际上这本书虽然是一个蛮远久的“名著”，其中概念都很经典并不过时，书中每页都有启示。还是希望我在实习期就有机会看到这本书的，现在开始也并不晚，并且应该多回顾，随着开发经验的增多应该收获也会越来越多。</p>"},{"layout":"post","title":"观察者模式以及在 Vue 源码中的实践","date":"2017-03-14T10:30:00.000Z","_content":"\n![vue](/images/vue-reactive.jpg)\n\n在 ES6 把 Promise 写进语言标准前，为实现异步编程，经常会采用 **观察者模式（发布-订阅模式）** 作为替代传递回调函数的方案。\n\n它定义了一种一对多的关系，让多个观察者订阅同一主题对象，当主题状态发生改变则立即发布，通知所有的订阅者。发布者和订阅者之间完全解耦，仅仅是共享同一自定义事件的名称。当新的订阅者出现，发布者无需做任何修改，反之亦然。\n\n<!--more-->\n\n## 常见的需要观察者模式的场景：\n\n在任意一个需要登录的网站中，header，navbar，消息列表，购物车等模块的渲染，都需要登陆后拿到用户信息。但是ajax登录请求完成的时间无法确定，如果在ajax回调中调用各模块的方法来更新用户信息的话，耦合性太强，新增/修改模块的成本太高，业务模块更复杂的时候很难维护。这个时候需要的就是观察者模式。\n\nVue 在实现数据绑定时也采用的观察者模式来实现数据的订阅，订阅者维护每一次更新之前的数据，当数据发生变化，订阅者将执行自身设定的回调逻辑，并更新所维护数据的值。\n\n## 实现观察者模式：\n\n>1. 指定发布者\n>2. 给发布者添加一个缓存列表，用于存放回调函数以通知订阅者\n>3. 发布消息时，遍历缓存列表，触发每一个订阅者回调函数\n\n并且除了缓存列表之外，还需要订阅，发布，取消订阅这三个方法。\n\n```javascript\nvar event = {\n  // 缓存列表\n  clientList: [],\n  // 订阅\n  listen: function(key, fn){\n    if (!this.clientList[key]) {\n      // 订阅列表中没有这个 key 则把初始化这个 key 的队列为空\n      this.clientList[key] = []\n    }\n    this.clientList[key].push(fn)\n  },\n\n  trigger: function () {\n    var key = Array.prototype.shift.call(arguments)\n    var fns = this.clientList[key]\n    if (!fns || fns.length === 0) return false\n    // 遍历缓存列表，挨个触发回调\n    for (var i = 0, fn; fn = fns[ i++ ];){\n      fn.apply(this, arguments)\n    }\n  },\n\n  remove: function (key, fn) {\n    var fns = this.clientList[key]\n    if (!fns){\n      return false;\n    }\n    if (!fn){\n      fns && (fns.length = 0)\n    } else {\n      for (var l = fns.length - 1; l >=0; l--){\n        var _fn = fns[l]\n        if (_fn === fn){\n          fns.splice(l, 1)\n        }\n      }\n    }\n  }\n}\n```\n这就是观察者模式的一个通用实现。\n\n在实际场景中，有可能需要多个发布者对象，需要多个类似上面 event 对象的绑定，非常麻烦，发布订阅也并没有完全解耦，需要知道这个对象的名字。因此也可以采用 **全局的 Event 对象** 来实现。\n同时，也有可能为了避免命名冲突，需要 **创建命名空间** ，或者是由于为了实现可以先发布再订阅，**创建离线堆栈** 等等，可定制高级版的观察者模式。\n\n## 采用观察者模式需要注意的问题：\n\n- 实现观察者模式本身需要耗费内存，如果发布并不常发生，而订阅却始终存在于内存中，造成了一定程度的浪费\n- 由于模块之间的联系由具体的耦合转为抽象，因此过多使用观察者模式的话，模块关系很难追溯，代码也很难维护\n\n## Vue源码中的使用：\nVue 实现数据绑定依靠的是 **Object.defineProperty() 的自定义getter/setter** 来进行的。\n\n```javascript\n// 管理，通知订阅者\n// 定义缓存列表，为外部提供 添加订阅/通知订阅者 的接口\nexport default class Dep{\n    constructor(){\n        // 缓存列表\n        this.subs = []\n    }\n    addSub(sub){\n        // 添加订阅，即向缓存列表中添加新项\n        this.subs.push(sub)\n    }\n    notify(){\n        // 通知所有的订阅者(Watcher)，触发订阅者的相应回调\n        this.subs.forEach((sub) => sub.update())\n    }\n}\n```\n\n```javascript\n// 引入订阅管理模块\nimport Dep from 'Dep'\n// 定义订阅\nexport default class Watcher{\n    // 接受三个参数，实例，所订阅数据，指定的回调\n    constructor(vm, expOrFn, cb){\n        this.vm = vm // 取到 Vue 实例，从而拿到实例上的 data\n        this.cb = cb // 数据更新时触发的回调函数\n        this.expOrFn = expOrFn // 被订阅的数据\n        this.val = this.get() // 赋值为定义订阅时的数据，即更新前的值\n    }\n    // 对外暴露的接口，数据更新时发布者将调用这个接口\n    update(){\n        this.run()\n    }\n    run(){\n        // 订阅数据发生变化时，更新 val ，触发回调\n        // val 为当前值， this.val 为更新前的值\n        const val = this.get()\n        if(val !== this.val){\n            this.val = val;\n            this.cb.call(this.vm)\n        }\n    }\n    get(){\n        // 读取所订阅数据的最新值\n        Dep.target = this\n        const val = this.vm._data[this.expOrFn]\n        // 指针置空\n        Dep.target = null\n        return val;\n    }\n}\n```\n\n```javascript\n// 定义 Observer 数据监听器\n// 引入 Dep 订阅管理模块\nimport Dep from 'Dep'\n// 定义 Observer 类，将所监听数据遍历每一项传入到 defineReactive 以加入 get/set 方法\nexport default class Observer{\n    constructor(value){\n        this.value = value\n        this.walk(value)\n    }\n    walk(value){\n        // 遍历所监听对象、数组的每一项\n        Object.keys(value).forEach(key => this.convert(key, value[key]))\n    }\n    convert(key, val){\n        defineReactive(this.value, key, val)\n    }\n}\nexport function defineReactive(obj, key, val){\n    // 创建新的订阅\n    var dep = new Dep()\n    // 给当前属性的值添加监听\n    var chlidOb = observe(val)\n    // 加上 get/set\n    Object.defineProperty(obj, key, {\n        // 设置为属性可遍历\n        enumerable: true,\n        // 属性可删除，可修改其 emumerable/writable 等属性\n        configurable: true,\n        get: ()=> {\n            console.log('get value')\n            // Dep.target 为 watcher 实例\n            // 如果存在这个 watcher 则将其加入到 sub 队列\n            // Watcher实例在实例化过程中，会触发当前get方法\n            if(Dep.target){\n                dep.addSub(Dep.target)\n            }\n            return val\n        },\n        set: (newVal) => {\n            // 如果数据被修改则会触发这段 set 函数\n            console.log('new value seted')\n            if(val === newVal) return\n            val = newVal\n            // 监听新值\n            chlidOb = observe(newVal)\n            // 通知所有订阅者，数值被改变了\n            dep.notify()\n        }\n    })\n}\n// 创建监听，在调用Observer类的外面加了层判断\nexport function observe(value){\n    // 当值不存在，或者不是对象，就不监听了\n    if(!value || typeof value !== 'object'){\n        return\n    }\n    return new Observer(value)\n}\n```\n\n在有些文章中，观察者模式与发布/订阅模式还有些差别，可以观摩这篇 [ObserverPattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript)去学习一下","source":"_posts/observer-pattern-in-vue.md","raw":"---\nlayout: post\ntitle:  \"观察者模式以及在 Vue 源码中的实践\"\ndate:   2017-03-14 18:30\ncategories: front-end javascript pattern\n---\n\n![vue](/images/vue-reactive.jpg)\n\n在 ES6 把 Promise 写进语言标准前，为实现异步编程，经常会采用 **观察者模式（发布-订阅模式）** 作为替代传递回调函数的方案。\n\n它定义了一种一对多的关系，让多个观察者订阅同一主题对象，当主题状态发生改变则立即发布，通知所有的订阅者。发布者和订阅者之间完全解耦，仅仅是共享同一自定义事件的名称。当新的订阅者出现，发布者无需做任何修改，反之亦然。\n\n<!--more-->\n\n## 常见的需要观察者模式的场景：\n\n在任意一个需要登录的网站中，header，navbar，消息列表，购物车等模块的渲染，都需要登陆后拿到用户信息。但是ajax登录请求完成的时间无法确定，如果在ajax回调中调用各模块的方法来更新用户信息的话，耦合性太强，新增/修改模块的成本太高，业务模块更复杂的时候很难维护。这个时候需要的就是观察者模式。\n\nVue 在实现数据绑定时也采用的观察者模式来实现数据的订阅，订阅者维护每一次更新之前的数据，当数据发生变化，订阅者将执行自身设定的回调逻辑，并更新所维护数据的值。\n\n## 实现观察者模式：\n\n>1. 指定发布者\n>2. 给发布者添加一个缓存列表，用于存放回调函数以通知订阅者\n>3. 发布消息时，遍历缓存列表，触发每一个订阅者回调函数\n\n并且除了缓存列表之外，还需要订阅，发布，取消订阅这三个方法。\n\n```javascript\nvar event = {\n  // 缓存列表\n  clientList: [],\n  // 订阅\n  listen: function(key, fn){\n    if (!this.clientList[key]) {\n      // 订阅列表中没有这个 key 则把初始化这个 key 的队列为空\n      this.clientList[key] = []\n    }\n    this.clientList[key].push(fn)\n  },\n\n  trigger: function () {\n    var key = Array.prototype.shift.call(arguments)\n    var fns = this.clientList[key]\n    if (!fns || fns.length === 0) return false\n    // 遍历缓存列表，挨个触发回调\n    for (var i = 0, fn; fn = fns[ i++ ];){\n      fn.apply(this, arguments)\n    }\n  },\n\n  remove: function (key, fn) {\n    var fns = this.clientList[key]\n    if (!fns){\n      return false;\n    }\n    if (!fn){\n      fns && (fns.length = 0)\n    } else {\n      for (var l = fns.length - 1; l >=0; l--){\n        var _fn = fns[l]\n        if (_fn === fn){\n          fns.splice(l, 1)\n        }\n      }\n    }\n  }\n}\n```\n这就是观察者模式的一个通用实现。\n\n在实际场景中，有可能需要多个发布者对象，需要多个类似上面 event 对象的绑定，非常麻烦，发布订阅也并没有完全解耦，需要知道这个对象的名字。因此也可以采用 **全局的 Event 对象** 来实现。\n同时，也有可能为了避免命名冲突，需要 **创建命名空间** ，或者是由于为了实现可以先发布再订阅，**创建离线堆栈** 等等，可定制高级版的观察者模式。\n\n## 采用观察者模式需要注意的问题：\n\n- 实现观察者模式本身需要耗费内存，如果发布并不常发生，而订阅却始终存在于内存中，造成了一定程度的浪费\n- 由于模块之间的联系由具体的耦合转为抽象，因此过多使用观察者模式的话，模块关系很难追溯，代码也很难维护\n\n## Vue源码中的使用：\nVue 实现数据绑定依靠的是 **Object.defineProperty() 的自定义getter/setter** 来进行的。\n\n```javascript\n// 管理，通知订阅者\n// 定义缓存列表，为外部提供 添加订阅/通知订阅者 的接口\nexport default class Dep{\n    constructor(){\n        // 缓存列表\n        this.subs = []\n    }\n    addSub(sub){\n        // 添加订阅，即向缓存列表中添加新项\n        this.subs.push(sub)\n    }\n    notify(){\n        // 通知所有的订阅者(Watcher)，触发订阅者的相应回调\n        this.subs.forEach((sub) => sub.update())\n    }\n}\n```\n\n```javascript\n// 引入订阅管理模块\nimport Dep from 'Dep'\n// 定义订阅\nexport default class Watcher{\n    // 接受三个参数，实例，所订阅数据，指定的回调\n    constructor(vm, expOrFn, cb){\n        this.vm = vm // 取到 Vue 实例，从而拿到实例上的 data\n        this.cb = cb // 数据更新时触发的回调函数\n        this.expOrFn = expOrFn // 被订阅的数据\n        this.val = this.get() // 赋值为定义订阅时的数据，即更新前的值\n    }\n    // 对外暴露的接口，数据更新时发布者将调用这个接口\n    update(){\n        this.run()\n    }\n    run(){\n        // 订阅数据发生变化时，更新 val ，触发回调\n        // val 为当前值， this.val 为更新前的值\n        const val = this.get()\n        if(val !== this.val){\n            this.val = val;\n            this.cb.call(this.vm)\n        }\n    }\n    get(){\n        // 读取所订阅数据的最新值\n        Dep.target = this\n        const val = this.vm._data[this.expOrFn]\n        // 指针置空\n        Dep.target = null\n        return val;\n    }\n}\n```\n\n```javascript\n// 定义 Observer 数据监听器\n// 引入 Dep 订阅管理模块\nimport Dep from 'Dep'\n// 定义 Observer 类，将所监听数据遍历每一项传入到 defineReactive 以加入 get/set 方法\nexport default class Observer{\n    constructor(value){\n        this.value = value\n        this.walk(value)\n    }\n    walk(value){\n        // 遍历所监听对象、数组的每一项\n        Object.keys(value).forEach(key => this.convert(key, value[key]))\n    }\n    convert(key, val){\n        defineReactive(this.value, key, val)\n    }\n}\nexport function defineReactive(obj, key, val){\n    // 创建新的订阅\n    var dep = new Dep()\n    // 给当前属性的值添加监听\n    var chlidOb = observe(val)\n    // 加上 get/set\n    Object.defineProperty(obj, key, {\n        // 设置为属性可遍历\n        enumerable: true,\n        // 属性可删除，可修改其 emumerable/writable 等属性\n        configurable: true,\n        get: ()=> {\n            console.log('get value')\n            // Dep.target 为 watcher 实例\n            // 如果存在这个 watcher 则将其加入到 sub 队列\n            // Watcher实例在实例化过程中，会触发当前get方法\n            if(Dep.target){\n                dep.addSub(Dep.target)\n            }\n            return val\n        },\n        set: (newVal) => {\n            // 如果数据被修改则会触发这段 set 函数\n            console.log('new value seted')\n            if(val === newVal) return\n            val = newVal\n            // 监听新值\n            chlidOb = observe(newVal)\n            // 通知所有订阅者，数值被改变了\n            dep.notify()\n        }\n    })\n}\n// 创建监听，在调用Observer类的外面加了层判断\nexport function observe(value){\n    // 当值不存在，或者不是对象，就不监听了\n    if(!value || typeof value !== 'object'){\n        return\n    }\n    return new Observer(value)\n}\n```\n\n在有些文章中，观察者模式与发布/订阅模式还有些差别，可以观摩这篇 [ObserverPattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript)去学习一下","slug":"observer-pattern-in-vue","published":1,"updated":"2017-11-19T06:50:01.000Z","_id":"cja54xykb001cgbehh8cxh7uu","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/vue-reactive.jpg\" alt=\"vue\"></p>\n<p>在 ES6 把 Promise 写进语言标准前，为实现异步编程，经常会采用 <strong>观察者模式（发布-订阅模式）</strong> 作为替代传递回调函数的方案。</p>\n<p>它定义了一种一对多的关系，让多个观察者订阅同一主题对象，当主题状态发生改变则立即发布，通知所有的订阅者。发布者和订阅者之间完全解耦，仅仅是共享同一自定义事件的名称。当新的订阅者出现，发布者无需做任何修改，反之亦然。</p>\n<a id=\"more\"></a>\n<h2 id=\"常见的需要观察者模式的场景：\"><a href=\"#常见的需要观察者模式的场景：\" class=\"headerlink\" title=\"常见的需要观察者模式的场景：\"></a>常见的需要观察者模式的场景：</h2><p>在任意一个需要登录的网站中，header，navbar，消息列表，购物车等模块的渲染，都需要登陆后拿到用户信息。但是ajax登录请求完成的时间无法确定，如果在ajax回调中调用各模块的方法来更新用户信息的话，耦合性太强，新增/修改模块的成本太高，业务模块更复杂的时候很难维护。这个时候需要的就是观察者模式。</p>\n<p>Vue 在实现数据绑定时也采用的观察者模式来实现数据的订阅，订阅者维护每一次更新之前的数据，当数据发生变化，订阅者将执行自身设定的回调逻辑，并更新所维护数据的值。</p>\n<h2 id=\"实现观察者模式：\"><a href=\"#实现观察者模式：\" class=\"headerlink\" title=\"实现观察者模式：\"></a>实现观察者模式：</h2><blockquote>\n<ol>\n<li>指定发布者</li>\n<li>给发布者添加一个缓存列表，用于存放回调函数以通知订阅者</li>\n<li>发布消息时，遍历缓存列表，触发每一个订阅者回调函数</li>\n</ol>\n</blockquote>\n<p>并且除了缓存列表之外，还需要订阅，发布，取消订阅这三个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> event = &#123;</div><div class=\"line\">  <span class=\"comment\">// 缓存列表</span></div><div class=\"line\">  clientList: [],</div><div class=\"line\">  <span class=\"comment\">// 订阅</span></div><div class=\"line\">  listen: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, fn</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.clientList[key]) &#123;</div><div class=\"line\">      <span class=\"comment\">// 订阅列表中没有这个 key 则把初始化这个 key 的队列为空</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.clientList[key] = []</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.clientList[key].push(fn)</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  trigger: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> key = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>)</div><div class=\"line\">    <span class=\"keyword\">var</span> fns = <span class=\"keyword\">this</span>.clientList[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fns || fns.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"comment\">// 遍历缓存列表，挨个触发回调</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, fn; fn = fns[ i++ ];)&#123;</div><div class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  remove: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fns = <span class=\"keyword\">this</span>.clientList[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fns)&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fn)&#123;</div><div class=\"line\">      fns &amp;&amp; (fns.length = <span class=\"number\">0</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> l = fns.length - <span class=\"number\">1</span>; l &gt;=<span class=\"number\">0</span>; l--)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _fn = fns[l]</div><div class=\"line\">        <span class=\"keyword\">if</span> (_fn === fn)&#123;</div><div class=\"line\">          fns.splice(l, <span class=\"number\">1</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这就是观察者模式的一个通用实现。</p>\n<p>在实际场景中，有可能需要多个发布者对象，需要多个类似上面 event 对象的绑定，非常麻烦，发布订阅也并没有完全解耦，需要知道这个对象的名字。因此也可以采用 <strong>全局的 Event 对象</strong> 来实现。<br>同时，也有可能为了避免命名冲突，需要 <strong>创建命名空间</strong> ，或者是由于为了实现可以先发布再订阅，<strong>创建离线堆栈</strong> 等等，可定制高级版的观察者模式。</p>\n<h2 id=\"采用观察者模式需要注意的问题：\"><a href=\"#采用观察者模式需要注意的问题：\" class=\"headerlink\" title=\"采用观察者模式需要注意的问题：\"></a>采用观察者模式需要注意的问题：</h2><ul>\n<li>实现观察者模式本身需要耗费内存，如果发布并不常发生，而订阅却始终存在于内存中，造成了一定程度的浪费</li>\n<li>由于模块之间的联系由具体的耦合转为抽象，因此过多使用观察者模式的话，模块关系很难追溯，代码也很难维护</li>\n</ul>\n<h2 id=\"Vue源码中的使用：\"><a href=\"#Vue源码中的使用：\" class=\"headerlink\" title=\"Vue源码中的使用：\"></a>Vue源码中的使用：</h2><p>Vue 实现数据绑定依靠的是 <strong>Object.defineProperty() 的自定义getter/setter</strong> 来进行的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 管理，通知订阅者</span></div><div class=\"line\"><span class=\"comment\">// 定义缓存列表，为外部提供 添加订阅/通知订阅者 的接口</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</div><div class=\"line\">        <span class=\"comment\">// 缓存列表</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.subs = []</div><div class=\"line\">    &#125;</div><div class=\"line\">    addSub(sub)&#123;</div><div class=\"line\">        <span class=\"comment\">// 添加订阅，即向缓存列表中添加新项</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.subs.push(sub)</div><div class=\"line\">    &#125;</div><div class=\"line\">    notify()&#123;</div><div class=\"line\">        <span class=\"comment\">// 通知所有的订阅者(Watcher)，触发订阅者的相应回调</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.subs.forEach((sub) =&gt; sub.update())</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 引入订阅管理模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> Dep <span class=\"keyword\">from</span> <span class=\"string\">'Dep'</span></div><div class=\"line\"><span class=\"comment\">// 定义订阅</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 接受三个参数，实例，所订阅数据，指定的回调</span></div><div class=\"line\">    <span class=\"keyword\">constructor</span>(vm, expOrFn, cb)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.vm = vm <span class=\"comment\">// 取到 Vue 实例，从而拿到实例上的 data</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.cb = cb <span class=\"comment\">// 数据更新时触发的回调函数</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.expOrFn = expOrFn <span class=\"comment\">// 被订阅的数据</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.val = <span class=\"keyword\">this</span>.get() <span class=\"comment\">// 赋值为定义订阅时的数据，即更新前的值</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 对外暴露的接口，数据更新时发布者将调用这个接口</span></div><div class=\"line\">    update()&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.run()</div><div class=\"line\">    &#125;</div><div class=\"line\">    run()&#123;</div><div class=\"line\">        <span class=\"comment\">// 订阅数据发生变化时，更新 val ，触发回调</span></div><div class=\"line\">        <span class=\"comment\">// val 为当前值， this.val 为更新前的值</span></div><div class=\"line\">        <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.get()</div><div class=\"line\">        <span class=\"keyword\">if</span>(val !== <span class=\"keyword\">this</span>.val)&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.val = val;</div><div class=\"line\">            <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    get()&#123;</div><div class=\"line\">        <span class=\"comment\">// 读取所订阅数据的最新值</span></div><div class=\"line\">        Dep.target = <span class=\"keyword\">this</span></div><div class=\"line\">        <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.vm._data[<span class=\"keyword\">this</span>.expOrFn]</div><div class=\"line\">        <span class=\"comment\">// 指针置空</span></div><div class=\"line\">        Dep.target = <span class=\"literal\">null</span></div><div class=\"line\">        <span class=\"keyword\">return</span> val;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义 Observer 数据监听器</span></div><div class=\"line\"><span class=\"comment\">// 引入 Dep 订阅管理模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> Dep <span class=\"keyword\">from</span> <span class=\"string\">'Dep'</span></div><div class=\"line\"><span class=\"comment\">// 定义 Observer 类，将所监听数据遍历每一项传入到 defineReactive 以加入 get/set 方法</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(value)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.value = value</div><div class=\"line\">        <span class=\"keyword\">this</span>.walk(value)</div><div class=\"line\">    &#125;</div><div class=\"line\">    walk(value)&#123;</div><div class=\"line\">        <span class=\"comment\">// 遍历所监听对象、数组的每一项</span></div><div class=\"line\">        <span class=\"built_in\">Object</span>.keys(value).forEach(key =&gt; <span class=\"keyword\">this</span>.convert(key, value[key]))</div><div class=\"line\">    &#125;</div><div class=\"line\">    convert(key, val)&#123;</div><div class=\"line\">        defineReactive(<span class=\"keyword\">this</span>.value, key, val)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, val</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 创建新的订阅</span></div><div class=\"line\">    <span class=\"keyword\">var</span> dep = <span class=\"keyword\">new</span> Dep()</div><div class=\"line\">    <span class=\"comment\">// 给当前属性的值添加监听</span></div><div class=\"line\">    <span class=\"keyword\">var</span> chlidOb = observe(val)</div><div class=\"line\">    <span class=\"comment\">// 加上 get/set</span></div><div class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">        <span class=\"comment\">// 设置为属性可遍历</span></div><div class=\"line\">        enumerable: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"comment\">// 属性可删除，可修改其 emumerable/writable 等属性</span></div><div class=\"line\">        configurable: <span class=\"literal\">true</span>,</div><div class=\"line\">        get: ()=&gt; &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'get value'</span>)</div><div class=\"line\">            <span class=\"comment\">// Dep.target 为 watcher 实例</span></div><div class=\"line\">            <span class=\"comment\">// 如果存在这个 watcher 则将其加入到 sub 队列</span></div><div class=\"line\">            <span class=\"comment\">// Watcher实例在实例化过程中，会触发当前get方法</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(Dep.target)&#123;</div><div class=\"line\">                dep.addSub(Dep.target)</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> val</div><div class=\"line\">        &#125;,</div><div class=\"line\">        set: (newVal) =&gt; &#123;</div><div class=\"line\">            <span class=\"comment\">// 如果数据被修改则会触发这段 set 函数</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'new value seted'</span>)</div><div class=\"line\">            <span class=\"keyword\">if</span>(val === newVal) <span class=\"keyword\">return</span></div><div class=\"line\">            val = newVal</div><div class=\"line\">            <span class=\"comment\">// 监听新值</span></div><div class=\"line\">            chlidOb = observe(newVal)</div><div class=\"line\">            <span class=\"comment\">// 通知所有订阅者，数值被改变了</span></div><div class=\"line\">            dep.notify()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 创建监听，在调用Observer类的外面加了层判断</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 当值不存在，或者不是对象，就不监听了</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!value || <span class=\"keyword\">typeof</span> value !== <span class=\"string\">'object'</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observer(value)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在有些文章中，观察者模式与发布/订阅模式还有些差别，可以观摩这篇 <a href=\"https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript\" target=\"_blank\" rel=\"external\">ObserverPattern</a>去学习一下</p>\n","excerpt":"<p><img src=\"/images/vue-reactive.jpg\" alt=\"vue\"></p>\n<p>在 ES6 把 Promise 写进语言标准前，为实现异步编程，经常会采用 <strong>观察者模式（发布-订阅模式）</strong> 作为替代传递回调函数的方案。</p>\n<p>它定义了一种一对多的关系，让多个观察者订阅同一主题对象，当主题状态发生改变则立即发布，通知所有的订阅者。发布者和订阅者之间完全解耦，仅仅是共享同一自定义事件的名称。当新的订阅者出现，发布者无需做任何修改，反之亦然。</p>","more":"<h2 id=\"常见的需要观察者模式的场景：\"><a href=\"#常见的需要观察者模式的场景：\" class=\"headerlink\" title=\"常见的需要观察者模式的场景：\"></a>常见的需要观察者模式的场景：</h2><p>在任意一个需要登录的网站中，header，navbar，消息列表，购物车等模块的渲染，都需要登陆后拿到用户信息。但是ajax登录请求完成的时间无法确定，如果在ajax回调中调用各模块的方法来更新用户信息的话，耦合性太强，新增/修改模块的成本太高，业务模块更复杂的时候很难维护。这个时候需要的就是观察者模式。</p>\n<p>Vue 在实现数据绑定时也采用的观察者模式来实现数据的订阅，订阅者维护每一次更新之前的数据，当数据发生变化，订阅者将执行自身设定的回调逻辑，并更新所维护数据的值。</p>\n<h2 id=\"实现观察者模式：\"><a href=\"#实现观察者模式：\" class=\"headerlink\" title=\"实现观察者模式：\"></a>实现观察者模式：</h2><blockquote>\n<ol>\n<li>指定发布者</li>\n<li>给发布者添加一个缓存列表，用于存放回调函数以通知订阅者</li>\n<li>发布消息时，遍历缓存列表，触发每一个订阅者回调函数</li>\n</ol>\n</blockquote>\n<p>并且除了缓存列表之外，还需要订阅，发布，取消订阅这三个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> event = &#123;</div><div class=\"line\">  <span class=\"comment\">// 缓存列表</span></div><div class=\"line\">  clientList: [],</div><div class=\"line\">  <span class=\"comment\">// 订阅</span></div><div class=\"line\">  listen: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, fn</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.clientList[key]) &#123;</div><div class=\"line\">      <span class=\"comment\">// 订阅列表中没有这个 key 则把初始化这个 key 的队列为空</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.clientList[key] = []</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.clientList[key].push(fn)</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  trigger: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> key = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>)</div><div class=\"line\">    <span class=\"keyword\">var</span> fns = <span class=\"keyword\">this</span>.clientList[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fns || fns.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"comment\">// 遍历缓存列表，挨个触发回调</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, fn; fn = fns[ i++ ];)&#123;</div><div class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  remove: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fns = <span class=\"keyword\">this</span>.clientList[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fns)&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fn)&#123;</div><div class=\"line\">      fns &amp;&amp; (fns.length = <span class=\"number\">0</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> l = fns.length - <span class=\"number\">1</span>; l &gt;=<span class=\"number\">0</span>; l--)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _fn = fns[l]</div><div class=\"line\">        <span class=\"keyword\">if</span> (_fn === fn)&#123;</div><div class=\"line\">          fns.splice(l, <span class=\"number\">1</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这就是观察者模式的一个通用实现。</p>\n<p>在实际场景中，有可能需要多个发布者对象，需要多个类似上面 event 对象的绑定，非常麻烦，发布订阅也并没有完全解耦，需要知道这个对象的名字。因此也可以采用 <strong>全局的 Event 对象</strong> 来实现。<br>同时，也有可能为了避免命名冲突，需要 <strong>创建命名空间</strong> ，或者是由于为了实现可以先发布再订阅，<strong>创建离线堆栈</strong> 等等，可定制高级版的观察者模式。</p>\n<h2 id=\"采用观察者模式需要注意的问题：\"><a href=\"#采用观察者模式需要注意的问题：\" class=\"headerlink\" title=\"采用观察者模式需要注意的问题：\"></a>采用观察者模式需要注意的问题：</h2><ul>\n<li>实现观察者模式本身需要耗费内存，如果发布并不常发生，而订阅却始终存在于内存中，造成了一定程度的浪费</li>\n<li>由于模块之间的联系由具体的耦合转为抽象，因此过多使用观察者模式的话，模块关系很难追溯，代码也很难维护</li>\n</ul>\n<h2 id=\"Vue源码中的使用：\"><a href=\"#Vue源码中的使用：\" class=\"headerlink\" title=\"Vue源码中的使用：\"></a>Vue源码中的使用：</h2><p>Vue 实现数据绑定依靠的是 <strong>Object.defineProperty() 的自定义getter/setter</strong> 来进行的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 管理，通知订阅者</span></div><div class=\"line\"><span class=\"comment\">// 定义缓存列表，为外部提供 添加订阅/通知订阅者 的接口</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</div><div class=\"line\">        <span class=\"comment\">// 缓存列表</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.subs = []</div><div class=\"line\">    &#125;</div><div class=\"line\">    addSub(sub)&#123;</div><div class=\"line\">        <span class=\"comment\">// 添加订阅，即向缓存列表中添加新项</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.subs.push(sub)</div><div class=\"line\">    &#125;</div><div class=\"line\">    notify()&#123;</div><div class=\"line\">        <span class=\"comment\">// 通知所有的订阅者(Watcher)，触发订阅者的相应回调</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.subs.forEach((sub) =&gt; sub.update())</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 引入订阅管理模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> Dep <span class=\"keyword\">from</span> <span class=\"string\">'Dep'</span></div><div class=\"line\"><span class=\"comment\">// 定义订阅</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 接受三个参数，实例，所订阅数据，指定的回调</span></div><div class=\"line\">    <span class=\"keyword\">constructor</span>(vm, expOrFn, cb)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.vm = vm <span class=\"comment\">// 取到 Vue 实例，从而拿到实例上的 data</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.cb = cb <span class=\"comment\">// 数据更新时触发的回调函数</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.expOrFn = expOrFn <span class=\"comment\">// 被订阅的数据</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.val = <span class=\"keyword\">this</span>.get() <span class=\"comment\">// 赋值为定义订阅时的数据，即更新前的值</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 对外暴露的接口，数据更新时发布者将调用这个接口</span></div><div class=\"line\">    update()&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.run()</div><div class=\"line\">    &#125;</div><div class=\"line\">    run()&#123;</div><div class=\"line\">        <span class=\"comment\">// 订阅数据发生变化时，更新 val ，触发回调</span></div><div class=\"line\">        <span class=\"comment\">// val 为当前值， this.val 为更新前的值</span></div><div class=\"line\">        <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.get()</div><div class=\"line\">        <span class=\"keyword\">if</span>(val !== <span class=\"keyword\">this</span>.val)&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.val = val;</div><div class=\"line\">            <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    get()&#123;</div><div class=\"line\">        <span class=\"comment\">// 读取所订阅数据的最新值</span></div><div class=\"line\">        Dep.target = <span class=\"keyword\">this</span></div><div class=\"line\">        <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.vm._data[<span class=\"keyword\">this</span>.expOrFn]</div><div class=\"line\">        <span class=\"comment\">// 指针置空</span></div><div class=\"line\">        Dep.target = <span class=\"literal\">null</span></div><div class=\"line\">        <span class=\"keyword\">return</span> val;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义 Observer 数据监听器</span></div><div class=\"line\"><span class=\"comment\">// 引入 Dep 订阅管理模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> Dep <span class=\"keyword\">from</span> <span class=\"string\">'Dep'</span></div><div class=\"line\"><span class=\"comment\">// 定义 Observer 类，将所监听数据遍历每一项传入到 defineReactive 以加入 get/set 方法</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(value)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.value = value</div><div class=\"line\">        <span class=\"keyword\">this</span>.walk(value)</div><div class=\"line\">    &#125;</div><div class=\"line\">    walk(value)&#123;</div><div class=\"line\">        <span class=\"comment\">// 遍历所监听对象、数组的每一项</span></div><div class=\"line\">        <span class=\"built_in\">Object</span>.keys(value).forEach(key =&gt; <span class=\"keyword\">this</span>.convert(key, value[key]))</div><div class=\"line\">    &#125;</div><div class=\"line\">    convert(key, val)&#123;</div><div class=\"line\">        defineReactive(<span class=\"keyword\">this</span>.value, key, val)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, val</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 创建新的订阅</span></div><div class=\"line\">    <span class=\"keyword\">var</span> dep = <span class=\"keyword\">new</span> Dep()</div><div class=\"line\">    <span class=\"comment\">// 给当前属性的值添加监听</span></div><div class=\"line\">    <span class=\"keyword\">var</span> chlidOb = observe(val)</div><div class=\"line\">    <span class=\"comment\">// 加上 get/set</span></div><div class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">        <span class=\"comment\">// 设置为属性可遍历</span></div><div class=\"line\">        enumerable: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"comment\">// 属性可删除，可修改其 emumerable/writable 等属性</span></div><div class=\"line\">        configurable: <span class=\"literal\">true</span>,</div><div class=\"line\">        get: ()=&gt; &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'get value'</span>)</div><div class=\"line\">            <span class=\"comment\">// Dep.target 为 watcher 实例</span></div><div class=\"line\">            <span class=\"comment\">// 如果存在这个 watcher 则将其加入到 sub 队列</span></div><div class=\"line\">            <span class=\"comment\">// Watcher实例在实例化过程中，会触发当前get方法</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(Dep.target)&#123;</div><div class=\"line\">                dep.addSub(Dep.target)</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> val</div><div class=\"line\">        &#125;,</div><div class=\"line\">        set: (newVal) =&gt; &#123;</div><div class=\"line\">            <span class=\"comment\">// 如果数据被修改则会触发这段 set 函数</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'new value seted'</span>)</div><div class=\"line\">            <span class=\"keyword\">if</span>(val === newVal) <span class=\"keyword\">return</span></div><div class=\"line\">            val = newVal</div><div class=\"line\">            <span class=\"comment\">// 监听新值</span></div><div class=\"line\">            chlidOb = observe(newVal)</div><div class=\"line\">            <span class=\"comment\">// 通知所有订阅者，数值被改变了</span></div><div class=\"line\">            dep.notify()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 创建监听，在调用Observer类的外面加了层判断</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 当值不存在，或者不是对象，就不监听了</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!value || <span class=\"keyword\">typeof</span> value !== <span class=\"string\">'object'</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observer(value)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在有些文章中，观察者模式与发布/订阅模式还有些差别，可以观摩这篇 <a href=\"https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript\">ObserverPattern</a>去学习一下</p>"},{"layout":"post","title":"2017 年度总结","date":"2017-12-31T04:00:00.000Z","_content":"\n![tokyo in 2017](/images/tokyo-in-2017.jpg)\n\n2017: no silver bullet.\n\n<!--more-->\n\n#### 工作\n\n二月底入职了美团，到现在也快一年了。\n\n借助于在下厨房时一行一行代码 review 出的好习惯以及一些技术选型上的经验红利，这大半年包括职级晋升也过得还是很顺利。在此非常感谢也怀念在下厨房的那些菜鸟日子。\n\n美团的知识wiki 藏龙卧虎，有完善的新人培养以及 Mentor 机制，每天各个 BU 都有些质量很不错的技术分享，精力足够的话在新人期是有非常多的机会去学习观摩的。在终端组时还有被要求记录 work log，虽然一开始有些痛苦，最后还是养成了注重人效与时间管理的习惯。\n\n除了以上，最大的感受还是在于，一直被培养“做事的方法”，要求注重软素质。在大厂当螺丝钉，基本不会遇到每天应付 PM 改需求，调整开发时间这类事。PM 包办了项目管理，与业务方的沟通等事情，作为 FE 只需要确定好自己的估时排期，关注后端提供的接口定义就可以。好处显而易见，坏处就是过于螺丝钉了，没什么机会去做自身领域外的事情。今后还是需要自己多努力扩展能力边界。\n\n\n#### 生活\n\n四月的时候去了趟日本，走了东京和伊东两座城市。在东京六本木的观景台拍了题图这张夜景。伊豆半岛的性价比很高，和牛比在东京吃的更好吃，因为没什么游客，看到了蛮多更市井的场景。感觉出来玩还是慢悠悠的会比较有意思。\n\n生活中最重要的事是，年底把户口迁到了成都。买房和定居还不一定是什么时候，应该要等工作能力再提高一些，不那么菜之后再说。时隔三年又去了一次成都，除了好吃更感觉是真的安逸。\n\n就在跨年这两天，我搬家到了望京这边，换了一个一居室，更适合猫猫住。离公司近一些，节省了通勤时间，想把节省的时间用在健身上。毕业一年半，体质是稳步地下降，精力不太够用，嗜糖这一坏习惯也没有多大好转。再这样下去应该是迟早 💊。\n\n今年有在做基金定投，收益 10% 左右，只是年底由于订明年出行的机票酒店吃了波土，最后两个月没有继续投入了。这种强制储蓄的理财方式确实很实用，只是需要每月都在发薪日投出去，免得最后又花超了变月光。\n\n#### 📚 和 🎬\n\n今年一共看了 13 本书，去年制定的看书计划基本完成了。\n\n> 1. 《学习JavaScript数据结构与算法》\n> 2. 《禅与摩托车维修艺术》\n> 3. 《程序员修炼之道 : 从小工到专家》\n> 4. 《Node.js实战》\n> 5. 《图解HTTP》\n> 6. 《Web全栈工程师的自我修养》\n> 7. 《牛津通识读本 : 数学》\n> 8. 《刻意练习》\n> 9. 《淘宝技术这十年》\n> 10. 《亲密关系》\n> 11. 《地球与太空》\n> 12. 《一首小夜曲》\n> 13. 《死神的精确度》\n\n只是技术上没看什么大部头，还有几本已经看到最后几章但是计划被打乱迟迟没有看完。\n\n电影看了 79 部，从豆瓣的报告来看还是院线片居多，可能也反映出了心态比较浮躁吧。\n\n#### 新的计划\n\n这里只列举一些急切需要完成（三个月内）的事。在此推荐一个最近感觉很好用的 APP， [我的小目标](https://www.v2ex.com/t/413134#reply11)，是由一名 iOS 开发者独立开发的个人作品，其中集成了番茄钟与单核工作法，金币积攒与消耗这种类似于打怪升级的模式很适合我。\n\n待办事项：\n1.读完《JavaScript 设计模式与开发实践》\n2.完成《Git 原理解析》的 blog && 分享\n3.移动端预渲染方案\n\n习惯养成：\n1.leetcode每周一题\n2.每周健身一次（看看前五周降体脂的效果如何\n3.每周在掘金翻译计划校对/推荐文章一次\n\n#### Less is more\n\n最后还是总结一下，生活和工作上都没有银弹，好好管理生活与代码的复杂度。\n\n","source":"_posts/2017-review.md","raw":"---\nlayout: post\ntitle:  \"2017 年度总结\"\ndate:   2017-12-31 12:00\ncategories: summary\n---\n\n![tokyo in 2017](/images/tokyo-in-2017.jpg)\n\n2017: no silver bullet.\n\n<!--more-->\n\n#### 工作\n\n二月底入职了美团，到现在也快一年了。\n\n借助于在下厨房时一行一行代码 review 出的好习惯以及一些技术选型上的经验红利，这大半年包括职级晋升也过得还是很顺利。在此非常感谢也怀念在下厨房的那些菜鸟日子。\n\n美团的知识wiki 藏龙卧虎，有完善的新人培养以及 Mentor 机制，每天各个 BU 都有些质量很不错的技术分享，精力足够的话在新人期是有非常多的机会去学习观摩的。在终端组时还有被要求记录 work log，虽然一开始有些痛苦，最后还是养成了注重人效与时间管理的习惯。\n\n除了以上，最大的感受还是在于，一直被培养“做事的方法”，要求注重软素质。在大厂当螺丝钉，基本不会遇到每天应付 PM 改需求，调整开发时间这类事。PM 包办了项目管理，与业务方的沟通等事情，作为 FE 只需要确定好自己的估时排期，关注后端提供的接口定义就可以。好处显而易见，坏处就是过于螺丝钉了，没什么机会去做自身领域外的事情。今后还是需要自己多努力扩展能力边界。\n\n\n#### 生活\n\n四月的时候去了趟日本，走了东京和伊东两座城市。在东京六本木的观景台拍了题图这张夜景。伊豆半岛的性价比很高，和牛比在东京吃的更好吃，因为没什么游客，看到了蛮多更市井的场景。感觉出来玩还是慢悠悠的会比较有意思。\n\n生活中最重要的事是，年底把户口迁到了成都。买房和定居还不一定是什么时候，应该要等工作能力再提高一些，不那么菜之后再说。时隔三年又去了一次成都，除了好吃更感觉是真的安逸。\n\n就在跨年这两天，我搬家到了望京这边，换了一个一居室，更适合猫猫住。离公司近一些，节省了通勤时间，想把节省的时间用在健身上。毕业一年半，体质是稳步地下降，精力不太够用，嗜糖这一坏习惯也没有多大好转。再这样下去应该是迟早 💊。\n\n今年有在做基金定投，收益 10% 左右，只是年底由于订明年出行的机票酒店吃了波土，最后两个月没有继续投入了。这种强制储蓄的理财方式确实很实用，只是需要每月都在发薪日投出去，免得最后又花超了变月光。\n\n#### 📚 和 🎬\n\n今年一共看了 13 本书，去年制定的看书计划基本完成了。\n\n> 1. 《学习JavaScript数据结构与算法》\n> 2. 《禅与摩托车维修艺术》\n> 3. 《程序员修炼之道 : 从小工到专家》\n> 4. 《Node.js实战》\n> 5. 《图解HTTP》\n> 6. 《Web全栈工程师的自我修养》\n> 7. 《牛津通识读本 : 数学》\n> 8. 《刻意练习》\n> 9. 《淘宝技术这十年》\n> 10. 《亲密关系》\n> 11. 《地球与太空》\n> 12. 《一首小夜曲》\n> 13. 《死神的精确度》\n\n只是技术上没看什么大部头，还有几本已经看到最后几章但是计划被打乱迟迟没有看完。\n\n电影看了 79 部，从豆瓣的报告来看还是院线片居多，可能也反映出了心态比较浮躁吧。\n\n#### 新的计划\n\n这里只列举一些急切需要完成（三个月内）的事。在此推荐一个最近感觉很好用的 APP， [我的小目标](https://www.v2ex.com/t/413134#reply11)，是由一名 iOS 开发者独立开发的个人作品，其中集成了番茄钟与单核工作法，金币积攒与消耗这种类似于打怪升级的模式很适合我。\n\n待办事项：\n1.读完《JavaScript 设计模式与开发实践》\n2.完成《Git 原理解析》的 blog && 分享\n3.移动端预渲染方案\n\n习惯养成：\n1.leetcode每周一题\n2.每周健身一次（看看前五周降体脂的效果如何\n3.每周在掘金翻译计划校对/推荐文章一次\n\n#### Less is more\n\n最后还是总结一下，生活和工作上都没有银弹，好好管理生活与代码的复杂度。\n\n","slug":"2017-review","published":1,"updated":"2017-12-31T14:12:24.000Z","_id":"cjbuug4no00007j6myudlxcg8","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/tokyo-in-2017.jpg\" alt=\"tokyo in 2017\"></p>\n<p>2017: no silver bullet.</p>\n<a id=\"more\"></a>\n<h4 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h4><p>二月底入职了美团，到现在也快一年了。</p>\n<p>借助于在下厨房时一行一行代码 review 出的好习惯以及一些技术选型上的经验红利，这大半年包括职级晋升也过得还是很顺利。在此非常感谢也怀念在下厨房的那些菜鸟日子。</p>\n<p>美团的知识wiki 藏龙卧虎，有完善的新人培养以及 Mentor 机制，每天各个 BU 都有些质量很不错的技术分享，精力足够的话在新人期是有非常多的机会去学习观摩的。在终端组时还有被要求记录 work log，虽然一开始有些痛苦，最后还是养成了注重人效与时间管理的习惯。</p>\n<p>除了以上，最大的感受还是在于，一直被培养“做事的方法”，要求注重软素质。在大厂当螺丝钉，基本不会遇到每天应付 PM 改需求，调整开发时间这类事。PM 包办了项目管理，与业务方的沟通等事情，作为 FE 只需要确定好自己的估时排期，关注后端提供的接口定义就可以。好处显而易见，坏处就是过于螺丝钉了，没什么机会去做自身领域外的事情。今后还是需要自己多努力扩展能力边界。</p>\n<h4 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h4><p>四月的时候去了趟日本，走了东京和伊东两座城市。在东京六本木的观景台拍了题图这张夜景。伊豆半岛的性价比很高，和牛比在东京吃的更好吃，因为没什么游客，看到了蛮多更市井的场景。感觉出来玩还是慢悠悠的会比较有意思。</p>\n<p>生活中最重要的事是，年底把户口迁到了成都。买房和定居还不一定是什么时候，应该要等工作能力再提高一些，不那么菜之后再说。时隔三年又去了一次成都，除了好吃更感觉是真的安逸。</p>\n<p>就在跨年这两天，我搬家到了望京这边，换了一个一居室，更适合猫猫住。离公司近一些，节省了通勤时间，想把节省的时间用在健身上。毕业一年半，体质是稳步地下降，精力不太够用，嗜糖这一坏习惯也没有多大好转。再这样下去应该是迟早 💊。</p>\n<p>今年有在做基金定投，收益 10% 左右，只是年底由于订明年出行的机票酒店吃了波土，最后两个月没有继续投入了。这种强制储蓄的理财方式确实很实用，只是需要每月都在发薪日投出去，免得最后又花超了变月光。</p>\n<h4 id=\"📚-和-🎬\"><a href=\"#📚-和-🎬\" class=\"headerlink\" title=\"📚 和 🎬\"></a>📚 和 🎬</h4><p>今年一共看了 13 本书，去年制定的看书计划基本完成了。</p>\n<blockquote>\n<ol>\n<li>《学习JavaScript数据结构与算法》</li>\n<li>《禅与摩托车维修艺术》</li>\n<li>《程序员修炼之道 : 从小工到专家》</li>\n<li>《Node.js实战》</li>\n<li>《图解HTTP》</li>\n<li>《Web全栈工程师的自我修养》</li>\n<li>《牛津通识读本 : 数学》</li>\n<li>《刻意练习》</li>\n<li>《淘宝技术这十年》</li>\n<li>《亲密关系》</li>\n<li>《地球与太空》</li>\n<li>《一首小夜曲》</li>\n<li>《死神的精确度》</li>\n</ol>\n</blockquote>\n<p>只是技术上没看什么大部头，还有几本已经看到最后几章但是计划被打乱迟迟没有看完。</p>\n<p>电影看了 79 部，从豆瓣的报告来看还是院线片居多，可能也反映出了心态比较浮躁吧。</p>\n<h4 id=\"新的计划\"><a href=\"#新的计划\" class=\"headerlink\" title=\"新的计划\"></a>新的计划</h4><p>这里只列举一些急切需要完成（三个月内）的事。在此推荐一个最近感觉很好用的 APP， <a href=\"https://www.v2ex.com/t/413134#reply11\" target=\"_blank\" rel=\"external\">我的小目标</a>，是由一名 iOS 开发者独立开发的个人作品，其中集成了番茄钟与单核工作法，金币积攒与消耗这种类似于打怪升级的模式很适合我。</p>\n<p>待办事项：<br>1.读完《JavaScript 设计模式与开发实践》<br>2.完成《Git 原理解析》的 blog &amp;&amp; 分享<br>3.移动端预渲染方案</p>\n<p>习惯养成：<br>1.leetcode每周一题<br>2.每周健身一次（看看前五周降体脂的效果如何<br>3.每周在掘金翻译计划校对/推荐文章一次</p>\n<h4 id=\"Less-is-more\"><a href=\"#Less-is-more\" class=\"headerlink\" title=\"Less is more\"></a>Less is more</h4><p>最后还是总结一下，生活和工作上都没有银弹，好好管理生活与代码的复杂度。</p>\n","excerpt":"<p><img src=\"/images/tokyo-in-2017.jpg\" alt=\"tokyo in 2017\"></p>\n<p>2017: no silver bullet.</p>","more":"<h4 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h4><p>二月底入职了美团，到现在也快一年了。</p>\n<p>借助于在下厨房时一行一行代码 review 出的好习惯以及一些技术选型上的经验红利，这大半年包括职级晋升也过得还是很顺利。在此非常感谢也怀念在下厨房的那些菜鸟日子。</p>\n<p>美团的知识wiki 藏龙卧虎，有完善的新人培养以及 Mentor 机制，每天各个 BU 都有些质量很不错的技术分享，精力足够的话在新人期是有非常多的机会去学习观摩的。在终端组时还有被要求记录 work log，虽然一开始有些痛苦，最后还是养成了注重人效与时间管理的习惯。</p>\n<p>除了以上，最大的感受还是在于，一直被培养“做事的方法”，要求注重软素质。在大厂当螺丝钉，基本不会遇到每天应付 PM 改需求，调整开发时间这类事。PM 包办了项目管理，与业务方的沟通等事情，作为 FE 只需要确定好自己的估时排期，关注后端提供的接口定义就可以。好处显而易见，坏处就是过于螺丝钉了，没什么机会去做自身领域外的事情。今后还是需要自己多努力扩展能力边界。</p>\n<h4 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h4><p>四月的时候去了趟日本，走了东京和伊东两座城市。在东京六本木的观景台拍了题图这张夜景。伊豆半岛的性价比很高，和牛比在东京吃的更好吃，因为没什么游客，看到了蛮多更市井的场景。感觉出来玩还是慢悠悠的会比较有意思。</p>\n<p>生活中最重要的事是，年底把户口迁到了成都。买房和定居还不一定是什么时候，应该要等工作能力再提高一些，不那么菜之后再说。时隔三年又去了一次成都，除了好吃更感觉是真的安逸。</p>\n<p>就在跨年这两天，我搬家到了望京这边，换了一个一居室，更适合猫猫住。离公司近一些，节省了通勤时间，想把节省的时间用在健身上。毕业一年半，体质是稳步地下降，精力不太够用，嗜糖这一坏习惯也没有多大好转。再这样下去应该是迟早 💊。</p>\n<p>今年有在做基金定投，收益 10% 左右，只是年底由于订明年出行的机票酒店吃了波土，最后两个月没有继续投入了。这种强制储蓄的理财方式确实很实用，只是需要每月都在发薪日投出去，免得最后又花超了变月光。</p>\n<h4 id=\"📚-和-🎬\"><a href=\"#📚-和-🎬\" class=\"headerlink\" title=\"📚 和 🎬\"></a>📚 和 🎬</h4><p>今年一共看了 13 本书，去年制定的看书计划基本完成了。</p>\n<blockquote>\n<ol>\n<li>《学习JavaScript数据结构与算法》</li>\n<li>《禅与摩托车维修艺术》</li>\n<li>《程序员修炼之道 : 从小工到专家》</li>\n<li>《Node.js实战》</li>\n<li>《图解HTTP》</li>\n<li>《Web全栈工程师的自我修养》</li>\n<li>《牛津通识读本 : 数学》</li>\n<li>《刻意练习》</li>\n<li>《淘宝技术这十年》</li>\n<li>《亲密关系》</li>\n<li>《地球与太空》</li>\n<li>《一首小夜曲》</li>\n<li>《死神的精确度》</li>\n</ol>\n</blockquote>\n<p>只是技术上没看什么大部头，还有几本已经看到最后几章但是计划被打乱迟迟没有看完。</p>\n<p>电影看了 79 部，从豆瓣的报告来看还是院线片居多，可能也反映出了心态比较浮躁吧。</p>\n<h4 id=\"新的计划\"><a href=\"#新的计划\" class=\"headerlink\" title=\"新的计划\"></a>新的计划</h4><p>这里只列举一些急切需要完成（三个月内）的事。在此推荐一个最近感觉很好用的 APP， <a href=\"https://www.v2ex.com/t/413134#reply11\">我的小目标</a>，是由一名 iOS 开发者独立开发的个人作品，其中集成了番茄钟与单核工作法，金币积攒与消耗这种类似于打怪升级的模式很适合我。</p>\n<p>待办事项：<br>1.读完《JavaScript 设计模式与开发实践》<br>2.完成《Git 原理解析》的 blog &amp;&amp; 分享<br>3.移动端预渲染方案</p>\n<p>习惯养成：<br>1.leetcode每周一题<br>2.每周健身一次（看看前五周降体脂的效果如何<br>3.每周在掘金翻译计划校对/推荐文章一次</p>\n<h4 id=\"Less-is-more\"><a href=\"#Less-is-more\" class=\"headerlink\" title=\"Less is more\"></a>Less is more</h4><p>最后还是总结一下，生活和工作上都没有银弹，好好管理生活与代码的复杂度。</p>"},{"layout":"post","title":"回顾一下 JavaScript 中的深浅拷贝以及内存管理","date":"2018-01-13T01:05:00.000Z","_content":"\n![cover](/images/review-copy-in-javascript.png)\n\n最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 `JSON.parse(JSON.stringify(target))` 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。\n\n<!--more-->\n\n### 基本类型 VS 引用类型，值传递 VS 引用传递\n\n首先回顾一下高程中的基本概念。\n\nECMAScript 变量包含两种数据类型的值：基本类型值与引用类型值。基本类型指的是简单的数据段，如 `Undefined`、`Null`、`Boolean`、`Number` 和 `String`（ES6 中出现的 `Symbol` 也属于基本类型）。引用类型指的是可能由多个值构成的对象。\n\n基本类型是按值访问的，**可以操作保存在变量中的实际的值**。\n\n引用类型的值是保存在内存中的对象，**JavaScript 不允许直接访问内存中的位置**，因此我们在操作对象时，是在操作对象的引用而不是实际的对象。\n\n然而访问变量有按值和按引用两种方式，而 **参数只能按值传递**。在向参数传递引用类型的值时，会把值在内存中的地址复制给另一个局部变量。\n\n### 深入内存\n\n以上虽然不难理解，但是不深层挖掘一下还是很难完全记住。所以来看看内存中到底发生了什么吧。\n\n先看看内存的生命周期：\n\n![life](https://raw.githubusercontent.com/dt-fe/weekly/master/assets/29/1.jpg)\n\n即 内存分配 => 内存读写 => 内存释放\n\nJavaScript 在定义变量时即完成了内存分配。**运算符= 就是创建或修改变量在内存中的指向。**\n\n```javascript\nvar a = { b: 1 }; // a 为引用类型，给 a 分配内存 { b: 1 }， a 存储的即为 { b: 1 } 的地址\nvar c = a; // 给 c 分配内存 指向 a 存储的地址，即 { b: 1 } 的地址\na = 2; // 修改 a 的内存指向到 2\nconsole.log(c); // c 存储的仍为 { b: 1 } 的地址，因此结果为 { b: 1 }\n```\n前两行代码在内存中的分布为：\n\n变量 | 内存\n:--: | :--:\na | { b: 1 } 地址\nc |  { b: 1 } 地址\n\n第三行修改了内存指向：\n\n变量 | 内存\n:--: | :--:\na | 2\n\n变量 c 仍然指向 { b: 1 } 的地址。\n\n再看一个例子：\n\n```javascript\nvar m = { a: 10, b: 20 }\nvar n = m; // 复制引用类型的值，使 n 和 m 指向同一地址\nn.a = 15;\nconsole.log(m.a);\n```\n还是先看前两行：\n\n变量 | 内存\n:--: | :--:\nm | { a: 10, b: 20 } 地址\nn | { a: 10, b: 20 } 地址\n\n第三行通过 n.a 修改了变量，但 m 和 n 仍然指向同一地址不变，因此 m.a 的值也为 15\n\n对于参数传递过程中的内存变化不是本文重点，可以观摩 [JavaScript深入之参数按值传递](https://github.com/mqyqingfeng/Blog/issues/10) 下面精彩的评论来学习。\n\n有很多博文还针对 JavaScript 的内存空间，栈内存与堆内存进行了讲解，但是对于这方面实在没有经验，没什么鉴别能力，暂时先不说了。\n\n###  JavaScript 中的深浅拷贝\n\n回顾完以上知识点后，可以发现对于对象的拷贝，其实分为两种情况（这里，将被拷贝对象称为源对象）：\n\n- shallow clone 浅拷贝：如果对象中某个属性值是对象的话，浅拷贝的只是内存指针，当内存中的值发生变化后，拷贝对象与源对象与都会发生改变。\n- deep clone 深拷贝：拷贝对象与源对象是完全单独的对象，没有属性值是指向同一内存指针的，源对象发生任何修改都不会引起拷贝对象发生变化。\n\n需要注意一点，ES6 中 Object 的新方法 `Object.assign` 执行的就是浅拷贝，Stack Overflow 上有一个高票回答误将其答为深拷贝，我就踩了坑，避免加深错误印象，这里不放链接了。\n\nES6 中的 Object `rest/spread destructuring` 也是浅拷贝：\n\n```javascript\nconst existing = { a: 1, b: 2, c: 3 };\nconst { ...clone } = existing;\n```\n\n对于深拷贝，可想而知，需要对嵌套对象进行递归遍历，但是真正实现 deep clone 没有想象的简单，主要原因在于 deep clone 的定义并不统一，以及 edge case 非常多，包含 DOM/BOM 对象如何处理，函数如何处理，原型链如何处理等问题。但是希望 “做出修改不影响其它引用” 确实是一个常见场景。\n\n最简单的方法就是开头提到的 `JSON.parse(JSON.stringify(target))`。缺点在于无法处理 Date、Function 等类型的属性值。\n\n因此在业务中推荐使用 lodash 的 [_.cloneDeep](https://lodash.com/docs/4.17.4#cloneDeep) 实现深拷贝，简洁可靠。\n\n实际上，在 [immutable.js](http://facebook.github.io/immutable-js/) 出现后，实现数据结构的持久化有了更优雅的方式。\n\n### 希望之光 Immutable\n\n![Immutable](https://camo.githubusercontent.com/4c698f4cef2ae6b69873aa7de91f6d10f28162e1/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69312f544231796b395f4b585858585862565846585845745848387058582d3930302d3334322e706e67)\n\nJavaScript 中的对象一般都是可变的（mutable），虽然节省了内存，却给复杂的大型应用造成很多隐患。Immutable Data 为一旦创建，就不能再被修改的数据。通过 **Persistent Data Structure**（持久化数据结构）使得在使用旧数据创建新数据时，也保证了旧数据同时可用且不变。\n\n前面所述的 deep clone 方法是把所有节点都复制一遍，性能损耗非常大。Immutable 使用了 **Structural Sharing**（结构共享），性能提升很多。\n\n通过 immutable.js 实现 deep clone:\n\n```javascript\nvar defaultConfig = Immutable.fromJS({});\nvar config = defaultConfig.merge(initConfig); // defaultConfig不会改变，返回新值给 config\nvar config = defaultConfig.mergeDeep(initConfig); // 深层merge\n```\n\nimmutable.js 提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record。\n\n虽然 immutable.js 通常与 facebook 同厂出品的 React 一起使用，但是它其实是一个完全独立的库，无论基于什么框架都可以使用。说它是希望之光并没有言过其实。更多内容可以查看 [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3)。\n\n\n\n\n","source":"_posts/review-copy-in-javascript.md","raw":"---\nlayout: post\ntitle:  \"回顾一下 JavaScript 中的深浅拷贝以及内存管理\"\ndate:   2018-01-13 09:05\ncategories: javascript\n---\n\n![cover](/images/review-copy-in-javascript.png)\n\n最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 `JSON.parse(JSON.stringify(target))` 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。\n\n<!--more-->\n\n### 基本类型 VS 引用类型，值传递 VS 引用传递\n\n首先回顾一下高程中的基本概念。\n\nECMAScript 变量包含两种数据类型的值：基本类型值与引用类型值。基本类型指的是简单的数据段，如 `Undefined`、`Null`、`Boolean`、`Number` 和 `String`（ES6 中出现的 `Symbol` 也属于基本类型）。引用类型指的是可能由多个值构成的对象。\n\n基本类型是按值访问的，**可以操作保存在变量中的实际的值**。\n\n引用类型的值是保存在内存中的对象，**JavaScript 不允许直接访问内存中的位置**，因此我们在操作对象时，是在操作对象的引用而不是实际的对象。\n\n然而访问变量有按值和按引用两种方式，而 **参数只能按值传递**。在向参数传递引用类型的值时，会把值在内存中的地址复制给另一个局部变量。\n\n### 深入内存\n\n以上虽然不难理解，但是不深层挖掘一下还是很难完全记住。所以来看看内存中到底发生了什么吧。\n\n先看看内存的生命周期：\n\n![life](https://raw.githubusercontent.com/dt-fe/weekly/master/assets/29/1.jpg)\n\n即 内存分配 => 内存读写 => 内存释放\n\nJavaScript 在定义变量时即完成了内存分配。**运算符= 就是创建或修改变量在内存中的指向。**\n\n```javascript\nvar a = { b: 1 }; // a 为引用类型，给 a 分配内存 { b: 1 }， a 存储的即为 { b: 1 } 的地址\nvar c = a; // 给 c 分配内存 指向 a 存储的地址，即 { b: 1 } 的地址\na = 2; // 修改 a 的内存指向到 2\nconsole.log(c); // c 存储的仍为 { b: 1 } 的地址，因此结果为 { b: 1 }\n```\n前两行代码在内存中的分布为：\n\n变量 | 内存\n:--: | :--:\na | { b: 1 } 地址\nc |  { b: 1 } 地址\n\n第三行修改了内存指向：\n\n变量 | 内存\n:--: | :--:\na | 2\n\n变量 c 仍然指向 { b: 1 } 的地址。\n\n再看一个例子：\n\n```javascript\nvar m = { a: 10, b: 20 }\nvar n = m; // 复制引用类型的值，使 n 和 m 指向同一地址\nn.a = 15;\nconsole.log(m.a);\n```\n还是先看前两行：\n\n变量 | 内存\n:--: | :--:\nm | { a: 10, b: 20 } 地址\nn | { a: 10, b: 20 } 地址\n\n第三行通过 n.a 修改了变量，但 m 和 n 仍然指向同一地址不变，因此 m.a 的值也为 15\n\n对于参数传递过程中的内存变化不是本文重点，可以观摩 [JavaScript深入之参数按值传递](https://github.com/mqyqingfeng/Blog/issues/10) 下面精彩的评论来学习。\n\n有很多博文还针对 JavaScript 的内存空间，栈内存与堆内存进行了讲解，但是对于这方面实在没有经验，没什么鉴别能力，暂时先不说了。\n\n###  JavaScript 中的深浅拷贝\n\n回顾完以上知识点后，可以发现对于对象的拷贝，其实分为两种情况（这里，将被拷贝对象称为源对象）：\n\n- shallow clone 浅拷贝：如果对象中某个属性值是对象的话，浅拷贝的只是内存指针，当内存中的值发生变化后，拷贝对象与源对象与都会发生改变。\n- deep clone 深拷贝：拷贝对象与源对象是完全单独的对象，没有属性值是指向同一内存指针的，源对象发生任何修改都不会引起拷贝对象发生变化。\n\n需要注意一点，ES6 中 Object 的新方法 `Object.assign` 执行的就是浅拷贝，Stack Overflow 上有一个高票回答误将其答为深拷贝，我就踩了坑，避免加深错误印象，这里不放链接了。\n\nES6 中的 Object `rest/spread destructuring` 也是浅拷贝：\n\n```javascript\nconst existing = { a: 1, b: 2, c: 3 };\nconst { ...clone } = existing;\n```\n\n对于深拷贝，可想而知，需要对嵌套对象进行递归遍历，但是真正实现 deep clone 没有想象的简单，主要原因在于 deep clone 的定义并不统一，以及 edge case 非常多，包含 DOM/BOM 对象如何处理，函数如何处理，原型链如何处理等问题。但是希望 “做出修改不影响其它引用” 确实是一个常见场景。\n\n最简单的方法就是开头提到的 `JSON.parse(JSON.stringify(target))`。缺点在于无法处理 Date、Function 等类型的属性值。\n\n因此在业务中推荐使用 lodash 的 [_.cloneDeep](https://lodash.com/docs/4.17.4#cloneDeep) 实现深拷贝，简洁可靠。\n\n实际上，在 [immutable.js](http://facebook.github.io/immutable-js/) 出现后，实现数据结构的持久化有了更优雅的方式。\n\n### 希望之光 Immutable\n\n![Immutable](https://camo.githubusercontent.com/4c698f4cef2ae6b69873aa7de91f6d10f28162e1/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69312f544231796b395f4b585858585862565846585845745848387058582d3930302d3334322e706e67)\n\nJavaScript 中的对象一般都是可变的（mutable），虽然节省了内存，却给复杂的大型应用造成很多隐患。Immutable Data 为一旦创建，就不能再被修改的数据。通过 **Persistent Data Structure**（持久化数据结构）使得在使用旧数据创建新数据时，也保证了旧数据同时可用且不变。\n\n前面所述的 deep clone 方法是把所有节点都复制一遍，性能损耗非常大。Immutable 使用了 **Structural Sharing**（结构共享），性能提升很多。\n\n通过 immutable.js 实现 deep clone:\n\n```javascript\nvar defaultConfig = Immutable.fromJS({});\nvar config = defaultConfig.merge(initConfig); // defaultConfig不会改变，返回新值给 config\nvar config = defaultConfig.mergeDeep(initConfig); // 深层merge\n```\n\nimmutable.js 提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record。\n\n虽然 immutable.js 通常与 facebook 同厂出品的 React 一起使用，但是它其实是一个完全独立的库，无论基于什么框架都可以使用。说它是希望之光并没有言过其实。更多内容可以查看 [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3)。\n\n\n\n\n","slug":"review-copy-in-javascript","published":1,"updated":"2018-01-13T13:19:40.000Z","_id":"cjcd8v87t00003t6mt1237fah","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/review-copy-in-javascript.png\" alt=\"cover\"></p>\n<p>最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 <code>JSON.parse(JSON.stringify(target))</code> 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。</p>\n<a id=\"more\"></a>\n<h3 id=\"基本类型-VS-引用类型，值传递-VS-引用传递\"><a href=\"#基本类型-VS-引用类型，值传递-VS-引用传递\" class=\"headerlink\" title=\"基本类型 VS 引用类型，值传递 VS 引用传递\"></a>基本类型 VS 引用类型，值传递 VS 引用传递</h3><p>首先回顾一下高程中的基本概念。</p>\n<p>ECMAScript 变量包含两种数据类型的值：基本类型值与引用类型值。基本类型指的是简单的数据段，如 <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code>（ES6 中出现的 <code>Symbol</code> 也属于基本类型）。引用类型指的是可能由多个值构成的对象。</p>\n<p>基本类型是按值访问的，<strong>可以操作保存在变量中的实际的值</strong>。</p>\n<p>引用类型的值是保存在内存中的对象，<strong>JavaScript 不允许直接访问内存中的位置</strong>，因此我们在操作对象时，是在操作对象的引用而不是实际的对象。</p>\n<p>然而访问变量有按值和按引用两种方式，而 <strong>参数只能按值传递</strong>。在向参数传递引用类型的值时，会把值在内存中的地址复制给另一个局部变量。</p>\n<h3 id=\"深入内存\"><a href=\"#深入内存\" class=\"headerlink\" title=\"深入内存\"></a>深入内存</h3><p>以上虽然不难理解，但是不深层挖掘一下还是很难完全记住。所以来看看内存中到底发生了什么吧。</p>\n<p>先看看内存的生命周期：</p>\n<p><img src=\"https://raw.githubusercontent.com/dt-fe/weekly/master/assets/29/1.jpg\" alt=\"life\"></p>\n<p>即 内存分配 =&gt; 内存读写 =&gt; 内存释放</p>\n<p>JavaScript 在定义变量时即完成了内存分配。<strong>运算符= 就是创建或修改变量在内存中的指向。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123; b: <span class=\"number\">1</span> &#125;; <span class=\"comment\">// a 为引用类型，给 a 分配内存 &#123; b: 1 &#125;， a 存储的即为 &#123; b: 1 &#125; 的地址</span></div><div class=\"line\"><span class=\"keyword\">var</span> c = a; <span class=\"comment\">// 给 c 分配内存 指向 a 存储的地址，即 &#123; b: 1 &#125; 的地址</span></div><div class=\"line\">a = <span class=\"number\">2</span>; <span class=\"comment\">// 修改 a 的内存指向到 2</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// c 存储的仍为 &#123; b: 1 &#125; 的地址，因此结果为 &#123; b: 1 &#125;</span></div></pre></td></tr></table></figure>\n<p>前两行代码在内存中的分布为：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:center\">内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">{ b: 1 } 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">c</td>\n<td style=\"text-align:center\">{ b: 1 } 地址</td>\n</tr>\n</tbody>\n</table>\n<p>第三行修改了内存指向：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:center\">内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n</tbody>\n</table>\n<p>变量 c 仍然指向 { b: 1 } 的地址。</p>\n<p>再看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = &#123; a: <span class=\"number\">10</span>, b: <span class=\"number\">20</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> n = m; <span class=\"comment\">// 复制引用类型的值，使 n 和 m 指向同一地址</span></div><div class=\"line\">n.a = <span class=\"number\">15</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(m.a);</div></pre></td></tr></table></figure>\n<p>还是先看前两行：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:center\">内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">{ a: 10, b: 20 } 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">n</td>\n<td style=\"text-align:center\">{ a: 10, b: 20 } 地址</td>\n</tr>\n</tbody>\n</table>\n<p>第三行通过 n.a 修改了变量，但 m 和 n 仍然指向同一地址不变，因此 m.a 的值也为 15</p>\n<p>对于参数传递过程中的内存变化不是本文重点，可以观摩 <a href=\"https://github.com/mqyqingfeng/Blog/issues/10\" target=\"_blank\" rel=\"external\">JavaScript深入之参数按值传递</a> 下面精彩的评论来学习。</p>\n<p>有很多博文还针对 JavaScript 的内存空间，栈内存与堆内存进行了讲解，但是对于这方面实在没有经验，没什么鉴别能力，暂时先不说了。</p>\n<h3 id=\"JavaScript-中的深浅拷贝\"><a href=\"#JavaScript-中的深浅拷贝\" class=\"headerlink\" title=\"JavaScript 中的深浅拷贝\"></a>JavaScript 中的深浅拷贝</h3><p>回顾完以上知识点后，可以发现对于对象的拷贝，其实分为两种情况（这里，将被拷贝对象称为源对象）：</p>\n<ul>\n<li>shallow clone 浅拷贝：如果对象中某个属性值是对象的话，浅拷贝的只是内存指针，当内存中的值发生变化后，拷贝对象与源对象与都会发生改变。</li>\n<li>deep clone 深拷贝：拷贝对象与源对象是完全单独的对象，没有属性值是指向同一内存指针的，源对象发生任何修改都不会引起拷贝对象发生变化。</li>\n</ul>\n<p>需要注意一点，ES6 中 Object 的新方法 <code>Object.assign</code> 执行的就是浅拷贝，Stack Overflow 上有一个高票回答误将其答为深拷贝，我就踩了坑，避免加深错误印象，这里不放链接了。</p>\n<p>ES6 中的 Object <code>rest/spread destructuring</code> 也是浅拷贝：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> existing = &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; ...clone &#125; = existing;</div></pre></td></tr></table></figure>\n<p>对于深拷贝，可想而知，需要对嵌套对象进行递归遍历，但是真正实现 deep clone 没有想象的简单，主要原因在于 deep clone 的定义并不统一，以及 edge case 非常多，包含 DOM/BOM 对象如何处理，函数如何处理，原型链如何处理等问题。但是希望 “做出修改不影响其它引用” 确实是一个常见场景。</p>\n<p>最简单的方法就是开头提到的 <code>JSON.parse(JSON.stringify(target))</code>。缺点在于无法处理 Date、Function 等类型的属性值。</p>\n<p>因此在业务中推荐使用 lodash 的 <a href=\"https://lodash.com/docs/4.17.4#cloneDeep\" target=\"_blank\" rel=\"external\">_.cloneDeep</a> 实现深拷贝，简洁可靠。</p>\n<p>实际上，在 <a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"external\">immutable.js</a> 出现后，实现数据结构的持久化有了更优雅的方式。</p>\n<h3 id=\"希望之光-Immutable\"><a href=\"#希望之光-Immutable\" class=\"headerlink\" title=\"希望之光 Immutable\"></a>希望之光 Immutable</h3><p><img src=\"https://camo.githubusercontent.com/4c698f4cef2ae6b69873aa7de91f6d10f28162e1/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69312f544231796b395f4b585858585862565846585845745848387058582d3930302d3334322e706e67\" alt=\"Immutable\"></p>\n<p>JavaScript 中的对象一般都是可变的（mutable），虽然节省了内存，却给复杂的大型应用造成很多隐患。Immutable Data 为一旦创建，就不能再被修改的数据。通过 <strong>Persistent Data Structure</strong>（持久化数据结构）使得在使用旧数据创建新数据时，也保证了旧数据同时可用且不变。</p>\n<p>前面所述的 deep clone 方法是把所有节点都复制一遍，性能损耗非常大。Immutable 使用了 <strong>Structural Sharing</strong>（结构共享），性能提升很多。</p>\n<p>通过 immutable.js 实现 deep clone:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> defaultConfig = Immutable.fromJS(&#123;&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> config = defaultConfig.merge(initConfig); <span class=\"comment\">// defaultConfig不会改变，返回新值给 config</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = defaultConfig.mergeDeep(initConfig); <span class=\"comment\">// 深层merge</span></div></pre></td></tr></table></figure>\n<p>immutable.js 提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record。</p>\n<p>虽然 immutable.js 通常与 facebook 同厂出品的 React 一起使用，但是它其实是一个完全独立的库，无论基于什么框架都可以使用。说它是希望之光并没有言过其实。更多内容可以查看 <a href=\"https://github.com/camsong/blog/issues/3\" target=\"_blank\" rel=\"external\">Immutable 详解及 React 中实践</a>。</p>\n","excerpt":"<p><img src=\"/images/review-copy-in-javascript.png\" alt=\"cover\"></p>\n<p>最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 <code>JSON.parse(JSON.stringify(target))</code> 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。</p>","more":"<h3 id=\"基本类型-VS-引用类型，值传递-VS-引用传递\"><a href=\"#基本类型-VS-引用类型，值传递-VS-引用传递\" class=\"headerlink\" title=\"基本类型 VS 引用类型，值传递 VS 引用传递\"></a>基本类型 VS 引用类型，值传递 VS 引用传递</h3><p>首先回顾一下高程中的基本概念。</p>\n<p>ECMAScript 变量包含两种数据类型的值：基本类型值与引用类型值。基本类型指的是简单的数据段，如 <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code>（ES6 中出现的 <code>Symbol</code> 也属于基本类型）。引用类型指的是可能由多个值构成的对象。</p>\n<p>基本类型是按值访问的，<strong>可以操作保存在变量中的实际的值</strong>。</p>\n<p>引用类型的值是保存在内存中的对象，<strong>JavaScript 不允许直接访问内存中的位置</strong>，因此我们在操作对象时，是在操作对象的引用而不是实际的对象。</p>\n<p>然而访问变量有按值和按引用两种方式，而 <strong>参数只能按值传递</strong>。在向参数传递引用类型的值时，会把值在内存中的地址复制给另一个局部变量。</p>\n<h3 id=\"深入内存\"><a href=\"#深入内存\" class=\"headerlink\" title=\"深入内存\"></a>深入内存</h3><p>以上虽然不难理解，但是不深层挖掘一下还是很难完全记住。所以来看看内存中到底发生了什么吧。</p>\n<p>先看看内存的生命周期：</p>\n<p><img src=\"https://raw.githubusercontent.com/dt-fe/weekly/master/assets/29/1.jpg\" alt=\"life\"></p>\n<p>即 内存分配 =&gt; 内存读写 =&gt; 内存释放</p>\n<p>JavaScript 在定义变量时即完成了内存分配。<strong>运算符= 就是创建或修改变量在内存中的指向。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123; b: <span class=\"number\">1</span> &#125;; <span class=\"comment\">// a 为引用类型，给 a 分配内存 &#123; b: 1 &#125;， a 存储的即为 &#123; b: 1 &#125; 的地址</span></div><div class=\"line\"><span class=\"keyword\">var</span> c = a; <span class=\"comment\">// 给 c 分配内存 指向 a 存储的地址，即 &#123; b: 1 &#125; 的地址</span></div><div class=\"line\">a = <span class=\"number\">2</span>; <span class=\"comment\">// 修改 a 的内存指向到 2</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// c 存储的仍为 &#123; b: 1 &#125; 的地址，因此结果为 &#123; b: 1 &#125;</span></div></pre></td></tr></table></figure>\n<p>前两行代码在内存中的分布为：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:center\">内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">{ b: 1 } 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">c</td>\n<td style=\"text-align:center\">{ b: 1 } 地址</td>\n</tr>\n</tbody>\n</table>\n<p>第三行修改了内存指向：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:center\">内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n</tbody>\n</table>\n<p>变量 c 仍然指向 { b: 1 } 的地址。</p>\n<p>再看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = &#123; a: <span class=\"number\">10</span>, b: <span class=\"number\">20</span> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> n = m; <span class=\"comment\">// 复制引用类型的值，使 n 和 m 指向同一地址</span></div><div class=\"line\">n.a = <span class=\"number\">15</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(m.a);</div></pre></td></tr></table></figure>\n<p>还是先看前两行：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:center\">内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">{ a: 10, b: 20 } 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">n</td>\n<td style=\"text-align:center\">{ a: 10, b: 20 } 地址</td>\n</tr>\n</tbody>\n</table>\n<p>第三行通过 n.a 修改了变量，但 m 和 n 仍然指向同一地址不变，因此 m.a 的值也为 15</p>\n<p>对于参数传递过程中的内存变化不是本文重点，可以观摩 <a href=\"https://github.com/mqyqingfeng/Blog/issues/10\">JavaScript深入之参数按值传递</a> 下面精彩的评论来学习。</p>\n<p>有很多博文还针对 JavaScript 的内存空间，栈内存与堆内存进行了讲解，但是对于这方面实在没有经验，没什么鉴别能力，暂时先不说了。</p>\n<h3 id=\"JavaScript-中的深浅拷贝\"><a href=\"#JavaScript-中的深浅拷贝\" class=\"headerlink\" title=\"JavaScript 中的深浅拷贝\"></a>JavaScript 中的深浅拷贝</h3><p>回顾完以上知识点后，可以发现对于对象的拷贝，其实分为两种情况（这里，将被拷贝对象称为源对象）：</p>\n<ul>\n<li>shallow clone 浅拷贝：如果对象中某个属性值是对象的话，浅拷贝的只是内存指针，当内存中的值发生变化后，拷贝对象与源对象与都会发生改变。</li>\n<li>deep clone 深拷贝：拷贝对象与源对象是完全单独的对象，没有属性值是指向同一内存指针的，源对象发生任何修改都不会引起拷贝对象发生变化。</li>\n</ul>\n<p>需要注意一点，ES6 中 Object 的新方法 <code>Object.assign</code> 执行的就是浅拷贝，Stack Overflow 上有一个高票回答误将其答为深拷贝，我就踩了坑，避免加深错误印象，这里不放链接了。</p>\n<p>ES6 中的 Object <code>rest/spread destructuring</code> 也是浅拷贝：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> existing = &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; ...clone &#125; = existing;</div></pre></td></tr></table></figure>\n<p>对于深拷贝，可想而知，需要对嵌套对象进行递归遍历，但是真正实现 deep clone 没有想象的简单，主要原因在于 deep clone 的定义并不统一，以及 edge case 非常多，包含 DOM/BOM 对象如何处理，函数如何处理，原型链如何处理等问题。但是希望 “做出修改不影响其它引用” 确实是一个常见场景。</p>\n<p>最简单的方法就是开头提到的 <code>JSON.parse(JSON.stringify(target))</code>。缺点在于无法处理 Date、Function 等类型的属性值。</p>\n<p>因此在业务中推荐使用 lodash 的 <a href=\"https://lodash.com/docs/4.17.4#cloneDeep\">_.cloneDeep</a> 实现深拷贝，简洁可靠。</p>\n<p>实际上，在 <a href=\"http://facebook.github.io/immutable-js/\">immutable.js</a> 出现后，实现数据结构的持久化有了更优雅的方式。</p>\n<h3 id=\"希望之光-Immutable\"><a href=\"#希望之光-Immutable\" class=\"headerlink\" title=\"希望之光 Immutable\"></a>希望之光 Immutable</h3><p><img src=\"https://camo.githubusercontent.com/4c698f4cef2ae6b69873aa7de91f6d10f28162e1/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69312f544231796b395f4b585858585862565846585845745848387058582d3930302d3334322e706e67\" alt=\"Immutable\"></p>\n<p>JavaScript 中的对象一般都是可变的（mutable），虽然节省了内存，却给复杂的大型应用造成很多隐患。Immutable Data 为一旦创建，就不能再被修改的数据。通过 <strong>Persistent Data Structure</strong>（持久化数据结构）使得在使用旧数据创建新数据时，也保证了旧数据同时可用且不变。</p>\n<p>前面所述的 deep clone 方法是把所有节点都复制一遍，性能损耗非常大。Immutable 使用了 <strong>Structural Sharing</strong>（结构共享），性能提升很多。</p>\n<p>通过 immutable.js 实现 deep clone:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> defaultConfig = Immutable.fromJS(&#123;&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> config = defaultConfig.merge(initConfig); <span class=\"comment\">// defaultConfig不会改变，返回新值给 config</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = defaultConfig.mergeDeep(initConfig); <span class=\"comment\">// 深层merge</span></div></pre></td></tr></table></figure>\n<p>immutable.js 提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record。</p>\n<p>虽然 immutable.js 通常与 facebook 同厂出品的 React 一起使用，但是它其实是一个完全独立的库，无论基于什么框架都可以使用。说它是希望之光并没有言过其实。更多内容可以查看 <a href=\"https://github.com/camsong/blog/issues/3\">Immutable 详解及 React 中实践</a>。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cja54xyhw0001gbehmqau1haz","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyit000agbehauwg9wdq"},{"post_id":"cja54xyii0007gbehic4gndcd","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyix000dgbehm1fay252"},{"post_id":"cja54xyiq0009gbeh4e817jo9","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyiz000fgbehukmvyj3i"},{"post_id":"cja54xyi20003gbeh1y55q7o2","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyj1000igbehsr1be1q1"},{"post_id":"cja54xyiu000bgbehy4do6g12","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyj6000kgbehfcym128j"},{"post_id":"cja54xyid0005gbeh6pmgmo53","category_id":"cja54xyiv000cgbeh72jb2eo5","_id":"cja54xyjc000ngbehnnpj2o7d"},{"post_id":"cja54xyiz000ggbeh0u7od6ax","category_id":"cja54xyiv000cgbeh72jb2eo5","_id":"cja54xyjf000pgbehgjcim9b3"},{"post_id":"cja54xyj2000jgbehrdeduzop","category_id":"cja54xyiv000cgbeh72jb2eo5","_id":"cja54xyjj000sgbehcosw3q38"},{"post_id":"cja54xyig0006gbeh35200ek7","category_id":"cja54xyj1000hgbehdyjocij9","_id":"cja54xyjn000ugbehfjjtk8ce"},{"post_id":"cja54xyix000egbeh6m2rdqbd","category_id":"cja54xyja000mgbeh23zzdp0m","_id":"cja54xyjp000wgbehhk13skie"},{"post_id":"cja54xyjf000qgbehtpo16xsj","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyjs000zgbehpy21n216"},{"post_id":"cja54xyjk000tgbehdso4kdho","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyju0011gbeh89xx4ob8"},{"post_id":"cja54xyj7000lgbehwzurecyj","category_id":"cja54xyjj000rgbeh7t1mq4xs","_id":"cja54xyjw0014gbehwcmgazb6"},{"post_id":"cja54xyjp000xgbehn223xoyn","category_id":"cja54xyia0004gbeh9upwye82","_id":"cja54xyk00016gbeh3reux4h8"},{"post_id":"cja54xyjs0010gbehn2f6ug9b","category_id":"cja54xyjj000rgbeh7t1mq4xs","_id":"cja54xyk80018gbeh6x4nun3w"},{"post_id":"cja54xyjc000ogbehceyfwznd","category_id":"cja54xyjq000ygbehot4dbikz","_id":"cja54xyka001bgbehh77abtuk"},{"post_id":"cja54xyju0012gbehkpixmrsq","category_id":"cja54xyiv000cgbeh72jb2eo5","_id":"cja54xykc001dgbehd728ytoe"},{"post_id":"cja54xyjw0015gbehtcrwqbbc","category_id":"cja54xyiv000cgbeh72jb2eo5","_id":"cja54xykc001egbeh2si8eli6"},{"post_id":"cja54xyjo000vgbehn18cbf9c","category_id":"cja54xyjw0013gbeh39hnmytv","_id":"cja54xykc001ggbehyl3x475b"},{"post_id":"cja54xyk10017gbehsogxs6av","category_id":"cja54xyka001agbehej9amkv3","_id":"cja54xykc001hgbehz4fzy3b4"},{"post_id":"cja54xyk90019gbehaoex7omj","category_id":"cja54xykc001fgbehoel3yoza","_id":"cja54xykd001jgbehhlu3tylc"},{"post_id":"cja54xykb001cgbehh8cxh7uu","category_id":"cja54xykc001igbehik50btus","_id":"cja54xykd001kgbehicfu9yvf"},{"post_id":"cjbuug4no00007j6myudlxcg8","category_id":"cjbuug4nv00017j6mwm2jw15u","_id":"cjbuug4og00027j6mt7p06qdd"},{"post_id":"cjcd8v87t00003t6mt1237fah","category_id":"cja54xyiv000cgbeh72jb2eo5","_id":"cjcd8v88200013t6m71qr1hk4"}],"PostTag":[],"Tag":[]}}