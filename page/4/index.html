<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Minibase</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.colafornia.me/atom.xml" title="Minibase"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/colafornia" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/high-performance-javascript-b/" class="post-title-link">阅读《高性能JavaScript》(下)</a></h2><div class="post-info">Oct 3, 2016</div><div class="post-content"><p><img src="/images/javascript-is-fast.png" alt="cover"></p>
<p>接<a href="https://blog.colafornia.me/2016/09/26/high-performance-javascript-a/">前四节的总结</a></p>
<h2 id="5-字符串和正则表达式"><a href="#5-字符串和正则表达式" class="headerlink" title="5.字符串和正则表达式"></a>5.字符串和正则表达式</h2><h4 id="字符串构建原理"><a href="#字符串构建原理" class="headerlink" title="字符串构建原理"></a>字符串构建原理</h4><p><code>str += &#39;one&#39; + &#39;two&#39;</code></p>
<p>这行代码运行时会经历四个步骤：</p>
<blockquote>
<p>1.在内存中创建一个临时字符串<br>2.链接后的字符串 ‘onetwo’ 被赋值给该临时字符串<br>3.临时字符串与 str 当前值连接<br>4.结果赋给 str</p>
</blockquote></div><a href="/post/2016/high-performance-javascript-b/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/high-performance-javascript-a/" class="post-title-link">阅读《高性能JavaScript》(上)</a></h2><div class="post-info">Sep 26, 2016</div><div class="post-content"><p><img src="https://img1.doubanio.com/lpic/s28879959.jpg" alt="cover"></p>
<p>这篇只包含前四章节。</p>
<h2 id="1-加载与执行"><a href="#1-加载与执行" class="headerlink" title="1.加载与执行"></a>1.加载与执行</h2><p>浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。</p>
<p>减少脚本执行对性能影响的方法：</p>
<ul>
<li>把所有 <code>&lt;script&gt;</code> 标签尽可能放到 <code>&lt;body&gt;</code> 标签底部。</li>
<li>合并脚本，减少HTTP请求带来的额外性能开销。</li>
<li>无阻塞下载执行JavaScript脚本：<ul>
<li><code>&lt;script&gt;</code> 的 <code>defer</code> 属性可以使脚本下载后先不执行，老版本浏览器不支持</li>
<li>书中未提到的 HTML5 <code>async</code> 属性可以使脚本异步加载执行</li>
<li>使用XHR对象动态加载脚本</li>
</ul>
</li>
</ul></div><a href="/post/2016/high-performance-javascript-a/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/basic-fetch-api/" class="post-title-link">一些关于 fetch api 的基本设定</a></h2><div class="post-info">Aug 22, 2016</div><div class="post-content"><p>长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api <code>Fetch</code>来替换它。</p>
<h3 id="XMLHttpRequest的缺陷"><a href="#XMLHttpRequest的缺陷" class="headerlink" title="XMLHttpRequest的缺陷"></a>XMLHttpRequest的缺陷</h3><p>先看一个典型的XHR例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">'GET'</span>, url);</div><div class="line">xhr.responseType = <span class="string">'json'</span>;</div><div class="line"></div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(xhr.response);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Booo"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p>
<p>可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。</p></div><a href="/post/2016/basic-fetch-api/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/browser-cache-summary/" class="post-title-link">关于浏览器缓存</a></h2><div class="post-info">Jul 18, 2016</div><div class="post-content"><p>浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。</p>
<p>浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置<code>meta标签</code>来实现。</p>
<h2 id="与缓存相关的首部字段"><a href="#与缓存相关的首部字段" class="headerlink" title="与缓存相关的首部字段"></a>与缓存相关的首部字段</h2><p><img src="http://o7ts2uaks.bkt.clouddn.com/CACHE.png" alt="http首部字段"></p></div><a href="/post/2016/browser-cache-summary/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/git-rebase-workflow/" class="post-title-link">避免脏pr：使用git rebase避免无谓的merge</a></h2><div class="post-info">Jun 9, 2016</div><div class="post-content"><h3 id="问题复现与解决"><a href="#问题复现与解决" class="headerlink" title="问题复现与解决"></a>问题复现与解决</h3><p>在团队开发中，由于git使用的不够合理规范，开pr之后就会发现其中掺杂着若干merge的commit:</p>
<p><img src="http://o7ts2uaks.bkt.clouddn.com/git-merge.jpg" alt="commit history"></p>
<p>事实上我们本地的branch和远端的branch会同步地非常频繁，这两个分支几乎完全同步，所以以上的merge动作是没有必要的。并且如果一个pr中存在merge，那么pr的files changed中就会看到merge目标的代码。这会给代码 Review 的工作代码困扰。因为代码reviewm时通常是看一个pr修改了哪些代码，现在pr中满是merge目标的代码，是没办法review的。</p>
<p>想要解决这个问题的关键是永远不要merge主分支，而是rebase主分支。</p></div><a href="/post/2016/git-rebase-workflow/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/angular-data-binding/" class="post-title-link">How does data binding work in AngularJS</a></h2><div class="post-info">Jun 5, 2016</div><div class="post-content"><p>AngularJS可以记住value值并且会把它和之前的value值进行比较。这就是基本的脏检查机制。如果某处的value值发生了变化，那么AngularJS就会触发指定事件。</p>
<p><code>$apply()</code>这个方法是用来处理AngularJS框架之外的表达式的，与它相辅相成的还有<code>$digest()</code>方法。一次digest就是一次完全的脏检查，它可以运行在所有的浏览器中。</p>
<h3 id="关于-watch"><a href="#关于-watch" class="headerlink" title="关于$watch"></a>关于$watch</h3><p>每一次你在UI中绑定什么东西时你就会往<code>$watch</code>的队列中插入一条<code>$watch</code>，想象一下$watch就是在所监测的model中可以侦查数据变化的东西。比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User: &lt;input type=&quot;text&quot; ng-model=&quot;user&quot; /&gt;</div><div class="line">Password: &lt;input type=&quot;password&quot; ng-model=&quot;pass&quot; /&gt;</div></pre></td></tr></table></figure>
<p>在这里我们分别给两个input绑定了$scope.user和$scope.pass，就是说我们向$watch队列添加了两个$watch。</p></div><a href="/post/2016/angular-data-binding/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/vieport-percentage/" class="post-title-link">Viewport-Percentage (or Viewport-Relative) Lengths</a></h2><div class="post-info">Mar 17, 2016</div><div class="post-content"><h3 id="什么是视区百分比长度（viewport-percentage-lengths）？"><a href="#什么是视区百分比长度（viewport-percentage-lengths）？" class="headerlink" title="什么是视区百分比长度（viewport-percentage lengths）？"></a>什么是视区百分比长度（viewport-percentage lengths）？</h3><p>先看一下W3C给出的定义：</p>
<blockquote>
<p>The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>
</blockquote>
<p>意为视区百分比长度是与其包含块的尺寸有关，并且是随之变化的。<code>initial containing block</code>意为浏览器内部的可视区域，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p></div><a href="/post/2016/vieport-percentage/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/trans-javascript-code-tips/" class="post-title-link">[译]JavaScript最佳实践：提高代码质量的技巧和建议</a></h2><div class="post-info">Mar 13, 2016</div><div class="post-content"><p>原文地址：<a href="https://www.codementor.io/javascript/tutorial/javascript-best-practices">https://www.codementor.io/javascript/tutorial/javascript-best-practices</a></p>
<p><img src="https://www.filepicker.io/api/file/e4jxgEgHRzS1zQU6aJLR" alt="image"><br>每天学习新知识可以让我们变成一个更优秀更理性的人。作为一名开发者，持续学习也是我们工作的一部分，无论如何，这些新知识的学习过程都是积极有益的经验积累。</p>
<p>在这篇教程中，我会提出一些JavaScript的最佳实践，你就不会觉得学习起来很困难了。准备好了就来一起升级你的代码吧！</p>
<h3 id="1-避免污染全局作用域"><a href="#1-避免污染全局作用域" class="headerlink" title="1.避免污染全局作用域"></a>1.避免污染全局作用域</h3><p>声明变量的过程中有很多有趣的地方。有的时候，你可能在不知情的情况下却声明了一个<code>全局变量</code>。在现代浏览器中，全局变量会被储存在<code>window</code>对象中，因此会有很多内容运行在其中，你不知情声明的全局变量可能会覆盖掉一些默认值。</p></div><a href="/post/2016/trans-javascript-code-tips/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/cookie-localstorage-session/" class="post-title-link">Cookie, LocalStorage 与 SessionStorage</a></h2><div class="post-info">Mar 10, 2016</div><div class="post-content"><p>有关Cookie, LocalStorage 与 SessionStorage的基本概念，区别，共同点，各自的应用场景。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递，是随HTTP请求一起被传递的额外数据。主要用途有保存登陆信息，大多数浏览器支持最大为 4096 字节的 Cookie</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术,大小限制在500万字符左右，各个浏览器不一致。永久有效，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p></div><a href="/post/2016/cookie-localstorage-session/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/learning-clouser-scope/" class="post-title-link">有关闭包，作用域，this对象</a></h2><div class="post-info">Jan 2, 2016</div><div class="post-content"><h3 id="首先看一下维基百科中，闭包的概念："><a href="#首先看一下维基百科中，闭包的概念：" class="headerlink" title="首先看一下维基百科中，闭包的概念："></a>首先看一下维基百科中，闭包的概念：</h3><blockquote>
<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。<br>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>
</blockquote>
<h4 id="在创建函数和调用函数时，都发生了什么"><a href="#在创建函数和调用函数时，都发生了什么" class="headerlink" title="在创建函数和调用函数时，都发生了什么"></a>在创建函数和调用函数时，都发生了什么</h4><ul>
<li>创建函数时<ol>
<li>创建了预先包含全局变量对象的作用域链</li>
<li>该作用域链保存在内部[[scope]]属性中</li>
</ol>
</li>
<li>调用函数时<ol>
<li>创建执行环境</li>
<li>复制函数[[scope]]属性中的对象构建作用域链</li>
<li>用arguments与其它形参初始化函数的活动对象</li>
</ol>
</li>
</ul></div><a href="/post/2016/learning-clouser-scope/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/3/" class="prev">PREV</a><a href="/page/5/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2023 <a href="https://blog.colafornia.me">Colafornia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-84469017-1",'auto');ga('send','pageview');</script></body></html>